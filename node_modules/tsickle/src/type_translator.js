/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/type_translator", ["require", "exports", "path", "tsickle/src/externs", "tsickle/src/jsdoc_transformer", "tsickle/src/transformer_util", "tsickle/src/typescript"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var path = require("path");
    var externs_1 = require("tsickle/src/externs");
    var jsdoc_transformer_1 = require("tsickle/src/jsdoc_transformer");
    var transformer_util_1 = require("tsickle/src/transformer_util");
    var ts = require("tsickle/src/typescript");
    /**
     * TypeScript allows you to write identifiers quoted, like:
     *   interface Foo {
     *     'bar': string;
     *     'complex name': string;
     *   }
     *   Foo.bar;  // ok
     *   Foo['bar']  // ok
     *   Foo['complex name']  // ok
     *
     * In Closure-land, we want identify that the legal name 'bar' can become an
     * ordinary field, but we need to skip strings like 'complex name'.
     */
    function isValidClosurePropertyName(name) {
        // In local experimentation, it appears that reserved words like 'var' and
        // 'if' are legal JS and still accepted by Closure.
        return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(name);
    }
    exports.isValidClosurePropertyName = isValidClosurePropertyName;
    /**
     * Determines if fileName refers to a builtin lib.d.ts file.
     * This is a terrible hack but it mirrors a similar thing done in Clutz.
     */
    function isBuiltinLibDTS(fileName) {
        return fileName.match(/\blib\.(?:[^/]+\.)?d\.ts$/) != null;
    }
    exports.isBuiltinLibDTS = isBuiltinLibDTS;
    /**
     * @return True if the named type is considered compatible with the Closure-defined
     *     type of the same name, e.g. "Array".  Note that we don't actually enforce
     *     that the types are actually compatible, but mostly just hope that they are due
     *     to being derived from the same HTML specs.
     */
    function isClosureProvidedType(symbol) {
        return symbol.declarations != null &&
            symbol.declarations.some(function (n) { return isBuiltinLibDTS(n.getSourceFile().fileName); });
    }
    function typeToDebugString(type) {
        var e_1, _a, e_2, _b;
        var debugString = "flags:0x" + type.flags.toString(16);
        if (type.aliasSymbol) {
            debugString += " alias:" + symbolToDebugString(type.aliasSymbol);
        }
        if (type.aliasTypeArguments) {
            debugString += " aliasArgs:<" + type.aliasTypeArguments.map(typeToDebugString).join(',') + ">";
        }
        // Just the unique flags (powers of two). Declared in src/compiler/types.ts.
        var basicTypes = [
            ts.TypeFlags.Any, ts.TypeFlags.String, ts.TypeFlags.Number,
            ts.TypeFlags.Boolean, ts.TypeFlags.Enum, ts.TypeFlags.StringLiteral,
            ts.TypeFlags.NumberLiteral, ts.TypeFlags.BooleanLiteral, ts.TypeFlags.EnumLiteral,
            ts.TypeFlags.ESSymbol, ts.TypeFlags.UniqueESSymbol, ts.TypeFlags.Void,
            ts.TypeFlags.Undefined, ts.TypeFlags.Null, ts.TypeFlags.Never,
            ts.TypeFlags.TypeParameter, ts.TypeFlags.Object, ts.TypeFlags.Union,
            ts.TypeFlags.Intersection, ts.TypeFlags.Index, ts.TypeFlags.IndexedAccess,
            ts.TypeFlags.Conditional, ts.TypeFlags.Substitution,
        ];
        try {
            for (var basicTypes_1 = __values(basicTypes), basicTypes_1_1 = basicTypes_1.next(); !basicTypes_1_1.done; basicTypes_1_1 = basicTypes_1.next()) {
                var flag = basicTypes_1_1.value;
                if ((type.flags & flag) !== 0) {
                    debugString += " " + ts.TypeFlags[flag];
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (basicTypes_1_1 && !basicTypes_1_1.done && (_a = basicTypes_1.return)) _a.call(basicTypes_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (type.flags === ts.TypeFlags.Object) {
            var objType = type;
            debugString += " objectFlags:0x" + objType.objectFlags;
            // Just the unique flags (powers of two). Declared in src/compiler/types.ts.
            var objectFlags = [
                ts.ObjectFlags.Class,
                ts.ObjectFlags.Interface,
                ts.ObjectFlags.Reference,
                ts.ObjectFlags.Tuple,
                ts.ObjectFlags.Anonymous,
                ts.ObjectFlags.Mapped,
                ts.ObjectFlags.Instantiated,
                ts.ObjectFlags.ObjectLiteral,
                ts.ObjectFlags.EvolvingArray,
                ts.ObjectFlags.ObjectLiteralPatternWithComputedProperties,
            ];
            try {
                for (var objectFlags_1 = __values(objectFlags), objectFlags_1_1 = objectFlags_1.next(); !objectFlags_1_1.done; objectFlags_1_1 = objectFlags_1.next()) {
                    var flag = objectFlags_1_1.value;
                    if ((objType.objectFlags & flag) !== 0) {
                        debugString += " object:" + ts.ObjectFlags[flag];
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (objectFlags_1_1 && !objectFlags_1_1.done && (_b = objectFlags_1.return)) _b.call(objectFlags_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        if (type.symbol && type.symbol.name !== '__type') {
            debugString += " symbol.name:" + JSON.stringify(type.symbol.name);
        }
        if (type.pattern) {
            debugString += " destructuring:true";
        }
        return "{type " + debugString + "}";
    }
    exports.typeToDebugString = typeToDebugString;
    function symbolToDebugString(sym) {
        var e_3, _a;
        var debugString = JSON.stringify(sym.name) + " flags:0x" + sym.flags.toString(16);
        // Just the unique flags (powers of two). Declared in src/compiler/types.ts.
        var symbolFlags = [
            ts.SymbolFlags.FunctionScopedVariable,
            ts.SymbolFlags.BlockScopedVariable,
            ts.SymbolFlags.Property,
            ts.SymbolFlags.EnumMember,
            ts.SymbolFlags.Function,
            ts.SymbolFlags.Class,
            ts.SymbolFlags.Interface,
            ts.SymbolFlags.ConstEnum,
            ts.SymbolFlags.RegularEnum,
            ts.SymbolFlags.ValueModule,
            ts.SymbolFlags.NamespaceModule,
            ts.SymbolFlags.TypeLiteral,
            ts.SymbolFlags.ObjectLiteral,
            ts.SymbolFlags.Method,
            ts.SymbolFlags.Constructor,
            ts.SymbolFlags.GetAccessor,
            ts.SymbolFlags.SetAccessor,
            ts.SymbolFlags.Signature,
            ts.SymbolFlags.TypeParameter,
            ts.SymbolFlags.TypeAlias,
            ts.SymbolFlags.ExportValue,
            ts.SymbolFlags.Alias,
            ts.SymbolFlags.Prototype,
            ts.SymbolFlags.ExportStar,
            ts.SymbolFlags.Optional,
            ts.SymbolFlags.Transient,
        ];
        try {
            for (var symbolFlags_1 = __values(symbolFlags), symbolFlags_1_1 = symbolFlags_1.next(); !symbolFlags_1_1.done; symbolFlags_1_1 = symbolFlags_1.next()) {
                var flag = symbolFlags_1_1.value;
                if ((sym.flags & flag) !== 0) {
                    debugString += " " + ts.SymbolFlags[flag];
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (symbolFlags_1_1 && !symbolFlags_1_1.done && (_a = symbolFlags_1.return)) _a.call(symbolFlags_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return debugString;
    }
    exports.symbolToDebugString = symbolToDebugString;
    /**
     * Searches for an ambient module declaration in the ancestors of declarations, depth first, and
     * returns the first or null if none found.
     */
    function getContainingAmbientModuleDeclaration(declarations) {
        var e_4, _a;
        try {
            for (var declarations_1 = __values(declarations), declarations_1_1 = declarations_1.next(); !declarations_1_1.done; declarations_1_1 = declarations_1.next()) {
                var declaration = declarations_1_1.value;
                var parent_1 = declaration.parent;
                while (parent_1) {
                    if (ts.isModuleDeclaration(parent_1) && ts.isStringLiteral(parent_1.name)) {
                        return parent_1;
                    }
                    parent_1 = parent_1.parent;
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (declarations_1_1 && !declarations_1_1.done && (_a = declarations_1.return)) _a.call(declarations_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return null;
    }
    /** Returns true if any of declarations is a top level declaration in an external module. */
    function isTopLevelExternal(declarations) {
        var e_5, _a;
        try {
            for (var declarations_2 = __values(declarations), declarations_2_1 = declarations_2.next(); !declarations_2_1.done; declarations_2_1 = declarations_2.next()) {
                var declaration = declarations_2_1.value;
                if (declaration.parent === undefined)
                    continue;
                if (ts.isSourceFile(declaration.parent) && ts.isExternalModule(declaration.parent))
                    return true;
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (declarations_2_1 && !declarations_2_1.done && (_a = declarations_2.return)) _a.call(declarations_2);
            }
            finally { if (e_5) throw e_5.error; }
        }
        return false;
    }
    /**
     * Returns true if a and b are (or were originally before transformation) nodes of the same source
     * file.
     */
    function isDeclaredInSameFile(a, b) {
        return ts.getOriginalNode(a).getSourceFile() === ts.getOriginalNode(b).getSourceFile();
    }
    /** TypeTranslator translates TypeScript types to Closure types. */
    var TypeTranslator = /** @class */ (function () {
        /**
         * @param node is the source AST ts.Node the type comes from.  This is used
         *     in some cases (e.g. anonymous types) for looking up field names.
         * @param pathBlackList is a set of paths that should never get typed;
         *     any reference to symbols defined in these paths should by typed
         *     as {?}.
         * @param symbolsToAliasedNames a mapping from symbols (`Foo`) to a name in scope they should be
         *     emitted as (e.g. `tsickle_forward_declare_1.Foo`). Can be augmented during type
         *     translation, e.g. to blacklist a symbol.
         */
        function TypeTranslator(host, typeChecker, node, pathBlackList, symbolsToAliasedNames, ensureSymbolDeclared) {
            if (symbolsToAliasedNames === void 0) { symbolsToAliasedNames = new Map(); }
            if (ensureSymbolDeclared === void 0) { ensureSymbolDeclared = function () { }; }
            this.host = host;
            this.typeChecker = typeChecker;
            this.node = node;
            this.pathBlackList = pathBlackList;
            this.symbolsToAliasedNames = symbolsToAliasedNames;
            this.ensureSymbolDeclared = ensureSymbolDeclared;
            /**
             * A list of type literals we've encountered while emitting; used to avoid getting stuck in
             * recursive types.
             */
            this.seenAnonymousTypes = new Set();
            /**
             * Whether to write types suitable for an \@externs file. Externs types must not refer to
             * non-externs types (i.e. non ambient types) and need to use fully qualified names.
             */
            this.isForExterns = false;
            // Normalize paths to not break checks on Windows.
            if (this.pathBlackList != null) {
                this.pathBlackList =
                    new Set(Array.from(this.pathBlackList.values()).map(function (p) { return path.normalize(p); }));
            }
        }
        /**
         * Converts a ts.Symbol to a string.
         * Other approaches that don't work:
         * - TypeChecker.typeToString translates Array as T[].
         * - TypeChecker.symbolToString emits types without their namespace,
         *   and doesn't let you pass the flag to control that.
         * @param useFqn whether to scope the name using its fully qualified name. Closure's template
         *     arguments are always scoped to the class containing them, where TypeScript's template args
         *     would be fully qualified. I.e. this flag is false for generic types.
         */
        TypeTranslator.prototype.symbolToString = function (sym, useFqn) {
            var _this = this;
            // TypeScript resolves e.g. union types to their members, which can include symbols not declared
            // in the current scope. Ensure that all symbols found this way are actually declared.
            // This must happen before the alias check below, it might introduce a new alias for the symbol.
            if (!this.isForExterns && (sym.flags & ts.SymbolFlags.TypeParameter) === 0) {
                this.ensureSymbolDeclared(sym);
            }
            // This follows getSingleLineStringWriter in the TypeScript compiler.
            var str = '';
            function writeText(text) {
                str += text;
            }
            var writeSymbol = function (text, symbol) {
                // When writing a symbol, check if there is an alias for it in the current scope that should
                // take precedence, e.g. from a goog.forwardDeclare.
                if (symbol.flags & ts.SymbolFlags.Alias) {
                    symbol = _this.typeChecker.getAliasedSymbol(symbol);
                }
                var alias = _this.symbolsToAliasedNames.get(symbol);
                if (alias) {
                    // If so, discard the entire current text and only use the alias - otherwise if a symbol has
                    // a local alias but appears in a dotted type path (e.g. when it's imported using import *
                    // as foo), str would contain both the prefx *and* the full alias (foo.alias.name).
                    str = alias;
                    return;
                }
                if (str.length === 0) {
                    var mangledPrefix = _this.maybeGetMangledNamePrefix(symbol);
                    text = mangledPrefix + text;
                }
                str += text;
            };
            var doNothing = function () {
                return;
            };
            var builder = this.typeChecker.getSymbolDisplayBuilder();
            var writer = {
                writeSymbol: writeSymbol,
                writeKeyword: writeText,
                writeOperator: writeText,
                writePunctuation: writeText,
                writeSpace: writeText,
                writeStringLiteral: writeText,
                writeParameter: writeText,
                writeProperty: writeText,
                writeLine: doNothing,
                increaseIndent: doNothing,
                decreaseIndent: doNothing,
                clear: doNothing,
                trackSymbol: function (symbol, enclosingDeclaration, meaning) {
                    return;
                },
                reportInaccessibleThisError: doNothing,
                reportPrivateInBaseOfClassExpression: doNothing,
            };
            builder.buildSymbolDisplay(sym, writer, this.node);
            return this.stripClutzNamespace(str);
        };
        /**
         * Returns the mangled name prefix for symbol, or an empty string if not applicable.
         *
         * Type names are emitted with a mangled prefix if they are top level symbols declared in an
         * external module (.d.ts or .ts), and are ambient declarations ("declare ..."). This is because
         * their declarations get moved to externs files (to make external names visible to Closure and
         * prevent renaming), which only use global names. This means the names must be mangled to prevent
         * collisions and allow referencing them uniquely.
         *
         * This method also handles the special case of symbols declared in an ambient external module
         * context.
         *
         * Symbols declared in a global block, e.g. "declare global { type X; }", are handled implicitly:
         * when referenced, they are written as just "X", which is not a top level declaration, so the
         * code below ignores them.
         */
        TypeTranslator.prototype.maybeGetMangledNamePrefix = function (symbol) {
            var _this = this;
            if (!symbol.declarations)
                return '';
            var declarations = symbol.declarations;
            var ambientModuleDeclaration = null;
            // If the symbol is neither a top level declaration in an external module nor in an ambient
            // block, tsickle should not emit a prefix: it's either not an external symbol, or it's an
            // external symbol nested in a module, so it will need to be qualified, and the mangling prefix
            // goes on the qualifier.
            if (!isTopLevelExternal(declarations)) {
                ambientModuleDeclaration = getContainingAmbientModuleDeclaration(declarations);
                if (!ambientModuleDeclaration)
                    return '';
            }
            // At this point, the declaration is from an external module (possibly ambient).
            // These declarations must be prefixed if either:
            // (a) tsickle is emitting an externs file, so all symbols are qualified within it
            // (b) or the declaration must be an exported ambient declaration from the local file.
            // Ambient external declarations from other files are imported, so there's a local alias for the
            // module and no mangling is needed.
            if (!this.isForExterns &&
                !declarations.every(function (d) { return isDeclaredInSameFile(_this.node, d) && jsdoc_transformer_1.isAmbient(d) &&
                    transformer_util_1.hasModifierFlag(d, ts.ModifierFlags.Export); })) {
                return '';
            }
            // If from an ambient declaration, use and resolve the name from that. Otherwise, use the file
            // name from the (arbitrary) first declaration to mangle.
            var fileName = ambientModuleDeclaration ?
                ambientModuleDeclaration.name.text :
                ts.getOriginalNode(declarations[0]).getSourceFile().fileName;
            var mangled = externs_1.moduleNameAsIdentifier(this.host, fileName, this.node.getSourceFile().fileName);
            return mangled + '.';
        };
        // Clutz (https://github.com/angular/clutz) emits global type symbols hidden in a special
        // ಠ_ಠ.clutz namespace. While most code seen by Tsickle will only ever see local aliases, Clutz
        // symbols can be written by users directly in code, and they can appear by dereferencing
        // TypeAliases. The code below simply strips the prefix, the remaining type name then matches
        // Closure's type.
        TypeTranslator.prototype.stripClutzNamespace = function (name) {
            if (name.startsWith('ಠ_ಠ.clutz.'))
                return name.substring('ಠ_ಠ.clutz.'.length);
            return name;
        };
        TypeTranslator.prototype.translate = function (type) {
            // NOTE: Though type.flags has the name "flags", it usually can only be one
            // of the enum options at a time (except for unions of literal types, e.g. unions of boolean
            // values, string values, enum values). This switch handles all the cases in the ts.TypeFlags
            // enum in the order they occur.
            var e_6, _a;
            // NOTE: Some TypeFlags are marked "internal" in the d.ts but still show up in the value of
            // type.flags. This mask limits the flag checks to the ones in the public API. "lastFlag" here
            // is the last flag handled in this switch statement, and should be kept in sync with
            // typescript.d.ts.
            // NonPrimitive occurs on its own on the lower case "object" type. Special case to "!Object".
            if (type.flags === ts.TypeFlags.NonPrimitive)
                return '!Object';
            // Avoid infinite loops on recursive type literals.
            // It would be nice to just emit the name of the recursive type here (in type.aliasSymbol
            // below), but Closure Compiler does not allow recursive type definitions.
            if (this.seenAnonymousTypes.has(type))
                return '?';
            var isAmbient = false;
            var isInNamespace = false;
            var isModule = false;
            if (type.symbol) {
                try {
                    for (var _b = __values(type.symbol.declarations || []), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var decl = _c.value;
                        if (ts.isExternalModule(decl.getSourceFile()))
                            isModule = true;
                        var current = decl;
                        while (current) {
                            if (ts.getCombinedModifierFlags(current) & ts.ModifierFlags.Ambient)
                                isAmbient = true;
                            if (current.kind === ts.SyntaxKind.ModuleDeclaration)
                                isInNamespace = true;
                            current = current.parent;
                        }
                    }
                }
                catch (e_6_1) { e_6 = { error: e_6_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_6) throw e_6.error; }
                }
            }
            // tsickle cannot generate types for non-ambient namespaces nor any symbols contained in them.
            if (isInNamespace && !isAmbient)
                return '?';
            // Types in externs cannot reference types from external modules.
            // However ambient types in modules get moved to externs, too, so type references work and we
            // can emit a precise type.
            if (this.isForExterns && isModule && !isAmbient)
                return '?';
            var lastFlag = ts.TypeFlags.Substitution;
            var mask = (lastFlag << 1) - 1;
            switch (type.flags & mask) {
                case ts.TypeFlags.Any:
                    return '?';
                case ts.TypeFlags.String:
                case ts.TypeFlags.StringLiteral:
                    return 'string';
                case ts.TypeFlags.Number:
                case ts.TypeFlags.NumberLiteral:
                    return 'number';
                case ts.TypeFlags.Boolean:
                case ts.TypeFlags.BooleanLiteral:
                    // See the note in translateUnion about booleans.
                    return 'boolean';
                case ts.TypeFlags.Enum:
                    if (!type.symbol) {
                        this.warn("EnumType without a symbol");
                        return '?';
                    }
                    return this.symbolToString(type.symbol, true);
                case ts.TypeFlags.ESSymbol:
                case ts.TypeFlags.UniqueESSymbol:
                    // ESSymbol indicates something typed symbol.
                    // UniqueESSymbol indicates a specific unique symbol, used e.g. to index into an object.
                    // Closure does not have this distinction, so tsickle emits both as 'symbol'.
                    return 'symbol';
                case ts.TypeFlags.Void:
                    return 'void';
                case ts.TypeFlags.Undefined:
                    return 'undefined';
                case ts.TypeFlags.Null:
                    return 'null';
                case ts.TypeFlags.Never:
                    this.warn("should not emit a 'never' type");
                    return '?';
                case ts.TypeFlags.TypeParameter:
                    // This is e.g. the T in a type like Foo<T>.
                    if (!type.symbol) {
                        this.warn("TypeParameter without a symbol"); // should not happen (tm)
                        return '?';
                    }
                    // In Closure Compiler, type parameters *are* scoped to their containing class.
                    var useFqn = false;
                    return this.symbolToString(type.symbol, useFqn);
                case ts.TypeFlags.Object:
                    return this.translateObject(type);
                case ts.TypeFlags.Union:
                    return this.translateUnion(type);
                case ts.TypeFlags.Conditional:
                case ts.TypeFlags.Substitution:
                    this.warn("emitting ? for conditional/substitution type");
                    return '?';
                case ts.TypeFlags.Intersection:
                case ts.TypeFlags.Index:
                case ts.TypeFlags.IndexedAccess:
                    // TODO(ts2.1): handle these special types.
                    this.warn("unhandled type flags: " + ts.TypeFlags[type.flags]);
                    return '?';
                default:
                    // Handle cases where multiple flags are set.
                    // Types with literal members are represented as
                    //   ts.TypeFlags.Union | [literal member]
                    // E.g. an enum typed value is a union type with the enum's members as its members. A
                    // boolean type is a union type with 'true' and 'false' as its members.
                    // Note also that in a more complex union, e.g. boolean|number, then it's a union of three
                    // things (true|false|number) and ts.TypeFlags.Boolean doesn't show up at all.
                    if (type.flags & ts.TypeFlags.Union) {
                        return this.translateUnion(type);
                    }
                    if (type.flags & ts.TypeFlags.EnumLiteral) {
                        return this.translateEnumLiteral(type);
                    }
                    // The switch statement should have been exhaustive.
                    throw new Error("unknown type flags " + type.flags + " on " + typeToDebugString(type));
            }
        };
        TypeTranslator.prototype.translateUnion = function (type) {
            var _this = this;
            var parts = type.types.map(function (t) { return _this.translate(t); });
            // Union types that include literals (e.g. boolean, enum) can end up repeating the same Closure
            // type. For example: true | boolean will be translated to boolean | boolean.
            // Remove duplicates to produce types that read better.
            parts = parts.filter(function (el, idx) { return parts.indexOf(el) === idx; });
            return parts.length === 1 ? parts[0] : "(" + parts.join('|') + ")";
        };
        TypeTranslator.prototype.translateEnumLiteral = function (type) {
            // Suppose you had:
            //   enum EnumType { MEMBER }
            // then the type of "EnumType.MEMBER" is an enum literal (the thing passed to this function)
            // and it has type flags that include
            //   ts.TypeFlags.NumberLiteral | ts.TypeFlags.EnumLiteral
            //
            // Closure Compiler doesn't support literals in types, so this code must not emit
            // "EnumType.MEMBER", but rather "EnumType".
            var enumLiteralBaseType = this.typeChecker.getBaseTypeOfLiteralType(type);
            if (!enumLiteralBaseType.symbol) {
                this.warn("EnumLiteralType without a symbol");
                return '?';
            }
            return this.symbolToString(enumLiteralBaseType.symbol, true);
        };
        // translateObject translates a ts.ObjectType, which is the type of all
        // object-like things in TS, such as classes and interfaces.
        TypeTranslator.prototype.translateObject = function (type) {
            var _this = this;
            if (type.symbol && this.isBlackListed(type.symbol))
                return '?';
            // NOTE: objectFlags is an enum, but a given type can have multiple flags.
            // Array<string> is both ts.ObjectFlags.Reference and ts.ObjectFlags.Interface.
            if (type.objectFlags & ts.ObjectFlags.Class) {
                if (!type.symbol) {
                    this.warn('class has no symbol');
                    return '?';
                }
                var name_1 = this.symbolToString(type.symbol, /* useFqn */ true);
                if (name_1 === '(Anonymous class)') {
                    // Values that have anonymous class types produce this name, but the type
                    // appears otherwise identical to a named class.  Given that the type is
                    // anonymous here, there's not really a useful name we can emit.
                    return '?';
                }
                return '!' + name_1;
            }
            else if (type.objectFlags & ts.ObjectFlags.Interface) {
                // Note: ts.InterfaceType has a typeParameters field, but that
                // specifies the parameters that the interface type *expects*
                // when it's used, and should not be transformed to the output.
                // E.g. a type like Array<number> is a TypeReference to the
                // InterfaceType "Array", but the "number" type parameter is
                // part of the outer TypeReference, not a typeParameter on
                // the InterfaceType.
                if (!type.symbol) {
                    this.warn('interface has no symbol');
                    return '?';
                }
                if (type.symbol.flags & ts.SymbolFlags.Value) {
                    // The symbol is both a type and a value.
                    // For user-defined types in this state, we don't have a Closure name
                    // for the type.  See the type_and_value test.
                    if (!isClosureProvidedType(type.symbol)) {
                        this.warn("type/symbol conflict for " + type.symbol.name + ", using {?} for now");
                        return '?';
                    }
                }
                return '!' + this.symbolToString(type.symbol, /* useFqn */ true);
            }
            else if (type.objectFlags & ts.ObjectFlags.Reference) {
                // A reference to another type, e.g. Array<number> refers to Array.
                // Emit the referenced type and any type arguments.
                var referenceType = type;
                // A tuple is a ReferenceType where the target is flagged Tuple and the
                // typeArguments are the tuple arguments.  Just treat it as a mystery
                // array, because Closure doesn't understand tuples.
                if (referenceType.target.objectFlags & ts.ObjectFlags.Tuple) {
                    return '!Array<?>';
                }
                var typeStr = '';
                if (referenceType.target === referenceType) {
                    // We get into an infinite loop here if the inner reference is
                    // the same as the outer; this can occur when this function
                    // fails to translate a more specific type before getting to
                    // this point.
                    throw new Error("reference loop in " + typeToDebugString(referenceType) + " " + referenceType.flags);
                }
                typeStr += this.translate(referenceType.target);
                // Translate can return '?' for a number of situations, e.g. type/value conflicts.
                // `?<?>` is illegal syntax in Closure Compiler, so just return `?` here.
                if (typeStr === '?')
                    return '?';
                if (referenceType.typeArguments) {
                    var params = referenceType.typeArguments.map(function (t) { return _this.translate(t); });
                    typeStr += "<" + params.join(', ') + ">";
                }
                return typeStr;
            }
            else if (type.objectFlags & ts.ObjectFlags.Anonymous) {
                if (!type.symbol) {
                    // This comes up when generating code for an arrow function as passed
                    // to a generic function.  The passed-in type is tagged as anonymous
                    // and has no properties so it's hard to figure out what to generate.
                    // Just avoid it for now so we don't crash.
                    this.warn('anonymous type has no symbol');
                    return '?';
                }
                if (type.symbol.flags & ts.SymbolFlags.Function ||
                    type.symbol.flags & ts.SymbolFlags.Method) {
                    var sigs = this.typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);
                    if (sigs.length === 1) {
                        return this.signatureToClosure(sigs[0]);
                    }
                    this.warn('unhandled anonymous type with multiple call signatures');
                    return '?';
                }
                else {
                    return this.translateAnonymousType(type);
                }
            }
            /*
            TODO(ts2.1): more unhandled object type flags:
              Tuple
              Mapped
              Instantiated
              ObjectLiteral
              EvolvingArray
              ObjectLiteralPatternWithComputedProperties
            */
            this.warn("unhandled type " + typeToDebugString(type));
            return '?';
        };
        /**
         * translateAnonymousType translates a ts.TypeFlags.ObjectType that is also
         * ts.ObjectFlags.Anonymous. That is, this type's symbol does not have a name. This is the
         * anonymous type encountered in e.g.
         *     let x: {a: number};
         * But also the inferred type in:
         *     let x = {a: 1};  // type of x is {a: number}, as above
         */
        TypeTranslator.prototype.translateAnonymousType = function (type) {
            var e_7, _a;
            this.seenAnonymousTypes.add(type);
            // Gather up all the named fields and whether the object is also callable.
            var callable = false;
            var indexable = false;
            var fields = [];
            if (!type.symbol || !type.symbol.members) {
                this.warn('anonymous type has no symbol');
                return '?';
            }
            // special-case construct signatures.
            var ctors = type.getConstructSignatures();
            if (ctors.length) {
                // TODO(martinprobst): this does not support additional properties defined on constructors
                // (not expressible in Closure), nor multiple constructors (same).
                var decl = ctors[0].declaration;
                if (!decl) {
                    this.warn('unhandled anonymous type with constructor signature but no declaration');
                    return '?';
                }
                if (decl.kind === ts.SyntaxKindJSDocSignature) {
                    this.warn('unhandled JSDoc based constructor signature');
                    return '?';
                }
                // new <T>(tee: T) is not supported by Closure, blacklist as ?.
                this.blacklistTypeParameters(this.symbolsToAliasedNames, decl.typeParameters);
                var params = this.convertParams(ctors[0], decl.parameters);
                var paramsStr = params.length ? (', ' + params.join(', ')) : '';
                var constructedType = this.translate(ctors[0].getReturnType());
                // In the specific case of the "new" in a function, it appears that
                //   function(new: !Bar)
                // fails to parse, while
                //   function(new: (!Bar))
                // parses in the way you'd expect.
                // It appears from testing that Closure ignores the ! anyway and just
                // assumes the result will be non-null in either case.  (To be pedantic,
                // it's possible to return null from a ctor it seems like a bad idea.)
                return "function(new: (" + constructedType + ")" + paramsStr + "): ?";
            }
            try {
                // members is an ES6 map, but the .d.ts defining it defined their own map
                // type, so typescript doesn't believe that .keys() is iterable
                // tslint:disable-next-line:no-any
                for (var _b = __values(type.symbol.members.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var field = _c.value;
                    switch (field) {
                        case '__call':
                            callable = true;
                            break;
                        case '__index':
                            indexable = true;
                            break;
                        default:
                            if (!isValidClosurePropertyName(field)) {
                                this.warn("omitting inexpressible property name: " + field);
                                continue;
                            }
                            var member = type.symbol.members.get(field);
                            // optional members are handled by the type including |undefined in a union type.
                            var memberType = this.translate(this.typeChecker.getTypeOfSymbolAtLocation(member, this.node));
                            fields.push(field + ": " + memberType);
                            break;
                    }
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_7) throw e_7.error; }
            }
            // Try to special-case plain key-value objects and functions.
            if (fields.length === 0) {
                if (callable && !indexable) {
                    // A function type.
                    var sigs = this.typeChecker.getSignaturesOfType(type, ts.SignatureKind.Call);
                    if (sigs.length === 1) {
                        return this.signatureToClosure(sigs[0]);
                    }
                }
                else if (indexable && !callable) {
                    // A plain key-value map type.
                    var keyType = 'string';
                    var valType = this.typeChecker.getIndexTypeOfType(type, ts.IndexKind.String);
                    if (!valType) {
                        keyType = 'number';
                        valType = this.typeChecker.getIndexTypeOfType(type, ts.IndexKind.Number);
                    }
                    if (!valType) {
                        this.warn('unknown index key type');
                        return "!Object<?,?>";
                    }
                    return "!Object<" + keyType + "," + this.translate(valType) + ">";
                }
                else if (!callable && !indexable) {
                    // Special-case the empty object {} because Closure doesn't like it.
                    // TODO(evanm): revisit this if it is a problem.
                    return '!Object';
                }
            }
            if (!callable && !indexable) {
                // Not callable, not indexable; implies a plain object with fields in it.
                return "{" + fields.join(', ') + "}";
            }
            this.warn('unhandled anonymous type');
            return '?';
        };
        /** Converts a ts.Signature (function signature) to a Closure function type. */
        TypeTranslator.prototype.signatureToClosure = function (sig) {
            // TODO(martinprobst): Consider harmonizing some overlap with emitFunctionType in tsickle.ts.
            if (!sig.declaration) {
                this.warn('signature without declaration');
                return 'Function';
            }
            if (sig.declaration.kind === ts.SyntaxKindJSDocSignature) {
                this.warn('signature with JSDoc declaration');
                return 'Function';
            }
            this.blacklistTypeParameters(this.symbolsToAliasedNames, sig.declaration.typeParameters);
            var typeStr = "function(";
            var paramDecls = sig.declaration.parameters || [];
            var maybeThisParam = paramDecls[0];
            // Oddly, the this type shows up in paramDecls, but not in the type's parameters.
            // Handle it here and then pass paramDecls down without its first element.
            if (maybeThisParam && maybeThisParam.name.getText() === 'this') {
                if (maybeThisParam.type) {
                    var thisType = this.typeChecker.getTypeAtLocation(maybeThisParam.type);
                    typeStr += "this: (" + this.translate(thisType) + ")";
                    if (paramDecls.length > 1)
                        typeStr += ', ';
                }
                else {
                    this.warn('this type without type');
                }
                paramDecls = paramDecls.slice(1);
            }
            var params = this.convertParams(sig, paramDecls);
            typeStr += params.join(', ') + ")";
            var retType = this.translate(this.typeChecker.getReturnTypeOfSignature(sig));
            if (retType) {
                typeStr += ": " + retType;
            }
            return typeStr;
        };
        /**
         * Converts parameters for the given signature. Takes parameter declarations as those might not
         * match the signature parameters (e.g. there might be an additional this parameter). This
         * difference is handled by the caller, as is converting the "this" parameter.
         */
        TypeTranslator.prototype.convertParams = function (sig, paramDecls) {
            var paramTypes = [];
            for (var i = 0; i < sig.parameters.length; i++) {
                var param = sig.parameters[i];
                var paramDecl = paramDecls[i];
                var optional = !!paramDecl.questionToken;
                var varArgs = !!paramDecl.dotDotDotToken;
                var paramType = this.typeChecker.getTypeOfSymbolAtLocation(param, this.node);
                if (varArgs) {
                    var typeRef = paramType;
                    paramType = typeRef.typeArguments[0];
                }
                var typeStr = this.translate(paramType);
                if (varArgs)
                    typeStr = '...' + typeStr;
                if (optional)
                    typeStr = typeStr + '=';
                paramTypes.push(typeStr);
            }
            return paramTypes;
        };
        TypeTranslator.prototype.warn = function (msg) {
            // By default, warn() does nothing.  The caller will overwrite this
            // if it wants different behavior.
        };
        /** @return true if sym should always have type {?}. */
        TypeTranslator.prototype.isBlackListed = function (symbol) {
            if (this.pathBlackList === undefined)
                return false;
            var pathBlackList = this.pathBlackList;
            // Some builtin types, such as {}, get represented by a symbol that has no declarations.
            if (symbol.declarations === undefined)
                return false;
            return symbol.declarations.every(function (n) {
                var fileName = path.normalize(n.getSourceFile().fileName);
                return pathBlackList.has(fileName);
            });
        };
        /**
         * Closure doesn not support type parameters for function types, i.e. generic function types.
         * Blacklist the symbols declared by them and emit a ? for the types.
         *
         * This mutates the given blacklist map. The map's scope is one file, and symbols are
         * unique objects, so this should neither lead to excessive memory consumption nor introduce
         * errors.
         *
         * @param blacklist a map to store the blacklisted symbols in, with a value of '?'. In practice,
         *     this is always === this.symbolsToAliasedNames, but we're passing it explicitly to make it
         *    clear that the map is mutated (in particular when used from outside the class).
         * @param decls the declarations whose symbols should be blacklisted.
         */
        TypeTranslator.prototype.blacklistTypeParameters = function (blacklist, decls) {
            var e_8, _a;
            if (!decls || !decls.length)
                return;
            try {
                for (var decls_1 = __values(decls), decls_1_1 = decls_1.next(); !decls_1_1.done; decls_1_1 = decls_1.next()) {
                    var tpd = decls_1_1.value;
                    var sym = this.typeChecker.getSymbolAtLocation(tpd.name);
                    if (!sym) {
                        this.warn("type parameter with no symbol");
                        continue;
                    }
                    this.symbolsToAliasedNames.set(sym, '?');
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (decls_1_1 && !decls_1_1.done && (_a = decls_1.return)) _a.call(decls_1);
                }
                finally { if (e_8) throw e_8.error; }
            }
        };
        return TypeTranslator;
    }());
    exports.TypeTranslator = TypeTranslator;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZV90cmFuc2xhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL3R5cGVfdHJhbnNsYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFFSCwyQkFBNkI7SUFFN0IsK0NBQWlEO0lBQ2pELG1FQUE2RDtJQUM3RCxpRUFBbUQ7SUFDbkQsMkNBQW1DO0lBRW5DOzs7Ozs7Ozs7Ozs7T0FZRztJQUNILG9DQUEyQyxJQUFZO1FBQ3JELDBFQUEwRTtRQUMxRSxtREFBbUQ7UUFDbkQsT0FBTywwQkFBMEIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUpELGdFQUlDO0lBRUQ7OztPQUdHO0lBQ0gseUJBQWdDLFFBQWdCO1FBQzlDLE9BQU8sUUFBUSxDQUFDLEtBQUssQ0FBQywyQkFBMkIsQ0FBQyxJQUFJLElBQUksQ0FBQztJQUM3RCxDQUFDO0lBRkQsMENBRUM7SUFFRDs7Ozs7T0FLRztJQUNILCtCQUErQixNQUFpQjtRQUM5QyxPQUFPLE1BQU0sQ0FBQyxZQUFZLElBQUksSUFBSTtZQUM5QixNQUFNLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxVQUFBLENBQUMsSUFBSSxPQUFBLGVBQWUsQ0FBQyxDQUFDLENBQUMsYUFBYSxFQUFFLENBQUMsUUFBUSxDQUFDLEVBQTNDLENBQTJDLENBQUMsQ0FBQztJQUNqRixDQUFDO0lBRUQsMkJBQWtDLElBQWE7O1FBQzdDLElBQUksV0FBVyxHQUFHLGFBQVcsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFHLENBQUM7UUFFdkQsSUFBSSxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ3BCLFdBQVcsSUFBSSxZQUFVLG1CQUFtQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUcsQ0FBQztTQUNsRTtRQUNELElBQUksSUFBSSxDQUFDLGtCQUFrQixFQUFFO1lBQzNCLFdB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QyxDQUFDLENBQUMsQ0FBQztRQUNMLENBQUM7UUFFRDs7Ozs7Ozs7Ozs7O1dBWUc7UUFDSCxnREFBdUIsR0FBdkIsVUFDSSxTQUFpQyxFQUNqQyxLQUEyRDs7WUFDN0QsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNO2dCQUFFLE9BQU87O2dCQUNwQyxLQUFrQixJQUFBLFVBQUEsU0FBQSxLQUFLLENBQUEsNEJBQUEsK0NBQUU7b0JBQXBCLElBQU0sR0FBRyxrQkFBQTtvQkFDWixJQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLG1CQUFtQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDM0QsSUFBSSxDQUFDLEdBQUcsRUFBRTt3QkFDUixJQUFJLENBQUMsSUFBSSxDQUFDLCtCQUErQixDQUFDLENBQUM7d0JBQzNDLFNBQVM7cUJBQ1Y7b0JBQ0QsSUFBSSxDQUFDLHFCQUFxQixDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7aUJBQzFDOzs7Ozs7Ozs7UUFDSCxDQUFDO1FBQ0gscUJBQUM7SUFBRCxDQUFDLEFBeG9CRCxJQXdvQkM7SUF4b0JZLHdDQUFjIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQge21vZHVsZU5hbWVBc0lkZW50aWZpZXJ9IGZyb20gJy4vZXh0ZXJucyc7XG5pbXBvcnQge0Fubm90YXRvckhvc3QsIGlzQW1iaWVudH0gZnJvbSAnLi9qc2RvY190cmFuc2Zvcm1lcic7XG5pbXBvcnQge2hhc01vZGlmaWVyRmxhZ30gZnJvbSAnLi90cmFuc2Zvcm1lcl91dGlsJztcbmltcG9ydCAqIGFzIHRzIGZyb20gJy4vdHlwZXNjcmlwdCc7XG5cbi8qKlxuICogVHlwZVNjcmlwdCBhbGxvd3MgeW91IHRvIHdyaXRlIGlkZW50aWZpZXJzIHF1b3RlZCwgbGlrZTpcbiAqICAgaW50ZXJmYWNlIEZvbyB7XG4gKiAgICAgJ2Jhcic6IHN0cmluZztcbiAqICAgICAnY29tcGxleCBuYW1lJzogc3RyaW5nO1xuICogICB9XG4gKiAgIEZvby5iYXI7ICAvLyBva1xuICogICBGb29bJ2JhciddICAvLyBva1xuICogICBGb29bJ2NvbXBsZXggbmFtZSddICAvLyBva1xuICpcbiAqIEluIENsb3N1cmUtbGFuZCwgd2Ugd2FudCBpZGVudGlmeSB0aGF0IHRoZSBsZWdhbCBuYW1lICdiYXInIGNhbiBiZWNvbWUgYW5cbiAqIG9yZGluYXJ5IGZpZWxkLCBidXQgd2UgbmVlZCB0byBza2lwIHN0cmluZ3MgbGlrZSAnY29tcGxleCBuYW1lJy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRDbG9zdXJlUHJvcGVydHlOYW1lKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAvLyBJbiBsb2NhbCBleHBlcmltZW50YXRpb24sIGl0IGFwcGVhcnMgdGhhdCByZXNlcnZlZCB3b3JkcyBsaWtlICd2YXInIGFuZFxuICAvLyAnaWYnIGFyZSBsZWdhbCBKUyBhbmQgc3RpbGwgYWNjZXB0ZWQgYnkgQ2xvc3VyZS5cbiAgcmV0dXJuIC9eW2EtekEtWl9dW2EtekEtWjAtOV9dKiQvLnRlc3QobmFtZSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBmaWxlTmFtZSByZWZlcnMgdG8gYSBidWlsdGluIGxpYi5kLnRzIGZpbGUuXG4gKiBUaGlzIGlzIGEgdGVycmlibGUgaGFjayBidXQgaXQgbWlycm9ycyBhIHNpbWlsYXIgdGhpbmcgZG9uZSBpbiBDbHV0ei5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnVpbHRpbkxpYkRUUyhmaWxlTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBmaWxlTmFtZS5tYXRjaCgvXFxibGliXFwuKD86W14vXStcXC4pP2RcXC50cyQvKSAhPSBudWxsO1xufVxuXG4vKipcbiAqIEByZXR1cm4gVHJ1ZSBpZiB0aGUgbmFtZWQgdHlwZSBpcyBjb25zaWRlcmVkIGNvbXBhdGlibGUgd2l0aCB0aGUgQ2xvc3VyZS1kZWZpbmVkXG4gKiAgICAgdHlwZSBvZiB0aGUgc2FtZSBuYW1lLCBlLmcuIFwiQXJyYXlcIi4gIE5vdGUgdGhhdCB3ZSBkb24ndCBhY3R1YWxseSBlbmZvcmNlXG4gKiAgICAgdGhhdCB0aGUgdHlwZXMgYXJlIGFjdHVhbGx5IGNvbXBhdGlibGUsIGJ1dCBtb3N0bHkganVzdCBob3BlIHRoYXQgdGhleSBhcmUgZHVlXG4gKiAgICAgdG8gYmVpbmcgZGVyaXZlZCBmcm9tIHRoZSBzYW1lIEhUTUwgc3BlY3MuXG4gKi9cbmZ1bmN0aW9uIGlzQ2xvc3VyZVByb3ZpZGVkVHlwZShzeW1ib2w6IHRzLlN5bWJvbCk6IGJvb2xlYW4ge1xuICByZXR1cm4gc3ltYm9sLmRlY2xhcmF0aW9ucyAhPSBudWxsICYmXG4gICAgICBzeW1ib2wuZGVjbGFyYXRpb25zLnNvbWUobiA9PiBpc0J1aWx0aW5MaWJEVFMobi5nZXRTb3VyY2VGaWxlKCkuZmlsZU5hbWUpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHR5cGVUb0RlYnVnU3RyaW5nKHR5cGU6IHRzLlR5cGUpOiBzdHJpbmcge1xuICBsZXQgZGVidWdTdHJpbmcgPSBgZmxhZ3M6MHgke3R5cGUuZmxhZ3MudG9TdHJpbmcoMTYpfWA7XG5cbiAgaWYgKHR5cGUuYWxpYXNTeW1ib2wpIHtcbiAgICBkZWJ1Z1N0cmluZyArPSBgIGFsaWFzOiR7c3ltYm9sVG9EZWJ1Z1N0cmluZyh0eXBlLmFsaWFzU3ltYm9sKX1gO1xuICB9XG4gIGlmICh0eXBlLmFsaWFzVHlwZUFyZ3VtZW50cykge1xuICAgIGRlYnVnU3RyaW5nICs9IGAgYWxpYXNBcmdzOjwke3R5cGUuYWxpYXNUeXBlQXJndW1lbnRzLm1hcCh0eXBlVG9EZWJ1Z1N0cmluZykuam9pbignLCcpfT5gO1xuICB9XG5cbiAgLy8gSnVzdCB0aGUgdW5pcXVlIGZsYWdzIChwb3dlcnMgb2YgdHdvKS4gRGVjbGFyZWQgaW4gc3JjL2NvbXBpbGVyL3R5cGVzLnRzLlxuICBjb25zdCBiYXNpY1R5cGVzOiB0cy5UeXBlRmxhZ3NbXSA9IFtcbiAgICB0cy5UeXBlRmxhZ3MuQW55LCAgICAgICAgICAgdHMuVHlwZUZsYWdzLlN0cmluZywgICAgICAgICB0cy5UeXBlRmxhZ3MuTnVtYmVyLFxuICAgIHRzLlR5cGVGbGFncy5Cb29sZWFuLCAgICAgICB0cy5UeXBlRmxhZ3MuRW51bSwgICAgICAgICAgIHRzLlR5cGVGbGFncy5TdHJpbmdMaXRlcmFsLFxuICAgIHRzLlR5cGVGbGFncy5OdW1iZXJMaXRlcmFsLCB0cy5UeXBlRmxhZ3MuQm9vbGVhbkxpdGVyYWwsIHRzLlR5cGVGbGFncy5FbnVtTGl0ZXJhbCxcbiAgICB0cy5UeXBlRmxhZ3MuRVNTeW1ib2wsICAgICAgdHMuVHlwZUZsYWdzLlVuaXF1ZUVTU3ltYm9sLCB0cy5UeXBlRmxhZ3MuVm9pZCxcbiAgICB0cy5UeXBlRmxhZ3MuVW5kZWZpbmVkLCAgICAgdHMuVHlwZUZsYWdzLk51bGwsICAgICAgICAgICB0cy5UeXBlRmxhZ3MuTmV2ZXIsXG4gICAgdHMuVHlwZUZsYWdzLlR5cGVQYXJhbWV0ZXIsIHRzLlR5cGVGbGFncy5PYmplY3QsICAgICAgICAgdHMuVHlwZUZsYWdzLlVuaW9uLFxuICAgIHRzLlR5cGVGbGFncy5JbnRlcnNlY3Rpb24sICB0cy5UeXBlRmxhZ3MuSW5kZXgsICAgICAgICAgIHRzLlR5cGVGbGFncy5JbmRleGVkQWNjZXNzLFxuICAgIHRzLlR5cGVGbGFncy5Db25kaXRpb25hbCwgICB0cy5UeXBlRmxhZ3MuU3Vic3RpdHV0aW9uLFxuICBdO1xuICBmb3IgKGNvbnN0IGZsYWcgb2YgYmFzaWNUeXBlcykge1xuICAgIGlmICgodHlwZS5mbGFncyAmIGZsYWcpICE9PSAwKSB7XG4gICAgICBkZWJ1Z1N0cmluZyArPSBgICR7dHMuVHlwZUZsYWdzW2ZsYWddfWA7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUuZmxhZ3MgPT09IHRzLlR5cGVGbGFncy5PYmplY3QpIHtcbiAgICBjb25zdCBvYmpUeXBlID0gdHlwZSBhcyB0cy5PYmplY3RUeXBlO1xuICAgIGRlYnVnU3RyaW5nICs9IGAgb2JqZWN0RmxhZ3M6MHgke29ialR5cGUub2JqZWN0RmxhZ3N9YDtcbiAgICAvLyBKdXN0IHRoZSB1bmlxdWUgZmxhZ3MgKHBvd2VycyBvZiB0d28pLiBEZWNsYXJlZCBpbiBzcmMvY29tcGlsZXIvdHlwZXMudHMuXG4gICAgY29uc3Qgb2JqZWN0RmxhZ3M6IHRzLk9iamVjdEZsYWdzW10gPSBbXG4gICAgICB0cy5PYmplY3RGbGFncy5DbGFzcyxcbiAgICAgIHRzLk9iamVjdEZsYWdzLkludGVyZmFjZSxcbiAgICAgIHRzLk9iamVjdEZsYWdzLlJlZmVyZW5jZSxcbiAgICAgIHRzLk9iamVjdEZsYWdzLlR1cGxlLFxuICAgICAgdHMuT2JqZWN0RmxhZ3MuQW5vbnltb3VzLFxuICAgICAgdHMuT2JqZWN0RmxhZ3MuTWFwcGVkLFxuICAgICAgdHMuT2JqZWN0RmxhZ3MuSW5zdGFudGlhdGVkLFxuICAgICAgdHMuT2JqZWN0RmxhZ3MuT2JqZWN0TGl0ZXJhbCxcbiAgICAgIHRzLk9iamVjdEZsYWdzLkV2b2x2aW5nQXJyYXksXG4gICAgICB0cy5PYmplY3RGbGFncy5PYmplY3RMaXRlcmFsUGF0dGVybldpdGhDb21wdXRlZFByb3BlcnRpZXMsXG4gICAgXTtcbiAgICBmb3IgKGNvbnN0IGZsYWcgb2Ygb2JqZWN0RmxhZ3MpIHtcbiAgICAgIGlmICgob2JqVHlwZS5vYmplY3RGbGFncyAmIGZsYWcpICE9PSAwKSB7XG4gICAgICAgIGRlYnVnU3RyaW5nICs9IGAgb2JqZWN0OiR7dHMuT2JqZWN0RmxhZ3NbZmxhZ119YDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZS5zeW1ib2wgJiYgdHlwZS5zeW1ib2wubmFtZSAhPT0gJ19fdHlwZScpIHtcbiAgICBkZWJ1Z1N0cmluZyArPSBgIHN5bWJvbC5uYW1lOiR7SlNPTi5zdHJpbmdpZnkodHlwZS5zeW1ib2wubmFtZSl9YDtcbiAgfVxuXG4gIGlmICh0eXBlLnBhdHRlcm4pIHtcbiAgICBkZWJ1Z1N0cmluZyArPSBgIGRlc3RydWN0dXJpbmc6dHJ1ZWA7XG4gIH1cblxuICByZXR1cm4gYHt0eXBlICR7ZGVidWdTdHJpbmd9fWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzeW1ib2xUb0RlYnVnU3RyaW5nKHN5bTogdHMuU3ltYm9sKTogc3RyaW5nIHtcbiAgbGV0IGRlYnVnU3RyaW5nID0gYCR7SlNPTi5zdHJpbmdpZnkoc3ltLm5hbWUpfSBmbGFnczoweCR7c3ltLmZsYWdzLnRvU3RyaW5nKDE2KX1gO1xuXG4gIC8vIEp1c3QgdGhlIHVuaXF1ZSBmbGFncyAocG93ZXJzIG9mIHR3bykuIERlY2xhcmVkIGluIHNyYy9jb21waWxlci90eXBlcy50cy5cbiAgY29uc3Qgc3ltYm9sRmxhZ3MgPSBbXG4gICAgdHMuU3ltYm9sRmxhZ3MuRnVuY3Rpb25TY29wZWRWYXJpYWJsZSxcbiAgICB0cy5TeW1ib2xGbGFncy5CbG9ja1Njb3BlZFZhcmlhYmxlLFxuICAgIHRzLlN5bWJvbEZsYWdzLlByb3BlcnR5LFxuICAgIHRzLlN5bWJvbEZsYWdzLkVudW1NZW1iZXIsXG4gICAgdHMuU3ltYm9sRmxhZ3MuRnVuY3Rpb24sXG4gICAgdHMuU3ltYm9sRmxhZ3MuQ2xhc3MsXG4gICAgdHMuU3ltYm9sRmxhZ3MuSW50ZXJmYWNlLFxuICAgIHRzLlN5bWJvbEZsYWdzLkNvbnN0RW51bSxcbiAgICB0cy5TeW1ib2xGbGFncy5SZWd1bGFyRW51bSxcbiAgICB0cy5TeW1ib2xGbGFncy5WYWx1ZU1vZHVsZSxcbiAgICB0cy5TeW1ib2xGbGFncy5OYW1lc3BhY2VNb2R1bGUsXG4gICAgdHMuU3ltYm9sRmxhZ3MuVHlwZUxpdGVyYWwsXG4gICAgdHMuU3ltYm9sRmxhZ3MuT2JqZWN0TGl0ZXJhbCxcbiAgICB0cy5TeW1ib2xGbGFncy5NZXRob2QsXG4gICAgdHMuU3ltYm9sRmxhZ3MuQ29uc3RydWN0b3IsXG4gICAgdHMuU3ltYm9sRmxhZ3MuR2V0QWNjZXNzb3IsXG4gICAgdHMuU3ltYm9sRmxhZ3MuU2V0QWNjZXNzb3IsXG4gICAgdHMuU3ltYm9sRmxhZ3MuU2lnbmF0dXJlLFxuICAgIHRzLlN5bWJvbEZsYWdzLlR5cGVQYXJhbWV0ZXIsXG4gICAgdHMuU3ltYm9sRmxhZ3MuVHlwZUFsaWFzLFxuICAgIHRzLlN5bWJvbEZsYWdzLkV4cG9ydFZhbHVlLFxuICAgIHRzLlN5bWJvbEZsYWdzLkFsaWFzLFxuICAgIHRzLlN5bWJvbEZsYWdzLlByb3RvdHlwZSxcbiAgICB0cy5TeW1ib2xGbGFncy5FeHBvcnRTdGFyLFxuICAgIHRzLlN5bWJvbEZsYWdzLk9wdGlvbmFsLFxuICAgIHRzLlN5bWJvbEZsYWdzLlRyYW5zaWVudCxcbiAgXTtcbiAgZm9yIChjb25zdCBmbGFnIG9mIHN5bWJvbEZsYWdzKSB7XG4gICAgaWYgKChzeW0uZmxhZ3MgJiBmbGFnKSAhPT0gMCkge1xuICAgICAgZGVidWdTdHJpbmcgKz0gYCAke3RzLlN5bWJvbEZsYWdzW2ZsYWddfWA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlYnVnU3RyaW5nO1xufVxuXG4vKiogQSBtb2R1bGUgZGVjbGFyZWQgYXMgXCJkZWNsYXJlIG1vZHVsZSAnZXh0ZXJuYWxfbmFtZScgey4uLn1cIiAobm90ZSB0aGUgcXVvdGVzKS4gKi9cbnR5cGUgQW1iaWVudE1vZHVsZURlY2xhcmF0aW9uID0gdHMuTW9kdWxlRGVjbGFyYXRpb24me25hbWU6IHRzLlN0cmluZ0xpdGVyYWx9O1xuXG4vKipcbiAqIFNlYXJjaGVzIGZvciBhbiBhbWJpZW50IG1vZHVsZSBkZWNsYXJhdGlvbiBpbiB0aGUgYW5jZXN0b3JzIG9mIGRlY2xhcmF0aW9ucywgZGVwdGggZmlyc3QsIGFuZFxuICogcmV0dXJucyB0aGUgZmlyc3Qgb3IgbnVsbCBpZiBub25lIGZvdW5kLlxuICovXG5mdW5jdGlvbiBnZXRDb250YWluaW5nQW1iaWVudE1vZHVsZURlY2xhcmF0aW9uKGRlY2xhcmF0aW9uczogdHMuRGVjbGFyYXRpb25bXSk6XG4gICAgQW1iaWVudE1vZHVsZURlY2xhcmF0aW9ufG51bGwge1xuICBmb3IgKGNvbnN0IGRlY2xhcmF0aW9uIG9mIGRlY2xhcmF0aW9ucykge1xuICAgIGxldCBwYXJlbnQgPSBkZWNsYXJhdGlvbi5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgaWYgKHRzLmlzTW9kdWxlRGVjbGFyYXRpb24ocGFyZW50KSAmJiB0cy5pc1N0cmluZ0xpdGVyYWwocGFyZW50Lm5hbWUpKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQgYXMgQW1iaWVudE1vZHVsZURlY2xhcmF0aW9uO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKiBSZXR1cm5zIHRydWUgaWYgYW55IG9mIGRlY2xhcmF0aW9ucyBpcyBhIHRvcCBsZXZlbCBkZWNsYXJhdGlvbiBpbiBhbiBleHRlcm5hbCBtb2R1bGUuICovXG5mdW5jdGlvbiBpc1RvcExldmVsRXh0ZXJuYWwoZGVjbGFyYXRpb25zOiB0cy5EZWNsYXJhdGlvbltdKSB7XG4gIGZvciAoY29uc3QgZGVjbGFyYXRpb24gb2YgZGVjbGFyYXRpb25zKSB7XG4gICAgaWYgKGRlY2xhcmF0aW9uLnBhcmVudCA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcbiAgICBpZiAodHMuaXNTb3VyY2VGaWxlKGRlY2xhcmF0aW9uLnBhcmVudCkgJiYgdHMuaXNFeHRlcm5hbE1vZHVsZShkZWNsYXJhdGlvbi5wYXJlbnQpKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgYW5kIGIgYXJlIChvciB3ZXJlIG9yaWdpbmFsbHkgYmVmb3JlIHRyYW5zZm9ybWF0aW9uKSBub2RlcyBvZiB0aGUgc2FtZSBzb3VyY2VcbiAqIGZpbGUuXG4gKi9cbmZ1bmN0aW9uIGlzRGVjbGFyZWRJblNhbWVGaWxlKGE6IHRzLk5vZGUsIGI6IHRzLk5vZGUpIHtcbiAgcmV0dXJuIHRzLmdldE9yaWdpbmFsTm9kZShhKS5nZXRTb3VyY2VGaWxlKCkgPT09IHRzLmdldE9yaWdpbmFsTm9kZShiKS5nZXRTb3VyY2VGaWxlKCk7XG59XG5cbi8qKiBUeXBlVHJhbnNsYXRvciB0cmFuc2xhdGVzIFR5cGVTY3JpcHQgdHlwZXMgdG8gQ2xvc3VyZSB0eXBlcy4gKi9cbmV4cG9ydCBjbGFzcyBUeXBlVHJhbnNsYXRvciB7XG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgdHlwZSBsaXRlcmFscyB3ZSd2ZSBlbmNvdW50ZXJlZCB3aGlsZSBlbWl0dGluZzsgdXNlZCB0byBhdm9pZCBnZXR0aW5nIHN0dWNrIGluXG4gICAqIHJlY3Vyc2l2ZSB0eXBlcy5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgc2VlbkFub255bW91c1R5cGVzID0gbmV3IFNldDx0cy5UeXBlPigpO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHdyaXRlIHR5cGVzIHN1aXRhYmxlIGZvciBhbiBcXEBleHRlcm5zIGZpbGUuIEV4dGVybnMgdHlwZXMgbXVzdCBub3QgcmVmZXIgdG9cbiAgICogbm9uLWV4dGVybnMgdHlwZXMgKGkuZS4gbm9uIGFtYmllbnQgdHlwZXMpIGFuZCBuZWVkIHRvIHVzZSBmdWxseSBxdWFsaWZpZWQgbmFtZXMuXG4gICAqL1xuICBpc0ZvckV4dGVybnMgPSBmYWxzZTtcblxuICAvKipcbiAgICogQHBhcmFtIG5vZGUgaXMgdGhlIHNvdXJjZSBBU1QgdHMuTm9kZSB0aGUgdHlwZSBjb21lcyBmcm9tLiAgVGhpcyBpcyB1c2VkXG4gICAqICAgICBpbiBzb21lIGNhc2VzIChlLmcuIGFub255bW91cyB0eXBlcykgZm9yIGxvb2tpbmcgdXAgZmllbGQgbmFtZXMuXG4gICAqIEBwYXJhbSBwYXRoQmxhY2tMaXN0IGlzIGEgc2V0IG9mIHBhdGhzIHRoYXQgc2hvdWxkIG5ldmVyIGdldCB0eXBlZDtcbiAgICogICAgIGFueSByZWZlcmVuY2UgdG8gc3ltYm9scyBkZWZpbmVkIGluIHRoZXNlIHBhdGhzIHNob3VsZCBieSB0eXBlZFxuICAgKiAgICAgYXMgez99LlxuICAgKiBAcGFyYW0gc3ltYm9sc1RvQWxpYXNlZE5hbWVzIGEgbWFwcGluZyBmcm9tIHN5bWJvbHMgKGBGb29gKSB0byBhIG5hbWUgaW4gc2NvcGUgdGhleSBzaG91bGQgYmVcbiAgICogICAgIGVtaXR0ZWQgYXMgKGUuZy4gYHRzaWNrbGVfZm9yd2FyZF9kZWNsYXJlXzEuRm9vYCkuIENhbiBiZSBhdWdtZW50ZWQgZHVyaW5nIHR5cGVcbiAgICogICAgIHRyYW5zbGF0aW9uLCBlLmcuIHRvIGJsYWNrbGlzdCBhIHN5bWJvbC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcHJpdmF0ZSByZWFkb25seSBob3N0OiBBbm5vdGF0b3JIb3N0LCBwcml2YXRlIHJlYWRvbmx5IHR5cGVDaGVja2VyOiB0cy5UeXBlQ2hlY2tlcixcbiAgICAgIHByaXZhdGUgcmVhZG9ubHkgbm9kZTogdHMuTm9kZSwgcHJpdmF0ZSByZWFkb25seSBwYXRoQmxhY2tMaXN0PzogU2V0PHN0cmluZz4sXG4gICAgICBwcml2YXRlIHJlYWRvbmx5IHN5bWJvbHNUb0FsaWFzZWROYW1lcyA9IG5ldyBNYXA8dHMuU3ltYm9sLCBzdHJpbmc+KCksXG4gICAgICBwcml2YXRlIHJlYWRvbmx5IGVuc3VyZVN5bWJvbERlY2xhcmVkOiAoc3ltOiB0cy5TeW1ib2wpID0+IHZvaWQgPSAoKSA9PiB7fSkge1xuICAgIC8vIE5vcm1hbGl6ZSBwYXRocyB0byBub3QgYnJlYWsgY2hlY2tzIG9uIFdpbmRvd3MuXG4gICAgaWYgKHRoaXMucGF0aEJsYWNrTGlzdCAhPSBudWxsKSB7XG4gICAgICB0aGlzLnBhdGhCbGFja0xpc3QgPVxuICAgICAgICAgIG5ldyBTZXQ8c3RyaW5nPihBcnJheS5mcm9tKHRoaXMucGF0aEJsYWNrTGlzdC52YWx1ZXMoKSkubWFwKHAgPT4gcGF0aC5ub3JtYWxpemUocCkpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSB0cy5TeW1ib2wgdG8gYSBzdHJpbmcuXG4gICAqIE90aGVyIGFwcHJvYWNoZXMgdGhhdCBkb24ndCB3b3JrOlxuICAgKiAtIFR5cGVDaGVja2VyLnR5cGVUb1N0cmluZyB0cmFuc2xhdGVzIEFycmF5IGFzIFRbXS5cbiAgICogLSBUeXBlQ2hlY2tlci5zeW1ib2xUb1N0cmluZyBlbWl0cyB0eXBlcyB3aXRob3V0IHRoZWlyIG5hbWVzcGFjZSxcbiAgICogICBhbmQgZG9lc24ndCBsZXQgeW91IHBhc3MgdGhlIGZsYWcgdG8gY29udHJvbCB0aGF0LlxuICAgKiBAcGFyYW0gdXNlRnFuIHdoZXRoZXIgdG8gc2NvcGUgdGhlIG5hbWUgdXNpbmcgaXRzIGZ1bGx5IHF1YWxpZmllZCBuYW1lLiBDbG9zdXJlJ3MgdGVtcGxhdGVcbiAgICogICAgIGFyZ3VtZW50cyBhcmUgYWx3YXlzIHNjb3BlZCB0byB0aGUgY2xhc3MgY29udGFpbmluZyB0aGVtLCB3aGVyZSBUeXBlU2NyaXB0J3MgdGVtcGxhdGUgYXJnc1xuICAgKiAgICAgd291bGQgYmUgZnVsbHkgcXVhbGlmaWVkLiBJLmUuIHRoaXMgZmxhZyBpcyBmYWxzZSBmb3IgZ2VuZXJpYyB0eXBlcy5cbiAgICovXG4gIHN5bWJvbFRvU3RyaW5nKHN5bTogdHMuU3ltYm9sLCB1c2VGcW46IGJvb2xlYW4pOiBzdHJpbmcge1xuICAgIC8vIFR5cGVTY3JpcHQgcmVzb2x2ZXMgZS5nLiB1bmlvbiB0eXBlcyB0byB0aGVpciBtZW1iZXJzLCB3aGljaCBjYW4gaW5jbHVkZSBzeW1ib2xzIG5vdCBkZWNsYXJlZFxuICAgIC8vIGluIHRoZSBjdXJyZW50IHNjb3BlLiBFbnN1cmUgdGhhdCBhbGwgc3ltYm9scyBmb3VuZCB0aGlzIHdheSBhcmUgYWN0dWFsbHkgZGVjbGFyZWQuXG4gICAgLy8gVGhpcyBtdXN0IGhhcHBlbiBiZWZvcmUgdGhlIGFsaWFzIGNoZWNrIGJlbG93LCBpdCBtaWdodCBpbnRyb2R1Y2UgYSBuZXcgYWxpYXMgZm9yIHRoZSBzeW1ib2wuXG4gICAgaWYgKCF0aGlzLmlzRm9yRXh0ZXJucyAmJiAoc3ltLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuVHlwZVBhcmFtZXRlcikgPT09IDApIHtcbiAgICAgIHRoaXMuZW5zdXJlU3ltYm9sRGVjbGFyZWQoc3ltKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZvbGxvd3MgZ2V0U2luZ2xlTGluZVN0cmluZ1dyaXRlciBpbiB0aGUgVHlwZVNjcmlwdCBjb21waWxlci5cbiAgICBsZXQgc3RyID0gJyc7XG4gICAgZnVuY3Rpb24gd3JpdGVUZXh0KHRleHQ6IHN0cmluZykge1xuICAgICAgc3RyICs9IHRleHQ7XG4gICAgfVxuICAgIGNvbnN0IHdyaXRlU3ltYm9sID0gKHRleHQ6IHN0cmluZywgc3ltYm9sOiB0cy5TeW1ib2wpID0+IHtcbiAgICAgIC8vIFdoZW4gd3JpdGluZyBhIHN5bWJvbCwgY2hlY2sgaWYgdGhlcmUgaXMgYW4gYWxpYXMgZm9yIGl0IGluIHRoZSBjdXJyZW50IHNjb3BlIHRoYXQgc2hvdWxkXG4gICAgICAvLyB0YWtlIHByZWNlZGVuY2UsIGUuZy4gZnJvbSBhIGdvb2cuZm9yd2FyZERlY2xhcmUuXG4gICAgICBpZiAoc3ltYm9sLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuQWxpYXMpIHtcbiAgICAgICAgc3ltYm9sID0gdGhpcy50eXBlQ2hlY2tlci5nZXRBbGlhc2VkU3ltYm9sKHN5bWJvbCk7XG4gICAgICB9XG4gICAgICBjb25zdCBhbGlhcyA9IHRoaXMuc3ltYm9sc1RvQWxpYXNlZE5hbWVzLmdldChzeW1ib2wpO1xuICAgICAgaWYgKGFsaWFzKSB7XG4gICAgICAgIC8vIElmIHNvLCBkaXNjYXJkIHRoZSBlbnRpcmUgY3VycmVudCB0ZXh0IGFuZCBvbmx5IHVzZSB0aGUgYWxpYXMgLSBvdGhlcndpc2UgaWYgYSBzeW1ib2wgaGFzXG4gICAgICAgIC8vIGEgbG9jYWwgYWxpYXMgYnV0IGFwcGVhcnMgaW4gYSBkb3R0ZWQgdHlwZSBwYXRoIChlLmcuIHdoZW4gaXQncyBpbXBvcnRlZCB1c2luZyBpbXBvcnQgKlxuICAgICAgICAvLyBhcyBmb28pLCBzdHIgd291bGQgY29udGFpbiBib3RoIHRoZSBwcmVmeCAqYW5kKiB0aGUgZnVsbCBhbGlhcyAoZm9vLmFsaWFzLm5hbWUpLlxuICAgICAgICBzdHIgPSBhbGlhcztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zdCBtYW5nbGVkUHJlZml4ID0gdGhpcy5tYXliZUdldE1hbmdsZWROYW1lUHJlZml4KHN5bWJvbCk7XG4gICAgICAgIHRleHQgPSBtYW5nbGVkUHJlZml4ICsgdGV4dDtcbiAgICAgIH1cbiAgICAgIHN0ciArPSB0ZXh0O1xuICAgIH07XG4gICAgY29uc3QgZG9Ob3RoaW5nID0gKCkgPT4ge1xuICAgICAgcmV0dXJuO1xuICAgIH07XG5cbiAgICBjb25zdCBidWlsZGVyID0gdGhpcy50eXBlQ2hlY2tlci5nZXRTeW1ib2xEaXNwbGF5QnVpbGRlcigpO1xuICAgIGNvbnN0IHdyaXRlcjogdHMuU3ltYm9sV3JpdGVyID0ge1xuICAgICAgd3JpdGVTeW1ib2wsXG4gICAgICB3cml0ZUtleXdvcmQ6IHdyaXRlVGV4dCxcbiAgICAgIHdyaXRlT3BlcmF0b3I6IHdyaXRlVGV4dCxcbiAgICAgIHdyaXRlUHVuY3R1YXRpb246IHdyaXRlVGV4dCxcbiAgICAgIHdyaXRlU3BhY2U6IHdyaXRlVGV4dCxcbiAgICAgIHdyaXRlU3RyaW5nTGl0ZXJhbDogd3JpdGVUZXh0LFxuICAgICAgd3JpdGVQYXJhbWV0ZXI6IHdyaXRlVGV4dCxcbiAgICAgIHdyaXRlUHJvcGVydHk6IHdyaXRlVGV4dCxcbiAgICAgIHdyaXRlTGluZTogZG9Ob3RoaW5nLFxuICAgICAgaW5jcmVhc2VJbmRlbnQ6IGRvTm90aGluZyxcbiAgICAgIGRlY3JlYXNlSW5kZW50OiBkb05vdGhpbmcsXG4gICAgICBjbGVhcjogZG9Ob3RoaW5nLFxuICAgICAgdHJhY2tTeW1ib2woc3ltYm9sOiB0cy5TeW1ib2wsIGVuY2xvc2luZ0RlY2xhcmF0aW9uPzogdHMuTm9kZSwgbWVhbmluZz86IHRzLlN5bWJvbEZsYWdzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0sXG4gICAgICByZXBvcnRJbmFjY2Vzc2libGVUaGlzRXJyb3I6IGRvTm90aGluZyxcbiAgICAgIHJlcG9ydFByaXZhdGVJbkJhc2VPZkNsYXNzRXhwcmVzc2lvbjogZG9Ob3RoaW5nLFxuICAgIH07XG4gICAgYnVpbGRlci5idWlsZFN5bWJvbERpc3BsYXkoc3ltLCB3cml0ZXIsIHRoaXMubm9kZSk7XG4gICAgcmV0dXJuIHRoaXMuc3RyaXBDbHV0ek5hbWVzcGFjZShzdHIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG1hbmdsZWQgbmFtZSBwcmVmaXggZm9yIHN5bWJvbCwgb3IgYW4gZW1wdHkgc3RyaW5nIGlmIG5vdCBhcHBsaWNhYmxlLlxuICAgKlxuICAgKiBUeXBlIG5hbWVzIGFyZSBlbWl0dGVkIHdpdGggYSBtYW5nbGVkIHByZWZpeCBpZiB0aGV5IGFyZSB0b3AgbGV2ZWwgc3ltYm9scyBkZWNsYXJlZCBpbiBhblxuICAgKiBleHRlcm5hbCBtb2R1bGUgKC5kLnRzIG9yIC50cyksIGFuZCBhcmUgYW1iaWVudCBkZWNsYXJhdGlvbnMgKFwiZGVjbGFyZSAuLi5cIikuIFRoaXMgaXMgYmVjYXVzZVxuICAgKiB0aGVpciBkZWNsYXJhdGlvbnMgZ2V0IG1vdmVkIHRvIGV4dGVybnMgZmlsZXMgKHRvIG1ha2UgZXh0ZXJuYWwgbmFtZXMgdmlzaWJsZSB0byBDbG9zdXJlIGFuZFxuICAgKiBwcmV2ZW50IHJlbmFtaW5nKSwgd2hpY2ggb25seSB1c2UgZ2xvYmFsIG5hbWVzLiBUaGlzIG1lYW5zIHRoZSBuYW1lcyBtdXN0IGJlIG1hbmdsZWQgdG8gcHJldmVudFxuICAgKiBjb2xsaXNpb25zIGFuZCBhbGxvdyByZWZlcmVuY2luZyB0aGVtIHVuaXF1ZWx5LlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBhbHNvIGhhbmRsZXMgdGhlIHNwZWNpYWwgY2FzZSBvZiBzeW1ib2xzIGRlY2xhcmVkIGluIGFuIGFtYmllbnQgZXh0ZXJuYWwgbW9kdWxlXG4gICAqIGNvbnRleHQuXG4gICAqXG4gICAqIFN5bWJvbHMgZGVjbGFyZWQgaW4gYSBnbG9iYWwgYmxvY2ssIGUuZy4gXCJkZWNsYXJlIGdsb2JhbCB7IHR5cGUgWDsgfVwiLCBhcmUgaGFuZGxlZCBpbXBsaWNpdGx5OlxuICAgKiB3aGVuIHJlZmVyZW5jZWQsIHRoZXkgYXJlIHdyaXR0ZW4gYXMganVzdCBcIlhcIiwgd2hpY2ggaXMgbm90IGEgdG9wIGxldmVsIGRlY2xhcmF0aW9uLCBzbyB0aGVcbiAgICogY29kZSBiZWxvdyBpZ25vcmVzIHRoZW0uXG4gICAqL1xuICBtYXliZUdldE1hbmdsZWROYW1lUHJlZml4KHN5bWJvbDogdHMuU3ltYm9sKTogc3RyaW5nfCcnIHtcbiAgICBpZiAoIXN5bWJvbC5kZWNsYXJhdGlvbnMpIHJldHVybiAnJztcbiAgICBjb25zdCBkZWNsYXJhdGlvbnMgPSBzeW1ib2wuZGVjbGFyYXRpb25zO1xuICAgIGxldCBhbWJpZW50TW9kdWxlRGVjbGFyYXRpb246IEFtYmllbnRNb2R1bGVEZWNsYXJhdGlvbnxudWxsID0gbnVsbDtcbiAgICAvLyBJZiB0aGUgc3ltYm9sIGlzIG5laXRoZXIgYSB0b3AgbGV2ZWwgZGVjbGFyYXRpb24gaW4gYW4gZXh0ZXJuYWwgbW9kdWxlIG5vciBpbiBhbiBhbWJpZW50XG4gICAgLy8gYmxvY2ssIHRzaWNrbGUgc2hvdWxkIG5vdCBlbWl0IGEgcHJlZml4OiBpdCdzIGVpdGhlciBub3QgYW4gZXh0ZXJuYWwgc3ltYm9sLCBvciBpdCdzIGFuXG4gICAgLy8gZXh0ZXJuYWwgc3ltYm9sIG5lc3RlZCBpbiBhIG1vZHVsZSwgc28gaXQgd2lsbCBuZWVkIHRvIGJlIHF1YWxpZmllZCwgYW5kIHRoZSBtYW5nbGluZyBwcmVmaXhcbiAgICAvLyBnb2VzIG9uIHRoZSBxdWFsaWZpZXIuXG4gICAgaWYgKCFpc1RvcExldmVsRXh0ZXJuYWwoZGVjbGFyYXRpb25zKSkge1xuICAgICAgYW1iaWVudE1vZHVsZURlY2xhcmF0aW9uID0gZ2V0Q29udGFpbmluZ0FtYmllbnRNb2R1bGVEZWNsYXJhdGlvbihkZWNsYXJhdGlvbnMpO1xuICAgICAgaWYgKCFhbWJpZW50TW9kdWxlRGVjbGFyYXRpb24pIHJldHVybiAnJztcbiAgICB9XG4gICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIGRlY2xhcmF0aW9uIGlzIGZyb20gYW4gZXh0ZXJuYWwgbW9kdWxlIChwb3NzaWJseSBhbWJpZW50KS5cbiAgICAvLyBUaGVzZSBkZWNsYXJhdGlvbnMgbXVzdCBiZSBwcmVmaXhlZCBpZiBlaXRoZXI6XG4gICAgLy8gKGEpIHRzaWNrbGUgaXMgZW1pdHRpbmcgYW4gZXh0ZXJucyBmaWxlLCBzbyBhbGwgc3ltYm9scyBhcmUgcXVhbGlmaWVkIHdpdGhpbiBpdFxuICAgIC8vIChiKSBvciB0aGUgZGVjbGFyYXRpb24gbXVzdCBiZSBhbiBleHBvcnRlZCBhbWJpZW50IGRlY2xhcmF0aW9uIGZyb20gdGhlIGxvY2FsIGZpbGUuXG4gICAgLy8gQW1iaWVudCBleHRlcm5hbCBkZWNsYXJhdGlvbnMgZnJvbSBvdGhlciBmaWxlcyBhcmUgaW1wb3J0ZWQsIHNvIHRoZXJlJ3MgYSBsb2NhbCBhbGlhcyBmb3IgdGhlXG4gICAgLy8gbW9kdWxlIGFuZCBubyBtYW5nbGluZyBpcyBuZWVkZWQuXG4gICAgaWYgKCF0aGlzLmlzRm9yRXh0ZXJucyAmJlxuICAgICAgICAhZGVjbGFyYXRpb25zLmV2ZXJ5KFxuICAgICAgICAgICAgZCA9PiBpc0RlY2xhcmVkSW5TYW1lRmlsZSh0aGlzLm5vZGUsIGQpICYmIGlzQW1iaWVudChkKSAmJlxuICAgICAgICAgICAgICAgIGhhc01vZGlmaWVyRmxhZyhkLCB0cy5Nb2RpZmllckZsYWdzLkV4cG9ydCkpKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIC8vIElmIGZyb20gYW4gYW1iaWVudCBkZWNsYXJhdGlvbiwgdXNlIGFuZCByZXNvbHZlIHRoZSBuYW1lIGZyb20gdGhhdC4gT3RoZXJ3aXNlLCB1c2UgdGhlIGZpbGVcbiAgICAvLyBuYW1lIGZyb20gdGhlIChhcmJpdHJhcnkpIGZpcnN0IGRlY2xhcmF0aW9uIHRvIG1hbmdsZS5cbiAgICBjb25zdCBmaWxlTmFtZSA9IGFtYmllbnRNb2R1bGVEZWNsYXJhdGlvbiA/XG4gICAgICAgIGFtYmllbnRNb2R1bGVEZWNsYXJhdGlvbi5uYW1lLnRleHQgOlxuICAgICAgICB0cy5nZXRPcmlnaW5hbE5vZGUoZGVjbGFyYXRpb25zWzBdKS5nZXRTb3VyY2VGaWxlKCkuZmlsZU5hbWU7XG4gICAgY29uc3QgbWFuZ2xlZCA9IG1vZHVsZU5hbWVBc0lkZW50aWZpZXIodGhpcy5ob3N0LCBmaWxlTmFtZSwgdGhpcy5ub2RlLmdldFNvdXJjZUZpbGUoKS5maWxlTmFtZSk7XG4gICAgcmV0dXJuIG1hbmdsZWQgKyAnLic7XG4gIH1cblxuICAvLyBDbHV0eiAoaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvY2x1dHopIGVtaXRzIGdsb2JhbCB0eXBlIHN5bWJvbHMgaGlkZGVuIGluIGEgc3BlY2lhbFxuICAvLyDgsqBf4LKgLmNsdXR6IG5hbWVzcGFjZS4gV2hpbGUgbW9zdCBjb2RlIHNlZW4gYnkgVHNpY2tsZSB3aWxsIG9ubHkgZXZlciBzZWUgbG9jYWwgYWxpYXNlcywgQ2x1dHpcbiAgLy8gc3ltYm9scyBjYW4gYmUgd3JpdHRlbiBieSB1c2VycyBkaXJlY3RseSBpbiBjb2RlLCBhbmQgdGhleSBjYW4gYXBwZWFyIGJ5IGRlcmVmZXJlbmNpbmdcbiAgLy8gVHlwZUFsaWFzZXMuIFRoZSBjb2RlIGJlbG93IHNpbXBseSBzdHJpcHMgdGhlIHByZWZpeCwgdGhlIHJlbWFpbmluZyB0eXBlIG5hbWUgdGhlbiBtYXRjaGVzXG4gIC8vIENsb3N1cmUncyB0eXBlLlxuICBwcml2YXRlIHN0cmlwQ2x1dHpOYW1lc3BhY2UobmFtZTogc3RyaW5nKSB7XG4gICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgn4LKgX+CyoC5jbHV0ei4nKSkgcmV0dXJuIG5hbWUuc3Vic3RyaW5nKCfgsqBf4LKgLmNsdXR6LicubGVuZ3RoKTtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuXG4gIHRyYW5zbGF0ZSh0eXBlOiB0cy5UeXBlKTogc3RyaW5nIHtcbiAgICAvLyBOT1RFOiBUaG91Z2ggdHlwZS5mbGFncyBoYXMgdGhlIG5hbWUgXCJmbGFnc1wiLCBpdCB1c3VhbGx5IGNhbiBvbmx5IGJlIG9uZVxuICAgIC8vIG9mIHRoZSBlbnVtIG9wdGlvbnMgYXQgYSB0aW1lIChleGNlcHQgZm9yIHVuaW9ucyBvZiBsaXRlcmFsIHR5cGVzLCBlLmcuIHVuaW9ucyBvZiBib29sZWFuXG4gICAgLy8gdmFsdWVzLCBzdHJpbmcgdmFsdWVzLCBlbnVtIHZhbHVlcykuIFRoaXMgc3dpdGNoIGhhbmRsZXMgYWxsIHRoZSBjYXNlcyBpbiB0aGUgdHMuVHlwZUZsYWdzXG4gICAgLy8gZW51bSBpbiB0aGUgb3JkZXIgdGhleSBvY2N1ci5cblxuICAgIC8vIE5PVEU6IFNvbWUgVHlwZUZsYWdzIGFyZSBtYXJrZWQgXCJpbnRlcm5hbFwiIGluIHRoZSBkLnRzIGJ1dCBzdGlsbCBzaG93IHVwIGluIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHR5cGUuZmxhZ3MuIFRoaXMgbWFzayBsaW1pdHMgdGhlIGZsYWcgY2hlY2tzIHRvIHRoZSBvbmVzIGluIHRoZSBwdWJsaWMgQVBJLiBcImxhc3RGbGFnXCIgaGVyZVxuICAgIC8vIGlzIHRoZSBsYXN0IGZsYWcgaGFuZGxlZCBpbiB0aGlzIHN3aXRjaCBzdGF0ZW1lbnQsIGFuZCBzaG91bGQgYmUga2VwdCBpbiBzeW5jIHdpdGhcbiAgICAvLyB0eXBlc2NyaXB0LmQudHMuXG5cbiAgICAvLyBOb25QcmltaXRpdmUgb2NjdXJzIG9uIGl0cyBvd24gb24gdGhlIGxvd2VyIGNhc2UgXCJvYmplY3RcIiB0eXBlLiBTcGVjaWFsIGNhc2UgdG8gXCIhT2JqZWN0XCIuXG4gICAgaWYgKHR5cGUuZmxhZ3MgPT09IHRzLlR5cGVGbGFncy5Ob25QcmltaXRpdmUpIHJldHVybiAnIU9iamVjdCc7XG5cbiAgICAvLyBBdm9pZCBpbmZpbml0ZSBsb29wcyBvbiByZWN1cnNpdmUgdHlwZSBsaXRlcmFscy5cbiAgICAvLyBJdCB3b3VsZCBiZSBuaWNlIHRvIGp1c3QgZW1pdCB0aGUgbmFtZSBvZiB0aGUgcmVjdXJzaXZlIHR5cGUgaGVyZSAoaW4gdHlwZS5hbGlhc1N5bWJvbFxuICAgIC8vIGJlbG93KSwgYnV0IENsb3N1cmUgQ29tcGlsZXIgZG9lcyBub3QgYWxsb3cgcmVjdXJzaXZlIHR5cGUgZGVmaW5pdGlvbnMuXG4gICAgaWYgKHRoaXMuc2VlbkFub255bW91c1R5cGVzLmhhcyh0eXBlKSkgcmV0dXJuICc/JztcblxuICAgIGxldCBpc0FtYmllbnQgPSBmYWxzZTtcbiAgICBsZXQgaXNJbk5hbWVzcGFjZSA9IGZhbHNlO1xuICAgIGxldCBpc01vZHVsZSA9IGZhbHNlO1xuICAgIGlmICh0eXBlLnN5bWJvbCkge1xuICAgICAgZm9yIChjb25zdCBkZWNsIG9mIHR5cGUuc3ltYm9sLmRlY2xhcmF0aW9ucyB8fCBbXSkge1xuICAgICAgICBpZiAodHMuaXNFeHRlcm5hbE1vZHVsZShkZWNsLmdldFNvdXJjZUZpbGUoKSkpIGlzTW9kdWxlID0gdHJ1ZTtcbiAgICAgICAgbGV0IGN1cnJlbnQ6IHRzLk5vZGV8dW5kZWZpbmVkID0gZGVjbDtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICBpZiAodHMuZ2V0Q29tYmluZWRNb2RpZmllckZsYWdzKGN1cnJlbnQpICYgdHMuTW9kaWZpZXJGbGFncy5BbWJpZW50KSBpc0FtYmllbnQgPSB0cnVlO1xuICAgICAgICAgIGlmIChjdXJyZW50LmtpbmQgPT09IHRzLlN5bnRheEtpbmQuTW9kdWxlRGVjbGFyYXRpb24pIGlzSW5OYW1lc3BhY2UgPSB0cnVlO1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRzaWNrbGUgY2Fubm90IGdlbmVyYXRlIHR5cGVzIGZvciBub24tYW1iaWVudCBuYW1lc3BhY2VzIG5vciBhbnkgc3ltYm9scyBjb250YWluZWQgaW4gdGhlbS5cbiAgICBpZiAoaXNJbk5hbWVzcGFjZSAmJiAhaXNBbWJpZW50KSByZXR1cm4gJz8nO1xuXG4gICAgLy8gVHlwZXMgaW4gZXh0ZXJucyBjYW5ub3QgcmVmZXJlbmNlIHR5cGVzIGZyb20gZXh0ZXJuYWwgbW9kdWxlcy5cbiAgICAvLyBIb3dldmVyIGFtYmllbnQgdHlwZXMgaW4gbW9kdWxlcyBnZXQgbW92ZWQgdG8gZXh0ZXJucywgdG9vLCBzbyB0eXBlIHJlZmVyZW5jZXMgd29yayBhbmQgd2VcbiAgICAvLyBjYW4gZW1pdCBhIHByZWNpc2UgdHlwZS5cbiAgICBpZiAodGhpcy5pc0ZvckV4dGVybnMgJiYgaXNNb2R1bGUgJiYgIWlzQW1iaWVudCkgcmV0dXJuICc/JztcblxuICAgIGNvbnN0IGxhc3RGbGFnID0gdHMuVHlwZUZsYWdzLlN1YnN0aXR1dGlvbjtcbiAgICBjb25zdCBtYXNrID0gKGxhc3RGbGFnIDw8IDEpIC0gMTtcbiAgICBzd2l0Y2ggKHR5cGUuZmxhZ3MgJiBtYXNrKSB7XG4gICAgICBjYXNlIHRzLlR5cGVGbGFncy5Bbnk6XG4gICAgICAgIHJldHVybiAnPyc7XG4gICAgICBjYXNlIHRzLlR5cGVGbGFncy5TdHJpbmc6XG4gICAgICBjYXNlIHRzLlR5cGVGbGFncy5TdHJpbmdMaXRlcmFsOlxuICAgICAgICByZXR1cm4gJ3N0cmluZyc7XG4gICAgICBjYXNlIHRzLlR5cGVGbGFncy5OdW1iZXI6XG4gICAgICBjYXNlIHRzLlR5cGVGbGFncy5OdW1iZXJMaXRlcmFsOlxuICAgICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgICBjYXNlIHRzLlR5cGVGbGFncy5Cb29sZWFuOlxuICAgICAgY2FzZSB0cy5UeXBlRmxhZ3MuQm9vbGVhbkxpdGVyYWw6XG4gICAgICAgIC8vIFNlZSB0aGUgbm90ZSBpbiB0cmFuc2xhdGVVbmlvbiBhYm91dCBib29sZWFucy5cbiAgICAgICAgcmV0dXJuICdib29sZWFuJztcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLkVudW06XG4gICAgICAgIGlmICghdHlwZS5zeW1ib2wpIHtcbiAgICAgICAgICB0aGlzLndhcm4oYEVudW1UeXBlIHdpdGhvdXQgYSBzeW1ib2xgKTtcbiAgICAgICAgICByZXR1cm4gJz8nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN5bWJvbFRvU3RyaW5nKHR5cGUuc3ltYm9sLCB0cnVlKTtcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLkVTU3ltYm9sOlxuICAgICAgY2FzZSB0cy5UeXBlRmxhZ3MuVW5pcXVlRVNTeW1ib2w6XG4gICAgICAgIC8vIEVTU3ltYm9sIGluZGljYXRlcyBzb21ldGhpbmcgdHlwZWQgc3ltYm9sLlxuICAgICAgICAvLyBVbmlxdWVFU1N5bWJvbCBpbmRpY2F0ZXMgYSBzcGVjaWZpYyB1bmlxdWUgc3ltYm9sLCB1c2VkIGUuZy4gdG8gaW5kZXggaW50byBhbiBvYmplY3QuXG4gICAgICAgIC8vIENsb3N1cmUgZG9lcyBub3QgaGF2ZSB0aGlzIGRpc3RpbmN0aW9uLCBzbyB0c2lja2xlIGVtaXRzIGJvdGggYXMgJ3N5bWJvbCcuXG4gICAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLlZvaWQ6XG4gICAgICAgIHJldHVybiAndm9pZCc7XG4gICAgICBjYXNlIHRzLlR5cGVGbGFncy5VbmRlZmluZWQ6XG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLk51bGw6XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICBjYXNlIHRzLlR5cGVGbGFncy5OZXZlcjpcbiAgICAgICAgdGhpcy53YXJuKGBzaG91bGQgbm90IGVtaXQgYSAnbmV2ZXInIHR5cGVgKTtcbiAgICAgICAgcmV0dXJuICc/JztcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLlR5cGVQYXJhbWV0ZXI6XG4gICAgICAgIC8vIFRoaXMgaXMgZS5nLiB0aGUgVCBpbiBhIHR5cGUgbGlrZSBGb288VD4uXG4gICAgICAgIGlmICghdHlwZS5zeW1ib2wpIHtcbiAgICAgICAgICB0aGlzLndhcm4oYFR5cGVQYXJhbWV0ZXIgd2l0aG91dCBhIHN5bWJvbGApOyAgLy8gc2hvdWxkIG5vdCBoYXBwZW4gKHRtKVxuICAgICAgICAgIHJldHVybiAnPyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gQ2xvc3VyZSBDb21waWxlciwgdHlwZSBwYXJhbWV0ZXJzICphcmUqIHNjb3BlZCB0byB0aGVpciBjb250YWluaW5nIGNsYXNzLlxuICAgICAgICBjb25zdCB1c2VGcW4gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ltYm9sVG9TdHJpbmcodHlwZS5zeW1ib2wsIHVzZUZxbik7XG4gICAgICBjYXNlIHRzLlR5cGVGbGFncy5PYmplY3Q6XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZU9iamVjdCh0eXBlIGFzIHRzLk9iamVjdFR5cGUpO1xuICAgICAgY2FzZSB0cy5UeXBlRmxhZ3MuVW5pb246XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZVVuaW9uKHR5cGUgYXMgdHMuVW5pb25UeXBlKTtcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLkNvbmRpdGlvbmFsOlxuICAgICAgY2FzZSB0cy5UeXBlRmxhZ3MuU3Vic3RpdHV0aW9uOlxuICAgICAgICB0aGlzLndhcm4oYGVtaXR0aW5nID8gZm9yIGNvbmRpdGlvbmFsL3N1YnN0aXR1dGlvbiB0eXBlYCk7XG4gICAgICAgIHJldHVybiAnPyc7XG4gICAgICBjYXNlIHRzLlR5cGVGbGFncy5JbnRlcnNlY3Rpb246XG4gICAgICBjYXNlIHRzLlR5cGVGbGFncy5JbmRleDpcbiAgICAgIGNhc2UgdHMuVHlwZUZsYWdzLkluZGV4ZWRBY2Nlc3M6XG4gICAgICAgIC8vIFRPRE8odHMyLjEpOiBoYW5kbGUgdGhlc2Ugc3BlY2lhbCB0eXBlcy5cbiAgICAgICAgdGhpcy53YXJuKGB1bmhhbmRsZWQgdHlwZSBmbGFnczogJHt0cy5UeXBlRmxhZ3NbdHlwZS5mbGFnc119YCk7XG4gICAgICAgIHJldHVybiAnPyc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBIYW5kbGUgY2FzZXMgd2hlcmUgbXVsdGlwbGUgZmxhZ3MgYXJlIHNldC5cblxuICAgICAgICAvLyBUeXBlcyB3aXRoIGxpdGVyYWwgbWVtYmVycyBhcmUgcmVwcmVzZW50ZWQgYXNcbiAgICAgICAgLy8gICB0cy5UeXBlRmxhZ3MuVW5pb24gfCBbbGl0ZXJhbCBtZW1iZXJdXG4gICAgICAgIC8vIEUuZy4gYW4gZW51bSB0eXBlZCB2YWx1ZSBpcyBhIHVuaW9uIHR5cGUgd2l0aCB0aGUgZW51bSdzIG1lbWJlcnMgYXMgaXRzIG1lbWJlcnMuIEFcbiAgICAgICAgLy8gYm9vbGVhbiB0eXBlIGlzIGEgdW5pb24gdHlwZSB3aXRoICd0cnVlJyBhbmQgJ2ZhbHNlJyBhcyBpdHMgbWVtYmVycy5cbiAgICAgICAgLy8gTm90ZSBhbHNvIHRoYXQgaW4gYSBtb3JlIGNvbXBsZXggdW5pb24sIGUuZy4gYm9vbGVhbnxudW1iZXIsIHRoZW4gaXQncyBhIHVuaW9uIG9mIHRocmVlXG4gICAgICAgIC8vIHRoaW5ncyAodHJ1ZXxmYWxzZXxudW1iZXIpIGFuZCB0cy5UeXBlRmxhZ3MuQm9vbGVhbiBkb2Vzbid0IHNob3cgdXAgYXQgYWxsLlxuICAgICAgICBpZiAodHlwZS5mbGFncyAmIHRzLlR5cGVGbGFncy5Vbmlvbikge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZVVuaW9uKHR5cGUgYXMgdHMuVW5pb25UeXBlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlLmZsYWdzICYgdHMuVHlwZUZsYWdzLkVudW1MaXRlcmFsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlRW51bUxpdGVyYWwodHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgc3dpdGNoIHN0YXRlbWVudCBzaG91bGQgaGF2ZSBiZWVuIGV4aGF1c3RpdmUuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlIGZsYWdzICR7dHlwZS5mbGFnc30gb24gJHt0eXBlVG9EZWJ1Z1N0cmluZyh0eXBlKX1gKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyYW5zbGF0ZVVuaW9uKHR5cGU6IHRzLlVuaW9uVHlwZSk6IHN0cmluZyB7XG4gICAgbGV0IHBhcnRzID0gdHlwZS50eXBlcy5tYXAodCA9PiB0aGlzLnRyYW5zbGF0ZSh0KSk7XG4gICAgLy8gVW5pb24gdHlwZXMgdGhhdCBpbmNsdWRlIGxpdGVyYWxzIChlLmcuIGJvb2xlYW4sIGVudW0pIGNhbiBlbmQgdXAgcmVwZWF0aW5nIHRoZSBzYW1lIENsb3N1cmVcbiAgICAvLyB0eXBlLiBGb3IgZXhhbXBsZTogdHJ1ZSB8IGJvb2xlYW4gd2lsbCBiZSB0cmFuc2xhdGVkIHRvIGJvb2xlYW4gfCBib29sZWFuLlxuICAgIC8vIFJlbW92ZSBkdXBsaWNhdGVzIHRvIHByb2R1Y2UgdHlwZXMgdGhhdCByZWFkIGJldHRlci5cbiAgICBwYXJ0cyA9IHBhcnRzLmZpbHRlcigoZWwsIGlkeCkgPT4gcGFydHMuaW5kZXhPZihlbCkgPT09IGlkeCk7XG4gICAgcmV0dXJuIHBhcnRzLmxlbmd0aCA9PT0gMSA/IHBhcnRzWzBdIDogYCgke3BhcnRzLmpvaW4oJ3wnKX0pYDtcbiAgfVxuXG4gIHByaXZhdGUgdHJhbnNsYXRlRW51bUxpdGVyYWwodHlwZTogdHMuVHlwZSk6IHN0cmluZyB7XG4gICAgLy8gU3VwcG9zZSB5b3UgaGFkOlxuICAgIC8vICAgZW51bSBFbnVtVHlwZSB7IE1FTUJFUiB9XG4gICAgLy8gdGhlbiB0aGUgdHlwZSBvZiBcIkVudW1UeXBlLk1FTUJFUlwiIGlzIGFuIGVudW0gbGl0ZXJhbCAodGhlIHRoaW5nIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uKVxuICAgIC8vIGFuZCBpdCBoYXMgdHlwZSBmbGFncyB0aGF0IGluY2x1ZGVcbiAgICAvLyAgIHRzLlR5cGVGbGFncy5OdW1iZXJMaXRlcmFsIHwgdHMuVHlwZUZsYWdzLkVudW1MaXRlcmFsXG4gICAgLy9cbiAgICAvLyBDbG9zdXJlIENvbXBpbGVyIGRvZXNuJ3Qgc3VwcG9ydCBsaXRlcmFscyBpbiB0eXBlcywgc28gdGhpcyBjb2RlIG11c3Qgbm90IGVtaXRcbiAgICAvLyBcIkVudW1UeXBlLk1FTUJFUlwiLCBidXQgcmF0aGVyIFwiRW51bVR5cGVcIi5cblxuICAgIGNvbnN0IGVudW1MaXRlcmFsQmFzZVR5cGUgPSB0aGlzLnR5cGVDaGVja2VyLmdldEJhc2VUeXBlT2ZMaXRlcmFsVHlwZSh0eXBlKTtcbiAgICBpZiAoIWVudW1MaXRlcmFsQmFzZVR5cGUuc3ltYm9sKSB7XG4gICAgICB0aGlzLndhcm4oYEVudW1MaXRlcmFsVHlwZSB3aXRob3V0IGEgc3ltYm9sYCk7XG4gICAgICByZXR1cm4gJz8nO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zeW1ib2xUb1N0cmluZyhlbnVtTGl0ZXJhbEJhc2VUeXBlLnN5bWJvbCwgdHJ1ZSk7XG4gIH1cblxuICAvLyB0cmFuc2xhdGVPYmplY3QgdHJhbnNsYXRlcyBhIHRzLk9iamVjdFR5cGUsIHdoaWNoIGlzIHRoZSB0eXBlIG9mIGFsbFxuICAvLyBvYmplY3QtbGlrZSB0aGluZ3MgaW4gVFMsIHN1Y2ggYXMgY2xhc3NlcyBhbmQgaW50ZXJmYWNlcy5cbiAgcHJpdmF0ZSB0cmFuc2xhdGVPYmplY3QodHlwZTogdHMuT2JqZWN0VHlwZSk6IHN0cmluZyB7XG4gICAgaWYgKHR5cGUuc3ltYm9sICYmIHRoaXMuaXNCbGFja0xpc3RlZCh0eXBlLnN5bWJvbCkpIHJldHVybiAnPyc7XG5cbiAgICAvLyBOT1RFOiBvYmplY3RGbGFncyBpcyBhbiBlbnVtLCBidXQgYSBnaXZlbiB0eXBlIGNhbiBoYXZlIG11bHRpcGxlIGZsYWdzLlxuICAgIC8vIEFycmF5PHN0cmluZz4gaXMgYm90aCB0cy5PYmplY3RGbGFncy5SZWZlcmVuY2UgYW5kIHRzLk9iamVjdEZsYWdzLkludGVyZmFjZS5cblxuICAgIGlmICh0eXBlLm9iamVjdEZsYWdzICYgdHMuT2JqZWN0RmxhZ3MuQ2xhc3MpIHtcbiAgICAgIGlmICghdHlwZS5zeW1ib2wpIHtcbiAgICAgICAgdGhpcy53YXJuKCdjbGFzcyBoYXMgbm8gc3ltYm9sJyk7XG4gICAgICAgIHJldHVybiAnPyc7XG4gICAgICB9XG4gICAgICBjb25zdCBuYW1lID0gdGhpcy5zeW1ib2xUb1N0cmluZyh0eXBlLnN5bWJvbCwgLyogdXNlRnFuICovIHRydWUpO1xuICAgICAgaWYgKG5hbWUgPT09ICcoQW5vbnltb3VzIGNsYXNzKScpIHtcbiAgICAgICAgLy8gVmFsdWVzIHRoYXQgaGF2ZSBhbm9ueW1vdXMgY2xhc3MgdHlwZXMgcHJvZHVjZSB0aGlzIG5hbWUsIGJ1dCB0aGUgdHlwZVxuICAgICAgICAvLyBhcHBlYXJzIG90aGVyd2lzZSBpZGVudGljYWwgdG8gYSBuYW1lZCBjbGFzcy4gIEdpdmVuIHRoYXQgdGhlIHR5cGUgaXNcbiAgICAgICAgLy8gYW5vbnltb3VzIGhlcmUsIHRoZXJlJ3Mgbm90IHJlYWxseSBhIHVzZWZ1bCBuYW1lIHdlIGNhbiBlbWl0LlxuICAgICAgICByZXR1cm4gJz8nO1xuICAgICAgfVxuICAgICAgcmV0dXJuICchJyArIG5hbWU7XG4gICAgfSBlbHNlIGlmICh0eXBlLm9iamVjdEZsYWdzICYgdHMuT2JqZWN0RmxhZ3MuSW50ZXJmYWNlKSB7XG4gICAgICAvLyBOb3RlOiB0cy5JbnRlcmZhY2VUeXBlIGhhcyBhIHR5cGVQYXJhbWV0ZXJzIGZpZWxkLCBidXQgdGhhdFxuICAgICAgLy8gc3BlY2lmaWVzIHRoZSBwYXJhbWV0ZXJzIHRoYXQgdGhlIGludGVyZmFjZSB0eXBlICpleHBlY3RzKlxuICAgICAgLy8gd2hlbiBpdCdzIHVzZWQsIGFuZCBzaG91bGQgbm90IGJlIHRyYW5zZm9ybWVkIHRvIHRoZSBvdXRwdXQuXG4gICAgICAvLyBFLmcuIGEgdHlwZSBsaWtlIEFycmF5PG51bWJlcj4gaXMgYSBUeXBlUmVmZXJlbmNlIHRvIHRoZVxuICAgICAgLy8gSW50ZXJmYWNlVHlwZSBcIkFycmF5XCIsIGJ1dCB0aGUgXCJudW1iZXJcIiB0eXBlIHBhcmFtZXRlciBpc1xuICAgICAgLy8gcGFydCBvZiB0aGUgb3V0ZXIgVHlwZVJlZmVyZW5jZSwgbm90IGEgdHlwZVBhcmFtZXRlciBvblxuICAgICAgLy8gdGhlIEludGVyZmFjZVR5cGUuXG4gICAgICBpZiAoIXR5cGUuc3ltYm9sKSB7XG4gICAgICAgIHRoaXMud2FybignaW50ZXJmYWNlIGhhcyBubyBzeW1ib2wnKTtcbiAgICAgICAgcmV0dXJuICc/JztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlLnN5bWJvbC5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLlZhbHVlKSB7XG4gICAgICAgIC8vIFRoZSBzeW1ib2wgaXMgYm90aCBhIHR5cGUgYW5kIGEgdmFsdWUuXG4gICAgICAgIC8vIEZvciB1c2VyLWRlZmluZWQgdHlwZXMgaW4gdGhpcyBzdGF0ZSwgd2UgZG9uJ3QgaGF2ZSBhIENsb3N1cmUgbmFtZVxuICAgICAgICAvLyBmb3IgdGhlIHR5cGUuICBTZWUgdGhlIHR5cGVfYW5kX3ZhbHVlIHRlc3QuXG4gICAgICAgIGlmICghaXNDbG9zdXJlUHJvdmlkZWRUeXBlKHR5cGUuc3ltYm9sKSkge1xuICAgICAgICAgIHRoaXMud2FybihgdHlwZS9zeW1ib2wgY29uZmxpY3QgZm9yICR7dHlwZS5zeW1ib2wubmFtZX0sIHVzaW5nIHs/fSBmb3Igbm93YCk7XG4gICAgICAgICAgcmV0dXJuICc/JztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICchJyArIHRoaXMuc3ltYm9sVG9TdHJpbmcodHlwZS5zeW1ib2wsIC8qIHVzZUZxbiAqLyB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUub2JqZWN0RmxhZ3MgJiB0cy5PYmplY3RGbGFncy5SZWZlcmVuY2UpIHtcbiAgICAgIC8vIEEgcmVmZXJlbmNlIHRvIGFub3RoZXIgdHlwZSwgZS5nLiBBcnJheTxudW1iZXI+IHJlZmVycyB0byBBcnJheS5cbiAgICAgIC8vIEVtaXQgdGhlIHJlZmVyZW5jZWQgdHlwZSBhbmQgYW55IHR5cGUgYXJndW1lbnRzLlxuICAgICAgY29uc3QgcmVmZXJlbmNlVHlwZSA9IHR5cGUgYXMgdHMuVHlwZVJlZmVyZW5jZTtcblxuICAgICAgLy8gQSB0dXBsZSBpcyBhIFJlZmVyZW5jZVR5cGUgd2hlcmUgdGhlIHRhcmdldCBpcyBmbGFnZ2VkIFR1cGxlIGFuZCB0aGVcbiAgICAgIC8vIHR5cGVBcmd1bWVudHMgYXJlIHRoZSB0dXBsZSBhcmd1bWVudHMuICBKdXN0IHRyZWF0IGl0IGFzIGEgbXlzdGVyeVxuICAgICAgLy8gYXJyYXksIGJlY2F1c2UgQ2xvc3VyZSBkb2Vzbid0IHVuZGVyc3RhbmQgdHVwbGVzLlxuICAgICAgaWYgKHJlZmVyZW5jZVR5cGUudGFyZ2V0Lm9iamVjdEZsYWdzICYgdHMuT2JqZWN0RmxhZ3MuVHVwbGUpIHtcbiAgICAgICAgcmV0dXJuICchQXJyYXk8Pz4nO1xuICAgICAgfVxuXG4gICAgICBsZXQgdHlwZVN0ciA9ICcnO1xuICAgICAgaWYgKHJlZmVyZW5jZVR5cGUudGFyZ2V0ID09PSByZWZlcmVuY2VUeXBlKSB7XG4gICAgICAgIC8vIFdlIGdldCBpbnRvIGFuIGluZmluaXRlIGxvb3AgaGVyZSBpZiB0aGUgaW5uZXIgcmVmZXJlbmNlIGlzXG4gICAgICAgIC8vIHRoZSBzYW1lIGFzIHRoZSBvdXRlcjsgdGhpcyBjYW4gb2NjdXIgd2hlbiB0aGlzIGZ1bmN0aW9uXG4gICAgICAgIC8vIGZhaWxzIHRvIHRyYW5zbGF0ZSBhIG1vcmUgc3BlY2lmaWMgdHlwZSBiZWZvcmUgZ2V0dGluZyB0b1xuICAgICAgICAvLyB0aGlzIHBvaW50LlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgcmVmZXJlbmNlIGxvb3AgaW4gJHt0eXBlVG9EZWJ1Z1N0cmluZyhyZWZlcmVuY2VUeXBlKX0gJHtyZWZlcmVuY2VUeXBlLmZsYWdzfWApO1xuICAgICAgfVxuICAgICAgdHlwZVN0ciArPSB0aGlzLnRyYW5zbGF0ZShyZWZlcmVuY2VUeXBlLnRhcmdldCk7XG4gICAgICAvLyBUcmFuc2xhdGUgY2FuIHJldHVybiAnPycgZm9yIGEgbnVtYmVyIG9mIHNpdHVhdGlvbnMsIGUuZy4gdHlwZS92YWx1ZSBjb25mbGljdHMuXG4gICAgICAvLyBgPzw/PmAgaXMgaWxsZWdhbCBzeW50YXggaW4gQ2xvc3VyZSBDb21waWxlciwgc28ganVzdCByZXR1cm4gYD9gIGhlcmUuXG4gICAgICBpZiAodHlwZVN0ciA9PT0gJz8nKSByZXR1cm4gJz8nO1xuICAgICAgaWYgKHJlZmVyZW5jZVR5cGUudHlwZUFyZ3VtZW50cykge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSByZWZlcmVuY2VUeXBlLnR5cGVBcmd1bWVudHMubWFwKHQgPT4gdGhpcy50cmFuc2xhdGUodCkpO1xuICAgICAgICB0eXBlU3RyICs9IGA8JHtwYXJhbXMuam9pbignLCAnKX0+YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlU3RyO1xuICAgIH0gZWxzZSBpZiAodHlwZS5vYmplY3RGbGFncyAmIHRzLk9iamVjdEZsYWdzLkFub255bW91cykge1xuICAgICAgaWYgKCF0eXBlLnN5bWJvbCkge1xuICAgICAgICAvLyBUaGlzIGNvbWVzIHVwIHdoZW4gZ2VuZXJhdGluZyBjb2RlIGZvciBhbiBhcnJvdyBmdW5jdGlvbiBhcyBwYXNzZWRcbiAgICAgICAgLy8gdG8gYSBnZW5lcmljIGZ1bmN0aW9uLiAgVGhlIHBhc3NlZC1pbiB0eXBlIGlzIHRhZ2dlZCBhcyBhbm9ueW1vdXNcbiAgICAgICAgLy8gYW5kIGhhcyBubyBwcm9wZXJ0aWVzIHNvIGl0J3MgaGFyZCB0byBmaWd1cmUgb3V0IHdoYXQgdG8gZ2VuZXJhdGUuXG4gICAgICAgIC8vIEp1c3QgYXZvaWQgaXQgZm9yIG5vdyBzbyB3ZSBkb24ndCBjcmFzaC5cbiAgICAgICAgdGhpcy53YXJuKCdhbm9ueW1vdXMgdHlwZSBoYXMgbm8gc3ltYm9sJyk7XG4gICAgICAgIHJldHVybiAnPyc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlLnN5bWJvbC5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLkZ1bmN0aW9uIHx8XG4gICAgICAgICAgdHlwZS5zeW1ib2wuZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5NZXRob2QpIHtcbiAgICAgICAgY29uc3Qgc2lncyA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0U2lnbmF0dXJlc09mVHlwZSh0eXBlLCB0cy5TaWduYXR1cmVLaW5kLkNhbGwpO1xuICAgICAgICBpZiAoc2lncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zaWduYXR1cmVUb0Nsb3N1cmUoc2lnc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YXJuKCd1bmhhbmRsZWQgYW5vbnltb3VzIHR5cGUgd2l0aCBtdWx0aXBsZSBjYWxsIHNpZ25hdHVyZXMnKTtcbiAgICAgICAgcmV0dXJuICc/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZUFub255bW91c1R5cGUodHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLypcbiAgICBUT0RPKHRzMi4xKTogbW9yZSB1bmhhbmRsZWQgb2JqZWN0IHR5cGUgZmxhZ3M6XG4gICAgICBUdXBsZVxuICAgICAgTWFwcGVkXG4gICAgICBJbnN0YW50aWF0ZWRcbiAgICAgIE9iamVjdExpdGVyYWxcbiAgICAgIEV2b2x2aW5nQXJyYXlcbiAgICAgIE9iamVjdExpdGVyYWxQYXR0ZXJuV2l0aENvbXB1dGVkUHJvcGVydGllc1xuICAgICovXG4gICAgdGhpcy53YXJuKGB1bmhhbmRsZWQgdHlwZSAke3R5cGVUb0RlYnVnU3RyaW5nKHR5cGUpfWApO1xuICAgIHJldHVybiAnPyc7XG4gIH1cblxuICAvKipcbiAgICogdHJhbnNsYXRlQW5vbnltb3VzVHlwZSB0cmFuc2xhdGVzIGEgdHMuVHlwZUZsYWdzLk9iamVjdFR5cGUgdGhhdCBpcyBhbHNvXG4gICAqIHRzLk9iamVjdEZsYWdzLkFub255bW91cy4gVGhhdCBpcywgdGhpcyB0eXBlJ3Mgc3ltYm9sIGRvZXMgbm90IGhhdmUgYSBuYW1lLiBUaGlzIGlzIHRoZVxuICAgKiBhbm9ueW1vdXMgdHlwZSBlbmNvdW50ZXJlZCBpbiBlLmcuXG4gICAqICAgICBsZXQgeDoge2E6IG51bWJlcn07XG4gICAqIEJ1dCBhbHNvIHRoZSBpbmZlcnJlZCB0eXBlIGluOlxuICAgKiAgICAgbGV0IHggPSB7YTogMX07ICAvLyB0eXBlIG9mIHggaXMge2E6IG51bWJlcn0sIGFzIGFib3ZlXG4gICAqL1xuICBwcml2YXRlIHRyYW5zbGF0ZUFub255bW91c1R5cGUodHlwZTogdHMuVHlwZSk6IHN0cmluZyB7XG4gICAgdGhpcy5zZWVuQW5vbnltb3VzVHlwZXMuYWRkKHR5cGUpO1xuICAgIC8vIEdhdGhlciB1cCBhbGwgdGhlIG5hbWVkIGZpZWxkcyBhbmQgd2hldGhlciB0aGUgb2JqZWN0IGlzIGFsc28gY2FsbGFibGUuXG4gICAgbGV0IGNhbGxhYmxlID0gZmFsc2U7XG4gICAgbGV0IGluZGV4YWJsZSA9IGZhbHNlO1xuICAgIGNvbnN0IGZpZWxkczogc3RyaW5nW10gPSBbXTtcbiAgICBpZiAoIXR5cGUuc3ltYm9sIHx8ICF0eXBlLnN5bWJvbC5tZW1iZXJzKSB7XG4gICAgICB0aGlzLndhcm4oJ2Fub255bW91cyB0eXBlIGhhcyBubyBzeW1ib2wnKTtcbiAgICAgIHJldHVybiAnPyc7XG4gICAgfVxuXG4gICAgLy8gc3BlY2lhbC1jYXNlIGNvbnN0cnVjdCBzaWduYXR1cmVzLlxuICAgIGNvbnN0IGN0b3JzID0gdHlwZS5nZXRDb25zdHJ1Y3RTaWduYXR1cmVzKCk7XG4gICAgaWYgKGN0b3JzLmxlbmd0aCkge1xuICAgICAgLy8gVE9ETyhtYXJ0aW5wcm9ic3QpOiB0aGlzIGRvZXMgbm90IHN1cHBvcnQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGRlZmluZWQgb24gY29uc3RydWN0b3JzXG4gICAgICAvLyAobm90IGV4cHJlc3NpYmxlIGluIENsb3N1cmUpLCBub3IgbXVsdGlwbGUgY29uc3RydWN0b3JzIChzYW1lKS5cbiAgICAgIGNvbnN0IGRlY2wgPSBjdG9yc1swXS5kZWNsYXJhdGlvbjtcbiAgICAgIGlmICghZGVjbCkge1xuICAgICAgICB0aGlzLndhcm4oJ3VuaGFuZGxlZCBhbm9ueW1vdXMgdHlwZSB3aXRoIGNvbnN0cnVjdG9yIHNpZ25hdHVyZSBidXQgbm8gZGVjbGFyYXRpb24nKTtcbiAgICAgICAgcmV0dXJuICc/JztcbiAgICAgIH1cbiAgICAgIGlmIChkZWNsLmtpbmQgPT09IHRzLlN5bnRheEtpbmRKU0RvY1NpZ25hdHVyZSkge1xuICAgICAgICB0aGlzLndhcm4oJ3VuaGFuZGxlZCBKU0RvYyBiYXNlZCBjb25zdHJ1Y3RvciBzaWduYXR1cmUnKTtcbiAgICAgICAgcmV0dXJuICc/JztcbiAgICAgIH1cblxuICAgICAgLy8gbmV3IDxUPih0ZWU6IFQpIGlzIG5vdCBzdXBwb3J0ZWQgYnkgQ2xvc3VyZSwgYmxhY2tsaXN0IGFzID8uXG4gICAgICB0aGlzLmJsYWNrbGlzdFR5cGVQYXJhbWV0ZXJzKHRoaXMuc3ltYm9sc1RvQWxpYXNlZE5hbWVzLCBkZWNsLnR5cGVQYXJhbWV0ZXJzKTtcblxuICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5jb252ZXJ0UGFyYW1zKGN0b3JzWzBdLCBkZWNsLnBhcmFtZXRlcnMpO1xuICAgICAgY29uc3QgcGFyYW1zU3RyID0gcGFyYW1zLmxlbmd0aCA/ICgnLCAnICsgcGFyYW1zLmpvaW4oJywgJykpIDogJyc7XG4gICAgICBjb25zdCBjb25zdHJ1Y3RlZFR5cGUgPSB0aGlzLnRyYW5zbGF0ZShjdG9yc1swXS5nZXRSZXR1cm5UeXBlKCkpO1xuICAgICAgLy8gSW4gdGhlIHNwZWNpZmljIGNhc2Ugb2YgdGhlIFwibmV3XCIgaW4gYSBmdW5jdGlvbiwgaXQgYXBwZWFycyB0aGF0XG4gICAgICAvLyAgIGZ1bmN0aW9uKG5ldzogIUJhcilcbiAgICAgIC8vIGZhaWxzIHRvIHBhcnNlLCB3aGlsZVxuICAgICAgLy8gICBmdW5jdGlvbihuZXc6ICghQmFyKSlcbiAgICAgIC8vIHBhcnNlcyBpbiB0aGUgd2F5IHlvdSdkIGV4cGVjdC5cbiAgICAgIC8vIEl0IGFwcGVhcnMgZnJvbSB0ZXN0aW5nIHRoYXQgQ2xvc3VyZSBpZ25vcmVzIHRoZSAhIGFueXdheSBhbmQganVzdFxuICAgICAgLy8gYXNzdW1lcyB0aGUgcmVzdWx0IHdpbGwgYmUgbm9uLW51bGwgaW4gZWl0aGVyIGNhc2UuICAoVG8gYmUgcGVkYW50aWMsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRvIHJldHVybiBudWxsIGZyb20gYSBjdG9yIGl0IHNlZW1zIGxpa2UgYSBiYWQgaWRlYS4pXG4gICAgICByZXR1cm4gYGZ1bmN0aW9uKG5ldzogKCR7Y29uc3RydWN0ZWRUeXBlfSkke3BhcmFtc1N0cn0pOiA/YDtcbiAgICB9XG5cbiAgICAvLyBtZW1iZXJzIGlzIGFuIEVTNiBtYXAsIGJ1dCB0aGUgLmQudHMgZGVmaW5pbmcgaXQgZGVmaW5lZCB0aGVpciBvd24gbWFwXG4gICAgLy8gdHlwZSwgc28gdHlwZXNjcmlwdCBkb2Vzbid0IGJlbGlldmUgdGhhdCAua2V5cygpIGlzIGl0ZXJhYmxlXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgIGZvciAoY29uc3QgZmllbGQgb2YgKHR5cGUuc3ltYm9sLm1lbWJlcnMua2V5cygpIGFzIGFueSkpIHtcbiAgICAgIHN3aXRjaCAoZmllbGQpIHtcbiAgICAgICAgY2FzZSAnX19jYWxsJzpcbiAgICAgICAgICBjYWxsYWJsZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ19faW5kZXgnOlxuICAgICAgICAgIGluZGV4YWJsZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFpc1ZhbGlkQ2xvc3VyZVByb3BlcnR5TmFtZShmaWVsZCkpIHtcbiAgICAgICAgICAgIHRoaXMud2Fybihgb21pdHRpbmcgaW5leHByZXNzaWJsZSBwcm9wZXJ0eSBuYW1lOiAke2ZpZWxkfWApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG1lbWJlciA9IHR5cGUuc3ltYm9sLm1lbWJlcnMuZ2V0KGZpZWxkKSE7XG4gICAgICAgICAgLy8gb3B0aW9uYWwgbWVtYmVycyBhcmUgaGFuZGxlZCBieSB0aGUgdHlwZSBpbmNsdWRpbmcgfHVuZGVmaW5lZCBpbiBhIHVuaW9uIHR5cGUuXG4gICAgICAgICAgY29uc3QgbWVtYmVyVHlwZSA9XG4gICAgICAgICAgICAgIHRoaXMudHJhbnNsYXRlKHRoaXMudHlwZUNoZWNrZXIuZ2V0VHlwZU9mU3ltYm9sQXRMb2NhdGlvbihtZW1iZXIsIHRoaXMubm9kZSkpO1xuICAgICAgICAgIGZpZWxkcy5wdXNoKGAke2ZpZWxkfTogJHttZW1iZXJUeXBlfWApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyeSB0byBzcGVjaWFsLWNhc2UgcGxhaW4ga2V5LXZhbHVlIG9iamVjdHMgYW5kIGZ1bmN0aW9ucy5cbiAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKGNhbGxhYmxlICYmICFpbmRleGFibGUpIHtcbiAgICAgICAgLy8gQSBmdW5jdGlvbiB0eXBlLlxuICAgICAgICBjb25zdCBzaWdzID0gdGhpcy50eXBlQ2hlY2tlci5nZXRTaWduYXR1cmVzT2ZUeXBlKHR5cGUsIHRzLlNpZ25hdHVyZUtpbmQuQ2FsbCk7XG4gICAgICAgIGlmIChzaWdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNpZ25hdHVyZVRvQ2xvc3VyZShzaWdzWzBdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpbmRleGFibGUgJiYgIWNhbGxhYmxlKSB7XG4gICAgICAgIC8vIEEgcGxhaW4ga2V5LXZhbHVlIG1hcCB0eXBlLlxuICAgICAgICBsZXQga2V5VHlwZSA9ICdzdHJpbmcnO1xuICAgICAgICBsZXQgdmFsVHlwZSA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0SW5kZXhUeXBlT2ZUeXBlKHR5cGUsIHRzLkluZGV4S2luZC5TdHJpbmcpO1xuICAgICAgICBpZiAoIXZhbFR5cGUpIHtcbiAgICAgICAgICBrZXlUeXBlID0gJ251bWJlcic7XG4gICAgICAgICAgdmFsVHlwZSA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0SW5kZXhUeXBlT2ZUeXBlKHR5cGUsIHRzLkluZGV4S2luZC5OdW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsVHlwZSkge1xuICAgICAgICAgIHRoaXMud2FybigndW5rbm93biBpbmRleCBrZXkgdHlwZScpO1xuICAgICAgICAgIHJldHVybiBgIU9iamVjdDw/LD8+YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCFPYmplY3Q8JHtrZXlUeXBlfSwke3RoaXMudHJhbnNsYXRlKHZhbFR5cGUpfT5gO1xuICAgICAgfSBlbHNlIGlmICghY2FsbGFibGUgJiYgIWluZGV4YWJsZSkge1xuICAgICAgICAvLyBTcGVjaWFsLWNhc2UgdGhlIGVtcHR5IG9iamVjdCB7fSBiZWNhdXNlIENsb3N1cmUgZG9lc24ndCBsaWtlIGl0LlxuICAgICAgICAvLyBUT0RPKGV2YW5tKTogcmV2aXNpdCB0aGlzIGlmIGl0IGlzIGEgcHJvYmxlbS5cbiAgICAgICAgcmV0dXJuICchT2JqZWN0JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWNhbGxhYmxlICYmICFpbmRleGFibGUpIHtcbiAgICAgIC8vIE5vdCBjYWxsYWJsZSwgbm90IGluZGV4YWJsZTsgaW1wbGllcyBhIHBsYWluIG9iamVjdCB3aXRoIGZpZWxkcyBpbiBpdC5cbiAgICAgIHJldHVybiBgeyR7ZmllbGRzLmpvaW4oJywgJyl9fWA7XG4gICAgfVxuXG4gICAgdGhpcy53YXJuKCd1bmhhbmRsZWQgYW5vbnltb3VzIHR5cGUnKTtcbiAgICByZXR1cm4gJz8nO1xuICB9XG5cbiAgLyoqIENvbnZlcnRzIGEgdHMuU2lnbmF0dXJlIChmdW5jdGlvbiBzaWduYXR1cmUpIHRvIGEgQ2xvc3VyZSBmdW5jdGlvbiB0eXBlLiAqL1xuICBwcml2YXRlIHNpZ25hdHVyZVRvQ2xvc3VyZShzaWc6IHRzLlNpZ25hdHVyZSk6IHN0cmluZyB7XG4gICAgLy8gVE9ETyhtYXJ0aW5wcm9ic3QpOiBDb25zaWRlciBoYXJtb25pemluZyBzb21lIG92ZXJsYXAgd2l0aCBlbWl0RnVuY3Rpb25UeXBlIGluIHRzaWNrbGUudHMuXG4gICAgaWYgKCFzaWcuZGVjbGFyYXRpb24pIHtcbiAgICAgIHRoaXMud2Fybignc2lnbmF0dXJlIHdpdGhvdXQgZGVjbGFyYXRpb24nKTtcbiAgICAgIHJldHVybiAnRnVuY3Rpb24nO1xuICAgIH1cbiAgICBpZiAoc2lnLmRlY2xhcmF0aW9uLmtpbmQgPT09IHRzLlN5bnRheEtpbmRKU0RvY1NpZ25hdHVyZSkge1xuICAgICAgdGhpcy53YXJuKCdzaWduYXR1cmUgd2l0aCBKU0RvYyBkZWNsYXJhdGlvbicpO1xuICAgICAgcmV0dXJuICdGdW5jdGlvbic7XG4gICAgfVxuICAgIHRoaXMuYmxhY2tsaXN0VHlwZVBhcmFtZXRlcnModGhpcy5zeW1ib2xzVG9BbGlhc2VkTmFtZXMsIHNpZy5kZWNsYXJhdGlvbi50eXBlUGFyYW1ldGVycyk7XG5cbiAgICBsZXQgdHlwZVN0ciA9IGBmdW5jdGlvbihgO1xuICAgIGxldCBwYXJhbURlY2xzOiBSZWFkb25seUFycmF5PHRzLlBhcmFtZXRlckRlY2xhcmF0aW9uPiA9IHNpZy5kZWNsYXJhdGlvbi5wYXJhbWV0ZXJzIHx8IFtdO1xuICAgIGNvbnN0IG1heWJlVGhpc1BhcmFtID0gcGFyYW1EZWNsc1swXTtcbiAgICAvLyBPZGRseSwgdGhlIHRoaXMgdHlwZSBzaG93cyB1cCBpbiBwYXJhbURlY2xzLCBidXQgbm90IGluIHRoZSB0eXBlJ3MgcGFyYW1ldGVycy5cbiAgICAvLyBIYW5kbGUgaXQgaGVyZSBhbmQgdGhlbiBwYXNzIHBhcmFtRGVjbHMgZG93biB3aXRob3V0IGl0cyBmaXJzdCBlbGVtZW50LlxuICAgIGlmIChtYXliZVRoaXNQYXJhbSAmJiBtYXliZVRoaXNQYXJhbS5uYW1lLmdldFRleHQoKSA9PT0gJ3RoaXMnKSB7XG4gICAgICBpZiAobWF5YmVUaGlzUGFyYW0udHlwZSkge1xuICAgICAgICBjb25zdCB0aGlzVHlwZSA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0VHlwZUF0TG9jYXRpb24obWF5YmVUaGlzUGFyYW0udHlwZSk7XG4gICAgICAgIHR5cGVTdHIgKz0gYHRoaXM6ICgke3RoaXMudHJhbnNsYXRlKHRoaXNUeXBlKX0pYDtcbiAgICAgICAgaWYgKHBhcmFtRGVjbHMubGVuZ3RoID4gMSkgdHlwZVN0ciArPSAnLCAnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53YXJuKCd0aGlzIHR5cGUgd2l0aG91dCB0eXBlJyk7XG4gICAgICB9XG4gICAgICBwYXJhbURlY2xzID0gcGFyYW1EZWNscy5zbGljZSgxKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLmNvbnZlcnRQYXJhbXMoc2lnLCBwYXJhbURlY2xzKTtcbiAgICB0eXBlU3RyICs9IGAke3BhcmFtcy5qb2luKCcsICcpfSlgO1xuXG4gICAgY29uc3QgcmV0VHlwZSA9IHRoaXMudHJhbnNsYXRlKHRoaXMudHlwZUNoZWNrZXIuZ2V0UmV0dXJuVHlwZU9mU2lnbmF0dXJlKHNpZykpO1xuICAgIGlmIChyZXRUeXBlKSB7XG4gICAgICB0eXBlU3RyICs9IGA6ICR7cmV0VHlwZX1gO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlU3RyO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHBhcmFtZXRlcnMgZm9yIHRoZSBnaXZlbiBzaWduYXR1cmUuIFRha2VzIHBhcmFtZXRlciBkZWNsYXJhdGlvbnMgYXMgdGhvc2UgbWlnaHQgbm90XG4gICAqIG1hdGNoIHRoZSBzaWduYXR1cmUgcGFyYW1ldGVycyAoZS5nLiB0aGVyZSBtaWdodCBiZSBhbiBhZGRpdGlvbmFsIHRoaXMgcGFyYW1ldGVyKS4gVGhpc1xuICAgKiBkaWZmZXJlbmNlIGlzIGhhbmRsZWQgYnkgdGhlIGNhbGxlciwgYXMgaXMgY29udmVydGluZyB0aGUgXCJ0aGlzXCIgcGFyYW1ldGVyLlxuICAgKi9cbiAgcHJpdmF0ZSBjb252ZXJ0UGFyYW1zKHNpZzogdHMuU2lnbmF0dXJlLCBwYXJhbURlY2xzOiBSZWFkb25seUFycmF5PHRzLlBhcmFtZXRlckRlY2xhcmF0aW9uPik6XG4gICAgICBzdHJpbmdbXSB7XG4gICAgY29uc3QgcGFyYW1UeXBlczogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZy5wYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHNpZy5wYXJhbWV0ZXJzW2ldO1xuXG4gICAgICBjb25zdCBwYXJhbURlY2wgPSBwYXJhbURlY2xzW2ldO1xuICAgICAgY29uc3Qgb3B0aW9uYWwgPSAhIXBhcmFtRGVjbC5xdWVzdGlvblRva2VuO1xuICAgICAgY29uc3QgdmFyQXJncyA9ICEhcGFyYW1EZWNsLmRvdERvdERvdFRva2VuO1xuICAgICAgbGV0IHBhcmFtVHlwZSA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0VHlwZU9mU3ltYm9sQXRMb2NhdGlvbihwYXJhbSwgdGhpcy5ub2RlKTtcbiAgICAgIGlmICh2YXJBcmdzKSB7XG4gICAgICAgIGNvbnN0IHR5cGVSZWYgPSBwYXJhbVR5cGUgYXMgdHMuVHlwZVJlZmVyZW5jZTtcbiAgICAgICAgcGFyYW1UeXBlID0gdHlwZVJlZi50eXBlQXJndW1lbnRzIVswXTtcbiAgICAgIH1cbiAgICAgIGxldCB0eXBlU3RyID0gdGhpcy50cmFuc2xhdGUocGFyYW1UeXBlKTtcbiAgICAgIGlmICh2YXJBcmdzKSB0eXBlU3RyID0gJy4uLicgKyB0eXBlU3RyO1xuICAgICAgaWYgKG9wdGlvbmFsKSB0eXBlU3RyID0gdHlwZVN0ciArICc9JztcbiAgICAgIHBhcmFtVHlwZXMucHVzaCh0eXBlU3RyKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtVHlwZXM7XG4gIH1cblxuICB3YXJuKG1zZzogc3RyaW5nKSB7XG4gICAgLy8gQnkgZGVmYXVsdCwgd2FybigpIGRvZXMgbm90aGluZy4gIFRoZSBjYWxsZXIgd2lsbCBvdmVyd3JpdGUgdGhpc1xuICAgIC8vIGlmIGl0IHdhbnRzIGRpZmZlcmVudCBiZWhhdmlvci5cbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHRydWUgaWYgc3ltIHNob3VsZCBhbHdheXMgaGF2ZSB0eXBlIHs/fS4gKi9cbiAgaXNCbGFja0xpc3RlZChzeW1ib2w6IHRzLlN5bWJvbCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLnBhdGhCbGFja0xpc3QgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHBhdGhCbGFja0xpc3QgPSB0aGlzLnBhdGhCbGFja0xpc3Q7XG4gICAgLy8gU29tZSBidWlsdGluIHR5cGVzLCBzdWNoIGFzIHt9LCBnZXQgcmVwcmVzZW50ZWQgYnkgYSBzeW1ib2wgdGhhdCBoYXMgbm8gZGVjbGFyYXRpb25zLlxuICAgIGlmIChzeW1ib2wuZGVjbGFyYXRpb25zID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gc3ltYm9sLmRlY2xhcmF0aW9ucy5ldmVyeShuID0+IHtcbiAgICAgIGNvbnN0IGZpbGVOYW1lID0gcGF0aC5ub3JtYWxpemUobi5nZXRTb3VyY2VGaWxlKCkuZmlsZU5hbWUpO1xuICAgICAgcmV0dXJuIHBhdGhCbGFja0xpc3QuaGFzKGZpbGVOYW1lKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zdXJlIGRvZXNuIG5vdCBzdXBwb3J0IHR5cGUgcGFyYW1ldGVycyBmb3IgZnVuY3Rpb24gdHlwZXMsIGkuZS4gZ2VuZXJpYyBmdW5jdGlvbiB0eXBlcy5cbiAgICogQmxhY2tsaXN0IHRoZSBzeW1ib2xzIGRlY2xhcmVkIGJ5IHRoZW0gYW5kIGVtaXQgYSA/IGZvciB0aGUgdHlwZXMuXG4gICAqXG4gICAqIFRoaXMgbXV0YXRlcyB0aGUgZ2l2ZW4gYmxhY2tsaXN0IG1hcC4gVGhlIG1hcCdzIHNjb3BlIGlzIG9uZSBmaWxlLCBhbmQgc3ltYm9scyBhcmVcbiAgICogdW5pcXVlIG9iamVjdHMsIHNvIHRoaXMgc2hvdWxkIG5laXRoZXIgbGVhZCB0byBleGNlc3NpdmUgbWVtb3J5IGNvbnN1bXB0aW9uIG5vciBpbnRyb2R1Y2VcbiAgICogZXJyb3JzLlxuICAgKlxuICAgKiBAcGFyYW0gYmxhY2tsaXN0IGEgbWFwIHRvIHN0b3JlIHRoZSBibGFja2xpc3RlZCBzeW1ib2xzIGluLCB3aXRoIGEgdmFsdWUgb2YgJz8nLiBJbiBwcmFjdGljZSxcbiAgICogICAgIHRoaXMgaXMgYWx3YXlzID09PSB0aGlzLnN5bWJvbHNUb0FsaWFzZWROYW1lcywgYnV0IHdlJ3JlIHBhc3NpbmcgaXQgZXhwbGljaXRseSB0byBtYWtlIGl0XG4gICAqICAgIGNsZWFyIHRoYXQgdGhlIG1hcCBpcyBtdXRhdGVkIChpbiBwYXJ0aWN1bGFyIHdoZW4gdXNlZCBmcm9tIG91dHNpZGUgdGhlIGNsYXNzKS5cbiAgICogQHBhcmFtIGRlY2xzIHRoZSBkZWNsYXJhdGlvbnMgd2hvc2Ugc3ltYm9scyBzaG91bGQgYmUgYmxhY2tsaXN0ZWQuXG4gICAqL1xuICBibGFja2xpc3RUeXBlUGFyYW1ldGVycyhcbiAgICAgIGJsYWNrbGlzdDogTWFwPHRzLlN5bWJvbCwgc3RyaW5nPixcbiAgICAgIGRlY2xzOiBSZWFkb25seUFycmF5PHRzLlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbj58dW5kZWZpbmVkKSB7XG4gICAgaWYgKCFkZWNscyB8fCAhZGVjbHMubGVuZ3RoKSByZXR1cm47XG4gICAgZm9yIChjb25zdCB0cGQgb2YgZGVjbHMpIHtcbiAgICAgIGNvbnN0IHN5bSA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbih0cGQubmFtZSk7XG4gICAgICBpZiAoIXN5bSkge1xuICAgICAgICB0aGlzLndhcm4oYHR5cGUgcGFyYW1ldGVyIHdpdGggbm8gc3ltYm9sYCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5zeW1ib2xzVG9BbGlhc2VkTmFtZXMuc2V0KHN5bSwgJz8nKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==