/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/externs", ["require", "exports", "path", "tsickle/src/googmodule", "tsickle/src/jsdoc", "tsickle/src/jsdoc_transformer", "tsickle/src/module_type_translator", "tsickle/src/transformer_util", "tsickle/src/type_translator", "tsickle/src/typescript"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @fileoverview Externs creates Closure Compiler \@externs definitions from the
     * ambient declarations in a TypeScript file.
     *
     * For example, a declare interface Foo { bar: string; } Would generate a /..
     *   \@externs ./ /.. \@record ./ var Foo = function() {}; /.. \@type {string}
     *   ./ Foo.prototype.bar;
     *
     * The generated externs indicate to Closure Compiler that symbols are external
     * to the optimization process, i.e. they are provided by outside code. That
     * most importantly means they must not be renamed or removed.
     *
     * A major difficulty here is that TypeScript supports module-scoped external
     * symbols; `.d.ts` files can contain `export`s and `import` other files.
     * Closure Compiler does not have such a concept, so tsickle must emulate the
     * behaviour. It does so by following this scheme:
     *
     * 1. non-module .d.ts produces global symbols
     * 2. module .d.ts produce symbols namespaced to the module, by creating a
     *    mangled name matching the current file's path. tsickle expects outside
     *    code (e.g. build system integration or manually written code) to contain a
     *    goog.module/provide that references the mangled path.
     * 3. declarations in `.ts` files produce types that can be separately emitted
     *    in e.g. an `externs.js`, using `getGeneratedExterns` below.
     *    1. non-exported symbols produce global types, because that's what users
     *       expect and it matches TypeScripts emit, which just references `Foo` for
     *       a locally declared symbol `Foo` in a module. Arguably these should be
     *       wrapped in `declare global { ... }`.
     *    2. exported symbols are scoped to the `.ts` file by prefixing them with a
     *       mangled name. Exported types are re-exported from the JavaScript
     *       `goog.module`, allowing downstream code to reference them. This has the
     *       same problem regarding ambient values as above, it is unclear where the
     *       value symbol would be defined, so for the time being this is
     *       unsupported.
     *
     * The effect of this is that:
     * - symbols in a module (i.e. not globals) are generally scoped to the local
     *   module using a mangled name, preventing symbol collisions on the Closure
     *   side.
     * - importing code can unconditionally refer to and import any symbol defined
     *   in a module `X` as `path.to.module.X`, regardless of whether the defining
     *   location is a `.d.ts` file or a `.ts` file, and regardless whether the
     *   symbol is ambient (assuming there's an appropriate shim).
     * - if there is a shim present, tsickle avoids emitting the Closure namespace
     *   itself, expecting the shim to provide the namespace and initialize it to a
     *   symbol that provides the right value at runtime (i.e. the implementation of
     *   whatever third party library the .d.ts describes).
     */
    var path = require("path");
    var googmodule_1 = require("tsickle/src/googmodule");
    var jsdoc = require("tsickle/src/jsdoc");
    var jsdoc_transformer_1 = require("tsickle/src/jsdoc_transformer");
    var module_type_translator_1 = require("tsickle/src/module_type_translator");
    var transformer_util_1 = require("tsickle/src/transformer_util");
    var type_translator_1 = require("tsickle/src/type_translator");
    var ts = require("tsickle/src/typescript");
    /**
     * Symbols that are already declared as externs in Closure, that should
     * be avoided by tsickle's "declare ..." => externs.js conversion.
     */
    var CLOSURE_EXTERNS_BLACKLIST = [
        'exports',
        'global',
        'module',
        // ErrorConstructor is the interface of the Error object itself.
        // tsickle detects that this is part of the TypeScript standard library
        // and assumes it's part of the Closure standard library, but this
        // assumption is wrong for ErrorConstructor.  To properly handle this
        // we'd somehow need to map methods defined on the ErrorConstructor
        // interface into properties on Closure's Error object, but for now it's
        // simpler to just blacklist it.
        'ErrorConstructor',
        'Symbol',
        'WorkerGlobalScope',
    ];
    /**
     * The header to be used in generated externs.  This is not included in the output of
     * generateExterns() because generateExterns() works one file at a time, and typically you create
     * one externs file from the entire compilation unit.
     *
     * Suppressions:
     * - duplicate: because externs might duplicate re-opened definitions from other JS files.
     * - checkTypes: Closure's type system does not match TS'.
     * - undefinedNames: code below tries to be careful not to overwrite previously emitted definitions,
     *   but on the flip side might accidentally miss definitions.
     */
    var EXTERNS_HEADER = "/**\n * @externs\n * @suppress {duplicate,checkTypes}\n */\n// NOTE: generated by tsickle, do not edit.\n";
    /**
     * Concatenate all generated externs definitions together into a string, including a file comment
     * header.
     */
    function getGeneratedExterns(externs) {
        var e_1, _a;
        var allExterns = EXTERNS_HEADER;
        try {
            for (var _b = __values(Object.keys(externs)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var fileName = _c.value;
                allExterns += "// externs from " + fileName + ":\n";
                allExterns += externs[fileName];
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return allExterns;
    }
    exports.getGeneratedExterns = getGeneratedExterns;
    /**
     * Returns a mangled version of the module name (resolved file name) for source file.
     *
     * The mangled name is safe to use as a JavaScript identifier. It is used as a globally unique
     * prefix to scope symbols in externs file (see code below).
     *
     * @param contextFileName if given is used as the context file path to resolve the source file's
     *     name against.
     */
    function moduleNameAsIdentifier(host, fileName, contextFileName) {
        var resolved = googmodule_1.resolveModuleName(host, contextFileName || '', fileName);
        return host.pathToModuleName('', resolved).replace(/\./g, '$');
    }
    exports.moduleNameAsIdentifier = moduleNameAsIdentifier;
    /**
     * isInGlobalAugmentation returns true if declaration is the immediate child of a 'declare global'
     * block.
     */
    function isInGlobalAugmentation(declaration) {
        // declare global { ... } creates a ModuleDeclaration containing a ModuleBlock containing the
        // declaration, with the ModuleDeclaration having the GlobalAugmentation flag set.
        if (!declaration.parent || !declaration.parent.parent)
            return false;
        return (declaration.parent.parent.flags & ts.NodeFlags.GlobalAugmentation) !== 0;
    }
    /**
     * generateExterns generates extern definitions for all ambient declarations in the given source
     * file. It returns a string representation of the Closure JavaScript, not including the initial
     * comment with \@fileoverview and \@externs (see above for that).
     */
    function generateExterns(typeChecker, sourceFile, host, moduleResolutionHost, options) {
        var e_2, _a, e_3, _b;
        var output = '';
        var diagnostics = [];
        var isDts = transformer_util_1.isDtsFileName(sourceFile.fileName);
        var isExternalModule = ts.isExternalModule(sourceFile);
        var mtt = new module_type_translator_1.ModuleTypeTranslator(sourceFile, typeChecker, host, diagnostics, /*isForExterns*/ true);
        var rootNamespace = '';
        if (isExternalModule) {
            // .d.ts files that are modules do not declare global symbols - their symbols must be explicitly
            // imported to be used. However Closure Compiler has no concept of externs that are modules and
            // require imports. This code mangles the symbol names by wrapping them in a top level variable
            // that's unique to this file. That allows emitting them for Closure as global symbols while
            // avoiding collisions. This is necessary as symbols local to this module can (and will very
            // commonly) conflict with the namespace used in "export as namespace", e.g. "angular", and also
            // to avoid users accidentally using these symbols in .js files (and more collisions). The
            // symbols that are "hidden" like that can be made accessible through an "export as namespace"
            // declaration (see below).
            rootNamespace = moduleNameAsIdentifier(host, sourceFile.fileName);
        }
        try {
            for (var _c = __values(sourceFile.statements), _d = _c.next(); !_d.done; _d = _c.next()) {
                var stmt = _d.value;
                if (!isDts && !transformer_util_1.hasModifierFlag(stmt, ts.ModifierFlags.Ambient))
                    continue;
                visitor(stmt, []);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_2) throw e_2.error; }
        }
        if (output && isExternalModule) {
            // If tsickle generated any externs and this is an external module, prepend the namespace
            // declaration for it.
            output = "/** @const */\nvar " + rootNamespace + " = {};\n" + output;
            // There can only be one export =.
            var exportAssignment = sourceFile.statements.find(ts.isExportAssignment);
            var exportedNamespace = rootNamespace;
            if (exportAssignment && exportAssignment.isExportEquals) {
                if (ts.isIdentifier(exportAssignment.expression) ||
                    ts.isQualifiedName(exportAssignment.expression)) {
                    // E.g. export = someName;
                    // If someName is "declare global { namespace someName {...} }", tsickle must not qualify
                    // access to it with module namespace as it is emitted in the global namespace.
                    var symbol = typeChecker.getSymbolAtLocation(exportAssignment.expression);
                    var isGlobalSymbol = symbol && symbol.declarations &&
                        symbol.declarations.some(function (d) { return isInGlobalAugmentation(d); });
                    var entityName = transformer_util_1.getEntityNameText(exportAssignment.expression);
                    if (isGlobalSymbol) {
                        exportedNamespace = entityName;
                    }
                    else {
                        exportedNamespace = rootNamespace + '.' + entityName;
                    }
                }
                else {
                    transformer_util_1.reportDiagnostic(diagnostics, exportAssignment.expression, "export = expression must be a qualified name, got " + ts.SyntaxKind[exportAssignment.expression.kind] + ".");
                }
            }
            if (isDts && host.provideExternalModuleDtsNamespace) {
                try {
                    // In a non-shimmed module, create a global namespace. This exists purely for backwards
                    // compatiblity, in the medium term all code using tsickle should always use `goog.module`s,
                    // so global names should not be neccessary.
                    for (var _e = __values(sourceFile.statements.filter(ts.isNamespaceExportDeclaration)), _f = _e.next(); !_f.done; _f = _e.next()) {
                        var nsExport = _f.value;
                        var namespaceName = transformer_util_1.getIdentifierText(nsExport.name);
                        emit("// export as namespace " + namespaceName + "\n");
                        writeVariableStatement(namespaceName, [], exportedNamespace);
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
        }
        return { output: output, diagnostics: diagnostics };
        function emit(str) {
            output += str;
        }
        /**
         * isFirstDeclaration returns true if decl is the first declaration
         * of its symbol.  E.g. imagine
         *   interface Foo { x: number; }
         *   interface Foo { y: number; }
         * we only want to emit the "\@record" for Foo on the first one.
         *
         * The exception are variable declarations, which - in externs - do not assign a value:
         *   /.. \@type {...} ./
         *   var someVariable;
         *   /.. \@type {...} ./
         *   someNamespace.someVariable;
         * If a later declaration wants to add additional properties on someVariable, tsickle must still
         * emit an assignment into the object, as it's otherwise absent.
         */
        function isFirstValueDeclaration(decl) {
            if (!decl.name)
                return true;
            var sym = typeChecker.getSymbolAtLocation(decl.name);
            if (!sym.declarations || sym.declarations.length < 2)
                return true;
            var earlierDecls = sym.declarations.slice(0, sym.declarations.indexOf(decl));
            // Either there are no earlier declarations, or all of them are variables (see above). tsickle
            // emits a value for all other declaration kinds (function for functions, classes, interfaces,
            // {} object for namespaces).
            return earlierDecls.length === 0 || earlierDecls.every(ts.isVariableDeclaration);
        }
        /** Writes the actual variable statement of a Closure variable declaration. */
        function writeVariableStatement(name, namespace, value) {
            var qualifiedName = namespace.concat([name]).join('.');
            if (namespace.length === 0)
                emit("var ");
            emit(qualifiedName);
            if (value)
                emit(" = " + value);
            emit(';\n');
        }
        /**
         * Writes a Closure variable declaration, i.e. the variable statement with a leading JSDoc
         * comment making it a declaration.
         */
        function writeVariableDeclaration(decl, namespace) {
            if (decl.name.kind === ts.SyntaxKind.Identifier) {
                var name_1 = transformer_util_1.getIdentifierText(decl.name);
                if (CLOSURE_EXTERNS_BLACKLIST.indexOf(name_1) >= 0)
                    return;
                emit(jsdoc.toString([{ tagName: 'type', type: mtt.typeToClosure(decl) }]));
                emit('\n');
                writeVariableStatement(name_1, namespace);
            }
            else {
                errorUnimplementedKind(decl.name, 'externs for variable');
            }
        }
        /**
         * Emits a JSDoc declaration that merges the signatures of the given function declaration (for
         * overloads), and returns the parameter names chosen.
         */
        function emitFunctionType(decls, extraTags) {
            if (extraTags === void 0) { extraTags = []; }
            var _a = __read(mtt.getFunctionTypeJSDoc(decls, extraTags), 2), tags = _a[0], paramNames = _a[1];
            emit('\n');
            emit(jsdoc.toString(tags));
            return paramNames;
        }
        function writeFunction(name, params, namespace) {
            var paramsStr = params.join(', ');
            if (namespace.length > 0) {
                var fqn = namespace.join('.');
                if (name.kind === ts.SyntaxKind.Identifier) {
                    fqn += '.'; // computed names include [ ] in their getText() representation.
                }
                fqn += name.getText();
                emit(fqn + " = function(" + paramsStr + ") {};\n");
            }
            else {
                if (name.kind !== ts.SyntaxKind.Identifier) {
                    transformer_util_1.reportDiagnostic(diagnostics, name, 'Non-namespaced computed name in externs');
                }
                emit("function " + name.getText() + "(" + paramsStr + ") {}\n");
            }
        }
        function writeEnum(decl, namespace) {
            var e_4, _a;
            var name = transformer_util_1.getIdentifierText(decl.name);
            emit('\n/** @const */\n');
            writeVariableStatement(name, namespace, '{}');
            namespace = namespace.concat([name]);
            try {
                for (var _b = __values(decl.members), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var member = _c.value;
                    var memberName = void 0;
                    switch (member.name.kind) {
                        case ts.SyntaxKind.Identifier:
                            memberName = transformer_util_1.getIdentifierText(member.name);
                            break;
                        case ts.SyntaxKind.StringLiteral:
                            var text = member.name.text;
                            if (type_translator_1.isValidClosurePropertyName(text))
                                memberName = text;
                            break;
                        default:
                            break;
                    }
                    if (!memberName) {
                        emit("\n/* TODO: " + ts.SyntaxKind[member.name.kind] + ": " + jsdoc_transformer_1.escapeForComment(member.name.getText()) + " */\n");
                        continue;
                    }
                    emit('/** @const {number} */\n');
                    writeVariableStatement(memberName, namespace);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_4) throw e_4.error; }
            }
        }
        function writeTypeAlias(decl, namespace) {
            var typeStr = mtt.typeToClosure(decl, undefined);
            emit("\n/** @typedef {" + typeStr + "} */\n");
            writeVariableStatement(transformer_util_1.getIdentifierText(decl.name), namespace);
        }
        function writeType(decl, namespace) {
            var e_5, _a, e_6, _b;
            var name = decl.name;
            if (!name) {
                transformer_util_1.reportDiagnostic(diagnostics, decl, 'anonymous type in externs');
                return;
            }
            var typeName = namespace.concat([name.getText()]).join('.');
            if (CLOSURE_EXTERNS_BLACKLIST.indexOf(typeName) >= 0)
                return;
            if (isFirstValueDeclaration(decl)) {
                // Emit the 'function' that is actually the declaration of the interface
                // itself.  If it's a class, this function also must include the type
                // annotations of the constructor.
                var paramNames = [];
                var jsdocTags = [];
                var wroteJsDoc = false;
                jsdoc_transformer_1.maybeAddHeritageClauses(jsdocTags, mtt, decl);
                jsdoc_transformer_1.maybeAddTemplateClause(jsdocTags, decl);
                if (decl.kind === ts.SyntaxKind.ClassDeclaration) {
                    // TODO: it appears you can just write 'class Foo { ...' in externs.
                    // This code instead tries to translate it to a function.
                    jsdocTags.push({ tagName: 'constructor' }, { tagName: 'struct' });
                    var ctors = decl
                        .members.filter(function (m) { return m.kind === ts.SyntaxKind.Constructor; });
                    if (ctors.length) {
                        var firstCtor = ctors[0];
                        if (ctors.length > 1) {
                            paramNames = emitFunctionType(ctors, jsdocTags);
                        }
                        else {
                            paramNames = emitFunctionType([firstCtor], jsdocTags);
                        }
                        wroteJsDoc = true;
                    }
                }
                else {
                    // Otherwise it's an interface; tag it as structurally typed.
                    jsdocTags.push({ tagName: 'record' }, { tagName: 'struct' });
                }
                if (!wroteJsDoc)
                    emit(jsdoc.toString(jsdocTags));
                writeFunction(name, paramNames, namespace);
            }
            // Process everything except (MethodSignature|MethodDeclaration|Constructor)
            var methods = new Map();
            try {
                for (var _c = __values(decl.members), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var member = _d.value;
                    switch (member.kind) {
                        case ts.SyntaxKind.PropertySignature:
                        case ts.SyntaxKind.PropertyDeclaration:
                            var prop = member;
                            if (prop.name.kind === ts.SyntaxKind.Identifier) {
                                var type = mtt.typeToClosure(prop);
                                if (prop.questionToken && type === '?') {
                                    // An optional 'any' type translates to '?|undefined' in Closure.
                                    type = '?|undefined';
                                }
                                emit(jsdoc.toString([{ tagName: 'type', type: type }]));
                                if (transformer_util_1.hasModifierFlag(prop, ts.ModifierFlags.Static)) {
                                    emit("\n" + typeName + "." + prop.name.getText() + ";\n");
                                }
                                else {
                                    emit("\n" + typeName + ".prototype." + prop.name.getText() + ";\n");
                                }
                                continue;
                            }
                            // TODO: For now property names other than Identifiers are not handled; e.g.
                            //    interface Foo { "123bar": number }
                            break;
                        case ts.SyntaxKind.MethodSignature:
                        case ts.SyntaxKind.MethodDeclaration:
                            var method = member;
                            var isStatic = transformer_util_1.hasModifierFlag(method, ts.ModifierFlags.Static);
                            var methodSignature = method.name.getText() + "$$$" + (isStatic ? 'static' : 'instance');
                            if (methods.has(methodSignature)) {
                                methods.get(methodSignature).push(method);
                            }
                            else {
                                methods.set(methodSignature, [method]);
                            }
                            continue;
                        case ts.SyntaxKind.Constructor:
                            continue; // Handled above.
                        default:
                            // Members can include things like index signatures, for e.g.
                            //   interface Foo { [key: string]: number; }
                            // For now, just skip it.
                            break;
                    }
                    // If we get here, the member wasn't handled in the switch statement.
                    var memberName = namespace;
                    if (member.name) {
                        memberName = memberName.concat([member.name.getText()]);
                    }
                    emit("\n/* TODO: " + ts.SyntaxKind[member.kind] + ": " + memberName.join('.') + " */\n");
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_5) throw e_5.error; }
            }
            try {
                // Handle method declarations/signatures separately, since we need to deal with overloads.
                for (var _e = __values(Array.from(methods.values())), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var methodVariants = _f.value;
                    var firstMethodVariant = methodVariants[0];
                    var parameterNames = void 0;
                    if (methodVariants.length > 1) {
                        parameterNames = emitFunctionType(methodVariants);
                    }
                    else {
                        parameterNames = emitFunctionType([firstMethodVariant]);
                    }
                    var methodNamespace = namespace.concat([name.getText()]);
                    // If the method is static, don't add the prototype.
                    if (!transformer_util_1.hasModifierFlag(firstMethodVariant, ts.ModifierFlags.Static)) {
                        methodNamespace.push('prototype');
                    }
                    writeFunction(firstMethodVariant.name, parameterNames, methodNamespace);
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_6) throw e_6.error; }
            }
        }
        /**
         * Adds aliases for the symbols imported in the given declaration, so that their types get
         * printed as the fully qualified name, and not just as a reference to the local import alias.
         *
         * tsickle generates .js files that (at most) contain a `goog.provide`, but are not
         * `goog.module`s. These files cannot express an aliased import. However Closure Compiler allows
         * referencing types using fully qualified names in such files, so tsickle can resolve the
         * imported module URI and produce `path.to.module.Symbol` as an alias, and use that when
         * referencing the type.
         */
        function addImportAliases(decl) {
            var e_7, _a;
            var moduleUri;
            if (ts.isImportDeclaration(decl)) {
                moduleUri = decl.moduleSpecifier.text;
            }
            else if (ts.isExternalModuleReference(decl.moduleReference)) {
                // import foo = require('./bar');
                moduleUri = decl.moduleReference.expression.text;
            }
            else {
                // import foo = bar.baz.bam;
                // unsupported.
                return;
            }
            var googNamespace = googmodule_1.extractGoogNamespaceImport(moduleUri);
            var moduleName = googNamespace ||
                host.pathToModuleName(sourceFile.fileName, googmodule_1.resolveModuleName(host, sourceFile.fileName, moduleUri));
            if (ts.isImportEqualsDeclaration(decl)) {
                // import foo = require('./bar');
                addImportAlias(decl.name, moduleName, undefined);
                return;
            }
            // Side effect import 'path'; declares no local aliases.
            if (!decl.importClause)
                return;
            if (decl.importClause.name) {
                // import name from ... -> map to .default on the module.name.
                if (googNamespace) {
                    addImportAlias(decl.importClause.name, googNamespace, undefined);
                }
                else {
                    addImportAlias(decl.importClause.name, moduleName, 'default');
                }
            }
            var namedBindings = decl.importClause.namedBindings;
            if (!namedBindings)
                return;
            if (ts.isNamespaceImport(namedBindings)) {
                // import * as name -> map directly to the module.name.
                addImportAlias(namedBindings.name, moduleName, undefined);
            }
            if (ts.isNamedImports(namedBindings)) {
                try {
                    // import {A as B}, map to module.name.A
                    for (var _b = __values(namedBindings.elements), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var namedBinding = _c.value;
                        addImportAlias(namedBinding.name, moduleName, namedBinding.name);
                    }
                }
                catch (e_7_1) { e_7 = { error: e_7_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_7) throw e_7.error; }
                }
            }
        }
        /**
         * Adds an import alias for the symbol defined at the given node. Creates an alias name based on
         * the given moduleName and (optionally) the name.
         */
        function addImportAlias(node, moduleName, name) {
            var symbol = typeChecker.getSymbolAtLocation(node);
            if (!symbol) {
                transformer_util_1.reportDiagnostic(diagnostics, node, "named import has no symbol");
                return;
            }
            var aliasName = moduleName;
            if (typeof name === 'string') {
                aliasName += '.' + name;
            }
            else if (name) {
                aliasName += '.' + transformer_util_1.getIdentifierText(name);
            }
            if (symbol.flags & ts.SymbolFlags.Alias) {
                symbol = typeChecker.getAliasedSymbol(symbol);
            }
            mtt.symbolsToAliasedNames.set(symbol, aliasName);
        }
        /**
         * Produces a compiler error that references the Node's kind. This is useful for the "else"
         * branch of code that is attempting to handle all possible input Node types, to ensure all cases
         * covered.
         */
        function errorUnimplementedKind(node, where) {
            transformer_util_1.reportDiagnostic(diagnostics, node, ts.SyntaxKind[node.kind] + " not implemented in " + where);
        }
        /**
         * getNamespaceForLocalDeclaration returns the namespace that should be used for the given
         * declaration, deciding whether to namespace the symbol to the file or whether to create a
         * global name.
         *
         * The function covers these cases:
         * 1) a declaration in a .d.ts
         * 1a) where the .d.ts is an external module     --> namespace
         * 1b) where the .d.ts is not an external module --> global
         * 2) a declaration in a .ts file (all are treated as modules)
         * 2a) that is exported                          --> namespace
         * 2b) that is unexported                        --> global
         *
         * For 1), all symbols in .d.ts should generally be namespaced to the file to avoid collisions.
         * However .d.ts files that are not external modules do declare global names (1b).
         *
         * For 2), ambient declarations in .ts files must be namespaced, for the same collision reasons.
         * The exception is 2b), where in TypeScript, an unexported local "declare const x: string;"
         * creates a symbol that, when used locally, is emitted as just "x". That is, it behaves
         * like a variable declared in a 'declare global' block. Closure Compiler would fail the build if
         * there is no declaration for "x", so tsickle must generate a global external symbol, i.e.
         * without the namespace wrapper.
         */
        function getNamespaceForTopLevelDeclaration(declaration, namespace) {
            // Only use rootNamespace for top level symbols, any other namespacing (global names, nested
            // namespaces) is always kept.
            if (namespace.length !== 0)
                return namespace;
            // All names in a module (external) .d.ts file can only be accessed locally, so they always get
            // namespace prefixed.
            if (isDts && isExternalModule)
                return [rootNamespace];
            // Same for exported declarations in regular .ts files.
            if (transformer_util_1.hasModifierFlag(declaration, ts.ModifierFlags.Export))
                return [rootNamespace];
            // But local declarations in .ts files or .d.ts files (1b, 2b) are global, too.
            return [];
        }
        function visitor(node, namespace) {
            var e_8, _a, e_9, _b;
            if (node.parent === sourceFile) {
                namespace = getNamespaceForTopLevelDeclaration(node, namespace);
            }
            switch (node.kind) {
                case ts.SyntaxKind.ModuleDeclaration:
                    var decl = node;
                    switch (decl.name.kind) {
                        case ts.SyntaxKind.Identifier:
                            if (decl.flags & ts.NodeFlags.GlobalAugmentation) {
                                // E.g. "declare global { ... }".  Reset to the outer namespace.
                                namespace = [];
                            }
                            else {
                                // E.g. "declare namespace foo {"
                                var name_2 = transformer_util_1.getIdentifierText(decl.name);
                                if (isFirstValueDeclaration(decl)) {
                                    emit('/** @const */\n');
                                    writeVariableStatement(name_2, namespace, '{}');
                                }
                                namespace = namespace.concat(name_2);
                            }
                            if (decl.body)
                                visitor(decl.body, namespace);
                            break;
                        case ts.SyntaxKind.StringLiteral:
                            // E.g. "declare module 'foo' {" (note the quotes).
                            // We still want to emit externs for this module, but Closure doesn't provide a
                            // mechanism for module-scoped externs. Instead, we emit in a mangled namespace.
                            // The mangled namespace (after resolving files) matches the emit for an original module
                            // file, so effectively this augments any existing module.
                            var importName = decl.name.text;
                            var importedModuleName = googmodule_1.resolveModuleName({ host: moduleResolutionHost, options: options }, sourceFile.fileName, importName);
                            var mangled = moduleNameAsIdentifier(host, importedModuleName);
                            emit("// Derived from: declare module \"" + importName + "\"\n");
                            namespace = [mangled];
                            // Declare "mangled$name" if it's not declared already elsewhere.
                            if (isFirstValueDeclaration(decl)) {
                                emit('/** @const */\n');
                                writeVariableStatement(mangled, [], '{}');
                            }
                            // Declare the contents inside the "mangled$name".
                            if (decl.body)
                                visitor(decl.body, [mangled]);
                            break;
                        default:
                            errorUnimplementedKind(decl.name, 'externs generation of namespace');
                            break;
                    }
                    break;
                case ts.SyntaxKind.ModuleBlock:
                    var block = node;
                    try {
                        for (var _c = __values(block.statements), _d = _c.next(); !_d.done; _d = _c.next()) {
                            var stmt = _d.value;
                            visitor(stmt, namespace);
                        }
                    }
                    catch (e_8_1) { e_8 = { error: e_8_1 }; }
                    finally {
                        try {
                            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                        }
                        finally { if (e_8) throw e_8.error; }
                    }
                    break;
                case ts.SyntaxKind.ImportEqualsDeclaration:
                    var importEquals = node;
                    var localName = transformer_util_1.getIdentifierText(importEquals.name);
                    if (localName === 'ng') {
                        emit("\n/* Skipping problematic import ng = ...; */\n");
                        break;
                    }
                    if (importEquals.moduleReference.kind === ts.SyntaxKind.ExternalModuleReference) {
                        addImportAliases(importEquals);
                        break;
                    }
                    var qn = transformer_util_1.getEntityNameText(importEquals.moduleReference);
                    // @const so that Closure Compiler understands this is an alias.
                    if (namespace.length === 0)
                        emit('/** @const */\n');
                    writeVariableStatement(localName, namespace, qn);
                    break;
                case ts.SyntaxKind.ClassDeclaration:
                case ts.SyntaxKind.InterfaceDeclaration:
                    writeType(node, namespace);
                    break;
                case ts.SyntaxKind.FunctionDeclaration:
                    var fnDecl = node;
                    var name_3 = fnDecl.name;
                    if (!name_3) {
                        transformer_util_1.reportDiagnostic(diagnostics, fnDecl, 'anonymous function in externs');
                        break;
                    }
                    // Gather up all overloads of this function.
                    var sym = typeChecker.getSymbolAtLocation(name_3);
                    var decls = sym.declarations.filter(ts.isFunctionDeclaration);
                    // Only emit the first declaration of each overloaded function.
                    if (fnDecl !== decls[0])
                        break;
                    var params = emitFunctionType(decls);
                    writeFunction(name_3, params, namespace);
                    break;
                case ts.SyntaxKind.VariableStatement:
                    try {
                        for (var _e = __values(node.declarationList.declarations), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var decl_1 = _f.value;
                            writeVariableDeclaration(decl_1, namespace);
                        }
                    }
                    catch (e_9_1) { e_9 = { error: e_9_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_9) throw e_9.error; }
                    }
                    break;
                case ts.SyntaxKind.EnumDeclaration:
                    writeEnum(node, namespace);
                    break;
                case ts.SyntaxKind.TypeAliasDeclaration:
                    writeTypeAlias(node, namespace);
                    break;
                case ts.SyntaxKind.ImportDeclaration:
                    addImportAliases(node);
                    break;
                case ts.SyntaxKind.NamespaceExportDeclaration:
                case ts.SyntaxKind.ExportAssignment:
                    // Handled on the file level.
                    break;
                default:
                    var locationStr = namespace.join('.') || path.basename(node.getSourceFile().fileName);
                    emit("\n// TODO(tsickle): " + ts.SyntaxKind[node.kind] + " in " + locationStr + "\n");
                    break;
            }
        }
    }
    exports.generateExterns = generateExterns;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXh0ZXJucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9leHRlcm5zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFFSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0ErQ0c7SUFFSCwyQkFBNkI7SUFFN0IscURBQTJFO0lBQzNFLHlDQUFpQztJQUNqQyxtRUFBcUg7SUFDckgsNkVBQThEO0lBQzlELGlFQUEwSDtJQUMxSCwrREFBNkQ7SUFDN0QsMkNBQW1DO0lBRW5DOzs7T0FHRztJQUNILElBQU0seUJBQXlCLEdBQTBCO1FBQ3ZELFNBQVM7UUFDVCxRQUFRO1FBQ1IsUUFBUTtRQUNSLGdFQUFnRTtRQUNoRSx1RUFBdUU7UUFDdkUsa0VBQWtFO1FBQ2xFLHFFQUFxRTtRQUNyRSxtRUFBbUU7UUFDbkUsd0VBQXdFO1FBQ3hFLGdDQUFnQztRQUNoQyxrQkFBa0I7UUFDbEIsUUFBUTtRQUNSLG1CQUFtQjtLQUNwQixDQUFDO0lBR0Y7Ozs7Ozs7Ozs7T0FVRztJQUNILElBQU0sY0FBYyxHQUFHLDJHQUt0QixDQUFDO0lBRUY7OztPQUdHO0lBQ0gsNkJBQW9DLE9BQXFDOztRQUN2RSxJQUFJLFVBQVUsR0FBRyxjQUFjLENBQUM7O1lBQ2hDLEtBQXVCLElBQUEsS0FBQSxTQUFBLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUEsZ0JBQUEsNEJBQUU7Z0JBQXhDLElBQU0sUUFBUSxXQUFBO2dCQUNqQixVQUFVLElBQUkscUJBQW1CLFFBQVEsUUFBSyxDQUFDO2dCQUMvQyxVQUFVLElBQUksT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQ2pDOzs7Ozs7Ozs7UUFDRCxPQUFPLFVBQVUsQ0FBQztJQUNwQixDQUFDO0lBUEQsa0RBT0M7SUFFRDs7Ozs7Ozs7T0FRRztJQUNILGdD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LENBQUMsMEJBQTBCLENBQUM7Z0JBQzlDLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0I7b0JBQ2pDLDZCQUE2QjtvQkFDN0IsTUFBTTtnQkFDUjtvQkFDRSxJQUFNLFdBQVcsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDO29CQUN4RixJQUFJLENBQUMseUJBQXVCLEVBQUUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFPLFdBQVcsT0FBSSxDQUFDLENBQUM7b0JBQzVFLE1BQU07YUFDVDtRQUNILENBQUM7SUFDSCxDQUFDO0lBdmlCRCwwQ0F1aUJDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRXh0ZXJucyBjcmVhdGVzIENsb3N1cmUgQ29tcGlsZXIgXFxAZXh0ZXJucyBkZWZpbml0aW9ucyBmcm9tIHRoZVxuICogYW1iaWVudCBkZWNsYXJhdGlvbnMgaW4gYSBUeXBlU2NyaXB0IGZpbGUuXG4gKlxuICogRm9yIGV4YW1wbGUsIGEgZGVjbGFyZSBpbnRlcmZhY2UgRm9vIHsgYmFyOiBzdHJpbmc7IH0gV291bGQgZ2VuZXJhdGUgYSAvLi5cbiAqICAgXFxAZXh0ZXJucyAuLyAvLi4gXFxAcmVjb3JkIC4vIHZhciBGb28gPSBmdW5jdGlvbigpIHt9OyAvLi4gXFxAdHlwZSB7c3RyaW5nfVxuICogICAuLyBGb28ucHJvdG90eXBlLmJhcjtcbiAqXG4gKiBUaGUgZ2VuZXJhdGVkIGV4dGVybnMgaW5kaWNhdGUgdG8gQ2xvc3VyZSBDb21waWxlciB0aGF0IHN5bWJvbHMgYXJlIGV4dGVybmFsXG4gKiB0byB0aGUgb3B0aW1pemF0aW9uIHByb2Nlc3MsIGkuZS4gdGhleSBhcmUgcHJvdmlkZWQgYnkgb3V0c2lkZSBjb2RlLiBUaGF0XG4gKiBtb3N0IGltcG9ydGFudGx5IG1lYW5zIHRoZXkgbXVzdCBub3QgYmUgcmVuYW1lZCBvciByZW1vdmVkLlxuICpcbiAqIEEgbWFqb3IgZGlmZmljdWx0eSBoZXJlIGlzIHRoYXQgVHlwZVNjcmlwdCBzdXBwb3J0cyBtb2R1bGUtc2NvcGVkIGV4dGVybmFsXG4gKiBzeW1ib2xzOyBgLmQudHNgIGZpbGVzIGNhbiBjb250YWluIGBleHBvcnRgcyBhbmQgYGltcG9ydGAgb3RoZXIgZmlsZXMuXG4gKiBDbG9zdXJlIENvbXBpbGVyIGRvZXMgbm90IGhhdmUgc3VjaCBhIGNvbmNlcHQsIHNvIHRzaWNrbGUgbXVzdCBlbXVsYXRlIHRoZVxuICogYmVoYXZpb3VyLiBJdCBkb2VzIHNvIGJ5IGZvbGxvd2luZyB0aGlzIHNjaGVtZTpcbiAqXG4gKiAxLiBub24tbW9kdWxlIC5kLnRzIHByb2R1Y2VzIGdsb2JhbCBzeW1ib2xzXG4gKiAyLiBtb2R1bGUgLmQudHMgcHJvZHVjZSBzeW1ib2xzIG5hbWVzcGFjZWQgdG8gdGhlIG1vZHVsZSwgYnkgY3JlYXRpbmcgYVxuICogICAgbWFuZ2xlZCBuYW1lIG1hdGNoaW5nIHRoZSBjdXJyZW50IGZpbGUncyBwYXRoLiB0c2lja2xlIGV4cGVjdHMgb3V0c2lkZVxuICogICAgY29kZSAoZS5nLiBidWlsZCBzeXN0ZW0gaW50ZWdyYXRpb24gb3IgbWFudWFsbHkgd3JpdHRlbiBjb2RlKSB0byBjb250YWluIGFcbiAqICAgIGdvb2cubW9kdWxlL3Byb3ZpZGUgdGhhdCByZWZlcmVuY2VzIHRoZSBtYW5nbGVkIHBhdGguXG4gKiAzLiBkZWNsYXJhdGlvbnMgaW4gYC50c2AgZmlsZXMgcHJvZHVjZSB0eXBlcyB0aGF0IGNhbiBiZSBzZXBhcmF0ZWx5IGVtaXR0ZWRcbiAqICAgIGluIGUuZy4gYW4gYGV4dGVybnMuanNgLCB1c2luZyBgZ2V0R2VuZXJhdGVkRXh0ZXJuc2AgYmVsb3cuXG4gKiAgICAxLiBub24tZXhwb3J0ZWQgc3ltYm9scyBwcm9kdWNlIGdsb2JhbCB0eXBlcywgYmVjYXVzZSB0aGF0J3Mgd2hhdCB1c2Vyc1xuICogICAgICAgZXhwZWN0IGFuZCBpdCBtYXRjaGVzIFR5cGVTY3JpcHRzIGVtaXQsIHdoaWNoIGp1c3QgcmVmZXJlbmNlcyBgRm9vYCBmb3JcbiAqICAgICAgIGEgbG9jYWxseSBkZWNsYXJlZCBzeW1ib2wgYEZvb2AgaW4gYSBtb2R1bGUuIEFyZ3VhYmx5IHRoZXNlIHNob3VsZCBiZVxuICogICAgICAgd3JhcHBlZCBpbiBgZGVjbGFyZSBnbG9iYWwgeyAuLi4gfWAuXG4gKiAgICAyLiBleHBvcnRlZCBzeW1ib2xzIGFyZSBzY29wZWQgdG8gdGhlIGAudHNgIGZpbGUgYnkgcHJlZml4aW5nIHRoZW0gd2l0aCBhXG4gKiAgICAgICBtYW5nbGVkIG5hbWUuIEV4cG9ydGVkIHR5cGVzIGFyZSByZS1leHBvcnRlZCBmcm9tIHRoZSBKYXZhU2NyaXB0XG4gKiAgICAgICBgZ29vZy5tb2R1bGVgLCBhbGxvd2luZyBkb3duc3RyZWFtIGNvZGUgdG8gcmVmZXJlbmNlIHRoZW0uIFRoaXMgaGFzIHRoZVxuICogICAgICAgc2FtZSBwcm9ibGVtIHJlZ2FyZGluZyBhbWJpZW50IHZhbHVlcyBhcyBhYm92ZSwgaXQgaXMgdW5jbGVhciB3aGVyZSB0aGVcbiAqICAgICAgIHZhbHVlIHN5bWJvbCB3b3VsZCBiZSBkZWZpbmVkLCBzbyBmb3IgdGhlIHRpbWUgYmVpbmcgdGhpcyBpc1xuICogICAgICAgdW5zdXBwb3J0ZWQuXG4gKlxuICogVGhlIGVmZmVjdCBvZiB0aGlzIGlzIHRoYXQ6XG4gKiAtIHN5bWJvbHMgaW4gYSBtb2R1bGUgKGkuZS4gbm90IGdsb2JhbHMpIGFyZSBnZW5lcmFsbHkgc2NvcGVkIHRvIHRoZSBsb2NhbFxuICogICBtb2R1bGUgdXNpbmcgYSBtYW5nbGVkIG5hbWUsIHByZXZlbnRpbmcgc3ltYm9sIGNvbGxpc2lvbnMgb24gdGhlIENsb3N1cmVcbiAqICAgc2lkZS5cbiAqIC0gaW1wb3J0aW5nIGNvZGUgY2FuIHVuY29uZGl0aW9uYWxseSByZWZlciB0byBhbmQgaW1wb3J0IGFueSBzeW1ib2wgZGVmaW5lZFxuICogICBpbiBhIG1vZHVsZSBgWGAgYXMgYHBhdGgudG8ubW9kdWxlLlhgLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIGRlZmluaW5nXG4gKiAgIGxvY2F0aW9uIGlzIGEgYC5kLnRzYCBmaWxlIG9yIGEgYC50c2AgZmlsZSwgYW5kIHJlZ2FyZGxlc3Mgd2hldGhlciB0aGVcbiAqICAgc3ltYm9sIGlzIGFtYmllbnQgKGFzc3VtaW5nIHRoZXJlJ3MgYW4gYXBwcm9wcmlhdGUgc2hpbSkuXG4gKiAtIGlmIHRoZXJlIGlzIGEgc2hpbSBwcmVzZW50LCB0c2lja2xlIGF2b2lkcyBlbWl0dGluZyB0aGUgQ2xvc3VyZSBuYW1lc3BhY2VcbiAqICAgaXRzZWxmLCBleHBlY3RpbmcgdGhlIHNoaW0gdG8gcHJvdmlkZSB0aGUgbmFtZXNwYWNlIGFuZCBpbml0aWFsaXplIGl0IHRvIGFcbiAqICAgc3ltYm9sIHRoYXQgcHJvdmlkZXMgdGhlIHJpZ2h0IHZhbHVlIGF0IHJ1bnRpbWUgKGkuZS4gdGhlIGltcGxlbWVudGF0aW9uIG9mXG4gKiAgIHdoYXRldmVyIHRoaXJkIHBhcnR5IGxpYnJhcnkgdGhlIC5kLnRzIGRlc2NyaWJlcykuXG4gKi9cblxuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcblxuaW1wb3J0IHtleHRyYWN0R29vZ05hbWVzcGFjZUltcG9ydCwgcmVzb2x2ZU1vZHVsZU5hbWV9IGZyb20gJy4vZ29vZ21vZHVsZSc7XG5pbXBvcnQgKiBhcyBqc2RvYyBmcm9tICcuL2pzZG9jJztcbmltcG9ydCB7QW5ub3RhdG9ySG9zdCwgZXNjYXBlRm9yQ29tbWVudCwgbWF5YmVBZGRIZXJpdGFnZUNsYXVzZXMsIG1heWJlQWRkVGVtcGxhdGVDbGF1c2V9IGZyb20gJy4vanNkb2NfdHJhbnNmb3JtZXInO1xuaW1wb3J0IHtNb2R1bGVUeXBlVHJhbnNsYXRvcn0gZnJvbSAnLi9tb2R1bGVfdHlwZV90cmFuc2xhdG9yJztcbmltcG9ydCB7Z2V0RW50aXR5TmFtZVRleHQsIGdldElkZW50aWZpZXJUZXh0LCBoYXNNb2RpZmllckZsYWcsIGlzRHRzRmlsZU5hbWUsIHJlcG9ydERpYWdub3N0aWN9IGZyb20gJy4vdHJhbnNmb3JtZXJfdXRpbCc7XG5pbXBvcnQge2lzVmFsaWRDbG9zdXJlUHJvcGVydHlOYW1lfSBmcm9tICcuL3R5cGVfdHJhbnNsYXRvcic7XG5pbXBvcnQgKiBhcyB0cyBmcm9tICcuL3R5cGVzY3JpcHQnO1xuXG4vKipcbiAqIFN5bWJvbHMgdGhhdCBhcmUgYWxyZWFkeSBkZWNsYXJlZCBhcyBleHRlcm5zIGluIENsb3N1cmUsIHRoYXQgc2hvdWxkXG4gKiBiZSBhdm9pZGVkIGJ5IHRzaWNrbGUncyBcImRlY2xhcmUgLi4uXCIgPT4gZXh0ZXJucy5qcyBjb252ZXJzaW9uLlxuICovXG5jb25zdCBDTE9TVVJFX0VYVEVSTlNfQkxBQ0tMSVNUOiBSZWFkb25seUFycmF5PHN0cmluZz4gPSBbXG4gICdleHBvcnRzJyxcbiAgJ2dsb2JhbCcsXG4gICdtb2R1bGUnLFxuICAvLyBFcnJvckNvbnN0cnVjdG9yIGlzIHRoZSBpbnRlcmZhY2Ugb2YgdGhlIEVycm9yIG9iamVjdCBpdHNlbGYuXG4gIC8vIHRzaWNrbGUgZGV0ZWN0cyB0aGF0IHRoaXMgaXMgcGFydCBvZiB0aGUgVHlwZVNjcmlwdCBzdGFuZGFyZCBsaWJyYXJ5XG4gIC8vIGFuZCBhc3N1bWVzIGl0J3MgcGFydCBvZiB0aGUgQ2xvc3VyZSBzdGFuZGFyZCBsaWJyYXJ5LCBidXQgdGhpc1xuICAvLyBhc3N1bXB0aW9uIGlzIHdyb25nIGZvciBFcnJvckNvbnN0cnVjdG9yLiAgVG8gcHJvcGVybHkgaGFuZGxlIHRoaXNcbiAgLy8gd2UnZCBzb21laG93IG5lZWQgdG8gbWFwIG1ldGhvZHMgZGVmaW5lZCBvbiB0aGUgRXJyb3JDb25zdHJ1Y3RvclxuICAvLyBpbnRlcmZhY2UgaW50byBwcm9wZXJ0aWVzIG9uIENsb3N1cmUncyBFcnJvciBvYmplY3QsIGJ1dCBmb3Igbm93IGl0J3NcbiAgLy8gc2ltcGxlciB0byBqdXN0IGJsYWNrbGlzdCBpdC5cbiAgJ0Vycm9yQ29uc3RydWN0b3InLFxuICAnU3ltYm9sJyxcbiAgJ1dvcmtlckdsb2JhbFNjb3BlJyxcbl07XG5cblxuLyoqXG4gKiBUaGUgaGVhZGVyIHRvIGJlIHVzZWQgaW4gZ2VuZXJhdGVkIGV4dGVybnMuICBUaGlzIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgb3V0cHV0IG9mXG4gKiBnZW5lcmF0ZUV4dGVybnMoKSBiZWNhdXNlIGdlbmVyYXRlRXh0ZXJucygpIHdvcmtzIG9uZSBmaWxlIGF0IGEgdGltZSwgYW5kIHR5cGljYWxseSB5b3UgY3JlYXRlXG4gKiBvbmUgZXh0ZXJucyBmaWxlIGZyb20gdGhlIGVudGlyZSBjb21waWxhdGlvbiB1bml0LlxuICpcbiAqIFN1cHByZXNzaW9uczpcbiAqIC0gZHVwbGljYXRlOiBiZWNhdXNlIGV4dGVybnMgbWlnaHQgZHVwbGljYXRlIHJlLW9wZW5lZCBkZWZpbml0aW9ucyBmcm9tIG90aGVyIEpTIGZpbGVzLlxuICogLSBjaGVja1R5cGVzOiBDbG9zdXJlJ3MgdHlwZSBzeXN0ZW0gZG9lcyBub3QgbWF0Y2ggVFMnLlxuICogLSB1bmRlZmluZWROYW1lczogY29kZSBiZWxvdyB0cmllcyB0byBiZSBjYXJlZnVsIG5vdCB0byBvdmVyd3JpdGUgcHJldmlvdXNseSBlbWl0dGVkIGRlZmluaXRpb25zLFxuICogICBidXQgb24gdGhlIGZsaXAgc2lkZSBtaWdodCBhY2NpZGVudGFsbHkgbWlzcyBkZWZpbml0aW9ucy5cbiAqL1xuY29uc3QgRVhURVJOU19IRUFERVIgPSBgLyoqXG4gKiBAZXh0ZXJuc1xuICogQHN1cHByZXNzIHtkdXBsaWNhdGUsY2hlY2tUeXBlc31cbiAqL1xuLy8gTk9URTogZ2VuZXJhdGVkIGJ5IHRzaWNrbGUsIGRvIG5vdCBlZGl0LlxuYDtcblxuLyoqXG4gKiBDb25jYXRlbmF0ZSBhbGwgZ2VuZXJhdGVkIGV4dGVybnMgZGVmaW5pdGlvbnMgdG9nZXRoZXIgaW50byBhIHN0cmluZywgaW5jbHVkaW5nIGEgZmlsZSBjb21tZW50XG4gKiBoZWFkZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRHZW5lcmF0ZWRFeHRlcm5zKGV4dGVybnM6IHtbZmlsZU5hbWU6IHN0cmluZ106IHN0cmluZ30pOiBzdHJpbmcge1xuICBsZXQgYWxsRXh0ZXJucyA9IEVYVEVSTlNfSEVBREVSO1xuICBmb3IgKGNvbnN0IGZpbGVOYW1lIG9mIE9iamVjdC5rZXlzKGV4dGVybnMpKSB7XG4gICAgYWxsRXh0ZXJucyArPSBgLy8gZXh0ZXJucyBmcm9tICR7ZmlsZU5hbWV9OlxcbmA7XG4gICAgYWxsRXh0ZXJucyArPSBleHRlcm5zW2ZpbGVOYW1lXTtcbiAgfVxuICByZXR1cm4gYWxsRXh0ZXJucztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbWFuZ2xlZCB2ZXJzaW9uIG9mIHRoZSBtb2R1bGUgbmFtZSAocmVzb2x2ZWQgZmlsZSBuYW1lKSBmb3Igc291cmNlIGZpbGUuXG4gKlxuICogVGhlIG1hbmdsZWQgbmFtZSBpcyBzYWZlIHRvIHVzZSBhcyBhIEphdmFTY3JpcHQgaWRlbnRpZmllci4gSXQgaXMgdXNlZCBhcyBhIGdsb2JhbGx5IHVuaXF1ZVxuICogcHJlZml4IHRvIHNjb3BlIHN5bWJvbHMgaW4gZXh0ZXJucyBmaWxlIChzZWUgY29kZSBiZWxvdykuXG4gKlxuICogQHBhcmFtIGNvbnRleHRGaWxlTmFtZSBpZiBnaXZlbiBpcyB1c2VkIGFzIHRoZSBjb250ZXh0IGZpbGUgcGF0aCB0byByZXNvbHZlIHRoZSBzb3VyY2UgZmlsZSdzXG4gKiAgICAgbmFtZSBhZ2FpbnN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbW9kdWxlTmFtZUFzSWRlbnRpZmllcihcbiAgICBob3N0OiBBbm5vdGF0b3JIb3N0LCBmaWxlTmFtZTogc3RyaW5nLCBjb250ZXh0RmlsZU5hbWU/OiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVNb2R1bGVOYW1lKGhvc3QsIGNvbnRleHRGaWxlTmFtZSB8fCAnJywgZmlsZU5hbWUpO1xuICByZXR1cm4gaG9zdC5wYXRoVG9Nb2R1bGVOYW1lKCcnLCByZXNvbHZlZCkucmVwbGFjZSgvXFwuL2csICckJyk7XG59XG5cbi8qKlxuICogaXNJbkdsb2JhbEF1Z21lbnRhdGlvbiByZXR1cm5zIHRydWUgaWYgZGVjbGFyYXRpb24gaXMgdGhlIGltbWVkaWF0ZSBjaGlsZCBvZiBhICdkZWNsYXJlIGdsb2JhbCdcbiAqIGJsb2NrLlxuICovXG5mdW5jdGlvbiBpc0luR2xvYmFsQXVnbWVudGF0aW9uKGRlY2xhcmF0aW9uOiB0cy5EZWNsYXJhdGlvbik6IGJvb2xlYW4ge1xuICAvLyBkZWNsYXJlIGdsb2JhbCB7IC4uLiB9IGNyZWF0ZXMgYSBNb2R1bGVEZWNsYXJhdGlvbiBjb250YWluaW5nIGEgTW9kdWxlQmxvY2sgY29udGFpbmluZyB0aGVcbiAgLy8gZGVjbGFyYXRpb24sIHdpdGggdGhlIE1vZHVsZURlY2xhcmF0aW9uIGhhdmluZyB0aGUgR2xvYmFsQXVnbWVudGF0aW9uIGZsYWcgc2V0LlxuICBpZiAoIWRlY2xhcmF0aW9uLnBhcmVudCB8fCAhZGVjbGFyYXRpb24ucGFyZW50LnBhcmVudCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gKGRlY2xhcmF0aW9uLnBhcmVudC5wYXJlbnQuZmxhZ3MgJiB0cy5Ob2RlRmxhZ3MuR2xvYmFsQXVnbWVudGF0aW9uKSAhPT0gMDtcbn1cblxuLyoqXG4gKiBnZW5lcmF0ZUV4dGVybnMgZ2VuZXJhdGVzIGV4dGVybiBkZWZpbml0aW9ucyBmb3IgYWxsIGFtYmllbnQgZGVjbGFyYXRpb25zIGluIHRoZSBnaXZlbiBzb3VyY2VcbiAqIGZpbGUuIEl0IHJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIENsb3N1cmUgSmF2YVNjcmlwdCwgbm90IGluY2x1ZGluZyB0aGUgaW5pdGlhbFxuICogY29tbWVudCB3aXRoIFxcQGZpbGVvdmVydmlldyBhbmQgXFxAZXh0ZXJucyAoc2VlIGFib3ZlIGZvciB0aGF0KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlRXh0ZXJucyhcbiAgICB0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIsIHNvdXJjZUZpbGU6IHRzLlNvdXJjZUZpbGUsIGhvc3Q6IEFubm90YXRvckhvc3QsXG4gICAgbW9kdWxlUmVzb2x1dGlvbkhvc3Q6IHRzLk1vZHVsZVJlc29sdXRpb25Ib3N0LFxuICAgIG9wdGlvbnM6IHRzLkNvbXBpbGVyT3B0aW9ucyk6IHtvdXRwdXQ6IHN0cmluZywgZGlhZ25vc3RpY3M6IHRzLkRpYWdub3N0aWNbXX0ge1xuICBsZXQgb3V0cHV0ID0gJyc7XG4gIGNvbnN0IGRpYWdub3N0aWNzOiB0cy5EaWFnbm9zdGljW10gPSBbXTtcbiAgY29uc3QgaXNEdHMgPSBpc0R0c0ZpbGVOYW1lKHNvdXJjZUZpbGUuZmlsZU5hbWUpO1xuICBjb25zdCBpc0V4dGVybmFsTW9kdWxlID0gdHMuaXNFeHRlcm5hbE1vZHVsZShzb3VyY2VGaWxlKTtcblxuICBjb25zdCBtdHQgPVxuICAgICAgbmV3IE1vZHVsZVR5cGVUcmFuc2xhdG9yKHNvdXJjZUZpbGUsIHR5cGVDaGVja2VyLCBob3N0LCBkaWFnbm9zdGljcywgLyppc0ZvckV4dGVybnMqLyB0cnVlKTtcblxuICBsZXQgcm9vdE5hbWVzcGFjZSA9ICcnO1xuICBpZiAoaXNFeHRlcm5hbE1vZHVsZSkge1xuICAgIC8vIC5kLnRzIGZpbGVzIHRoYXQgYXJlIG1vZHVsZXMgZG8gbm90IGRlY2xhcmUgZ2xvYmFsIHN5bWJvbHMgLSB0aGVpciBzeW1ib2xzIG11c3QgYmUgZXhwbGljaXRseVxuICAgIC8vIGltcG9ydGVkIHRvIGJlIHVzZWQuIEhvd2V2ZXIgQ2xvc3VyZSBDb21waWxlciBoYXMgbm8gY29uY2VwdCBvZiBleHRlcm5zIHRoYXQgYXJlIG1vZHVsZXMgYW5kXG4gICAgLy8gcmVxdWlyZSBpbXBvcnRzLiBUaGlzIGNvZGUgbWFuZ2xlcyB0aGUgc3ltYm9sIG5hbWVzIGJ5IHdyYXBwaW5nIHRoZW0gaW4gYSB0b3AgbGV2ZWwgdmFyaWFibGVcbiAgICAvLyB0aGF0J3MgdW5pcXVlIHRvIHRoaXMgZmlsZS4gVGhhdCBhbGxvd3MgZW1pdHRpbmcgdGhlbSBmb3IgQ2xvc3VyZSBhcyBnbG9iYWwgc3ltYm9scyB3aGlsZVxuICAgIC8vIGF2b2lkaW5nIGNvbGxpc2lvbnMuIFRoaXMgaXMgbmVjZXNzYXJ5IGFzIHN5bWJvbHMgbG9jYWwgdG8gdGhpcyBtb2R1bGUgY2FuIChhbmQgd2lsbCB2ZXJ5XG4gICAgLy8gY29tbW9ubHkpIGNvbmZsaWN0IHdpdGggdGhlIG5hbWVzcGFjZSB1c2VkIGluIFwiZXhwb3J0IGFzIG5hbWVzcGFjZVwiLCBlLmcuIFwiYW5ndWxhclwiLCBhbmQgYWxzb1xuICAgIC8vIHRvIGF2b2lkIHVzZXJzIGFjY2lkZW50YWxseSB1c2luZyB0aGVzZSBzeW1ib2xzIGluIC5qcyBmaWxlcyAoYW5kIG1vcmUgY29sbGlzaW9ucykuIFRoZVxuICAgIC8vIHN5bWJvbHMgdGhhdCBhcmUgXCJoaWRkZW5cIiBsaWtlIHRoYXQgY2FuIGJlIG1hZGUgYWNjZXNzaWJsZSB0aHJvdWdoIGFuIFwiZXhwb3J0IGFzIG5hbWVzcGFjZVwiXG4gICAgLy8gZGVjbGFyYXRpb24gKHNlZSBiZWxvdykuXG4gICAgcm9vdE5hbWVzcGFjZSA9IG1vZHVsZU5hbWVBc0lkZW50aWZpZXIoaG9zdCwgc291cmNlRmlsZS5maWxlTmFtZSk7XG4gIH1cblxuICBmb3IgKGNvbnN0IHN0bXQgb2Ygc291cmNlRmlsZS5zdGF0ZW1lbnRzKSB7XG4gICAgaWYgKCFpc0R0cyAmJiAhaGFzTW9kaWZpZXJGbGFnKHN0bXQsIHRzLk1vZGlmaWVyRmxhZ3MuQW1iaWVudCkpIGNvbnRpbnVlO1xuICAgIHZpc2l0b3Ioc3RtdCwgW10pO1xuICB9XG5cbiAgaWYgKG91dHB1dCAmJiBpc0V4dGVybmFsTW9kdWxlKSB7XG4gICAgLy8gSWYgdHNpY2tsZSBnZW5lcmF0ZWQgYW55IGV4dGVybnMgYW5kIHRoaXMgaXMgYW4gZXh0ZXJuYWwgbW9kdWxlLCBwcmVwZW5kIHRoZSBuYW1lc3BhY2VcbiAgICAvLyBkZWNsYXJhdGlvbiBmb3IgaXQuXG4gICAgb3V0cHV0ID0gYC8qKiBAY29uc3QgKi9cXG52YXIgJHtyb290TmFtZXNwYWNlfSA9IHt9O1xcbmAgKyBvdXRwdXQ7XG5cbiAgICAvLyBUaGVyZSBjYW4gb25seSBiZSBvbmUgZXhwb3J0ID0uXG4gICAgY29uc3QgZXhwb3J0QXNzaWdubWVudCA9IHNvdXJjZUZpbGUuc3RhdGVtZW50cy5maW5kKHRzLmlzRXhwb3J0QXNzaWdubWVudCk7XG4gICAgbGV0IGV4cG9ydGVkTmFtZXNwYWNlID0gcm9vdE5hbWVzcGFjZTtcbiAgICBpZiAoZXhwb3J0QXNzaWdubWVudCAmJiBleHBvcnRBc3NpZ25tZW50LmlzRXhwb3J0RXF1YWxzKSB7XG4gICAgICBpZiAodHMuaXNJZGVudGlmaWVyKGV4cG9ydEFzc2lnbm1lbnQuZXhwcmVzc2lvbikgfHxcbiAgICAgICAgICB0cy5pc1F1YWxpZmllZE5hbWUoZXhwb3J0QXNzaWdubWVudC5leHByZXNzaW9uKSkge1xuICAgICAgICAvLyBFLmcuIGV4cG9ydCA9IHNvbWVOYW1lO1xuICAgICAgICAvLyBJZiBzb21lTmFtZSBpcyBcImRlY2xhcmUgZ2xvYmFsIHsgbmFtZXNwYWNlIHNvbWVOYW1lIHsuLi59IH1cIiwgdHNpY2tsZSBtdXN0IG5vdCBxdWFsaWZ5XG4gICAgICAgIC8vIGFjY2VzcyB0byBpdCB3aXRoIG1vZHVsZSBuYW1lc3BhY2UgYXMgaXQgaXMgZW1pdHRlZCBpbiB0aGUgZ2xvYmFsIG5hbWVzcGFjZS5cbiAgICAgICAgY29uc3Qgc3ltYm9sID0gdHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihleHBvcnRBc3NpZ25tZW50LmV4cHJlc3Npb24pO1xuICAgICAgICBjb25zdCBpc0dsb2JhbFN5bWJvbCA9IHN5bWJvbCAmJiBzeW1ib2wuZGVjbGFyYXRpb25zICYmXG4gICAgICAgICAgICBzeW1ib2wuZGVjbGFyYXRpb25zLnNvbWUoZCA9PiBpc0luR2xvYmFsQXVnbWVudGF0aW9uKGQpKTtcbiAgICAgICAgY29uc3QgZW50aXR5TmFtZSA9IGdldEVudGl0eU5hbWVUZXh0KGV4cG9ydEFzc2lnbm1lbnQuZXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChpc0dsb2JhbFN5bWJvbCkge1xuICAgICAgICAgIGV4cG9ydGVkTmFtZXNwYWNlID0gZW50aXR5TmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHBvcnRlZE5hbWVzcGFjZSA9IHJvb3ROYW1lc3BhY2UgKyAnLicgKyBlbnRpdHlOYW1lO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXBvcnREaWFnbm9zdGljKFxuICAgICAgICAgICAgZGlhZ25vc3RpY3MsIGV4cG9ydEFzc2lnbm1lbnQuZXhwcmVzc2lvbixcbiAgICAgICAgICAgIGBleHBvcnQgPSBleHByZXNzaW9uIG11c3QgYmUgYSBxdWFsaWZpZWQgbmFtZSwgZ290ICR7XG4gICAgICAgICAgICAgICAgdHMuU3ludGF4S2luZFtleHBvcnRBc3NpZ25tZW50LmV4cHJlc3Npb24ua2luZF19LmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0R0cyAmJiBob3N0LnByb3ZpZGVFeHRlcm5hbE1vZHVsZUR0c05hbWVzcGFjZSkge1xuICAgICAgLy8gSW4gYSBub24tc2hpbW1lZCBtb2R1bGUsIGNyZWF0ZSBhIGdsb2JhbCBuYW1lc3BhY2UuIFRoaXMgZXhpc3RzIHB1cmVseSBmb3IgYmFja3dhcmRzXG4gICAgICAvLyBjb21wYXRpYmxpdHksIGluIHRoZSBtZWRpdW0gdGVybSBhbGwgY29kZSB1c2luZyB0c2lja2xlIHNob3VsZCBhbHdheXMgdXNlIGBnb29nLm1vZHVsZWBzLFxuICAgICAgLy8gc28gZ2xvYmFsIG5hbWVzIHNob3VsZCBub3QgYmUgbmVjY2Vzc2FyeS5cbiAgICAgIGZvciAoY29uc3QgbnNFeHBvcnQgb2Ygc291cmNlRmlsZS5zdGF0ZW1lbnRzLmZpbHRlcih0cy5pc05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uKSkge1xuICAgICAgICBjb25zdCBuYW1lc3BhY2VOYW1lID0gZ2V0SWRlbnRpZmllclRleHQobnNFeHBvcnQubmFtZSk7XG4gICAgICAgIGVtaXQoYC8vIGV4cG9ydCBhcyBuYW1lc3BhY2UgJHtuYW1lc3BhY2VOYW1lfVxcbmApO1xuICAgICAgICB3cml0ZVZhcmlhYmxlU3RhdGVtZW50KG5hbWVzcGFjZU5hbWUsIFtdLCBleHBvcnRlZE5hbWVzcGFjZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtvdXRwdXQsIGRpYWdub3N0aWNzfTtcblxuICBmdW5jdGlvbiBlbWl0KHN0cjogc3RyaW5nKSB7XG4gICAgb3V0cHV0ICs9IHN0cjtcbiAgfVxuXG4gIC8qKlxuICAgKiBpc0ZpcnN0RGVjbGFyYXRpb24gcmV0dXJucyB0cnVlIGlmIGRlY2wgaXMgdGhlIGZpcnN0IGRlY2xhcmF0aW9uXG4gICAqIG9mIGl0cyBzeW1ib2wuICBFLmcuIGltYWdpbmVcbiAgICogICBpbnRlcmZhY2UgRm9vIHsgeDogbnVtYmVyOyB9XG4gICAqICAgaW50ZXJmYWNlIEZvbyB7IHk6IG51bWJlcjsgfVxuICAgKiB3ZSBvbmx5IHdhbnQgdG8gZW1pdCB0aGUgXCJcXEByZWNvcmRcIiBmb3IgRm9vIG9uIHRoZSBmaXJzdCBvbmUuXG4gICAqXG4gICAqIFRoZSBleGNlcHRpb24gYXJlIHZhcmlhYmxlIGRlY2xhcmF0aW9ucywgd2hpY2ggLSBpbiBleHRlcm5zIC0gZG8gbm90IGFzc2lnbiBhIHZhbHVlOlxuICAgKiAgIC8uLiBcXEB0eXBlIHsuLi59IC4vXG4gICAqICAgdmFyIHNvbWVWYXJpYWJsZTtcbiAgICogICAvLi4gXFxAdHlwZSB7Li4ufSAuL1xuICAgKiAgIHNvbWVOYW1lc3BhY2Uuc29tZVZhcmlhYmxlO1xuICAgKiBJZiBhIGxhdGVyIGRlY2xhcmF0aW9uIHdhbnRzIHRvIGFkZCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb24gc29tZVZhcmlhYmxlLCB0c2lja2xlIG11c3Qgc3RpbGxcbiAgICogZW1pdCBhbiBhc3NpZ25tZW50IGludG8gdGhlIG9iamVjdCwgYXMgaXQncyBvdGhlcndpc2UgYWJzZW50LlxuICAgKi9cbiAgZnVuY3Rpb24gaXNGaXJzdFZhbHVlRGVjbGFyYXRpb24oZGVjbDogdHMuRGVjbGFyYXRpb25TdGF0ZW1lbnQpOiBib29sZWFuIHtcbiAgICBpZiAoIWRlY2wubmFtZSkgcmV0dXJuIHRydWU7XG4gICAgY29uc3Qgc3ltID0gdHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihkZWNsLm5hbWUpITtcbiAgICBpZiAoIXN5bS5kZWNsYXJhdGlvbnMgfHwgc3ltLmRlY2xhcmF0aW9ucy5sZW5ndGggPCAyKSByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBlYXJsaWVyRGVjbHMgPSBzeW0uZGVjbGFyYXRpb25zLnNsaWNlKDAsIHN5bS5kZWNsYXJhdGlvbnMuaW5kZXhPZihkZWNsKSk7XG4gICAgLy8gRWl0aGVyIHRoZXJlIGFyZSBubyBlYXJsaWVyIGRlY2xhcmF0aW9ucywgb3IgYWxsIG9mIHRoZW0gYXJlIHZhcmlhYmxlcyAoc2VlIGFib3ZlKS4gdHNpY2tsZVxuICAgIC8vIGVtaXRzIGEgdmFsdWUgZm9yIGFsbCBvdGhlciBkZWNsYXJhdGlvbiBraW5kcyAoZnVuY3Rpb24gZm9yIGZ1bmN0aW9ucywgY2xhc3NlcywgaW50ZXJmYWNlcyxcbiAgICAvLyB7fSBvYmplY3QgZm9yIG5hbWVzcGFjZXMpLlxuICAgIHJldHVybiBlYXJsaWVyRGVjbHMubGVuZ3RoID09PSAwIHx8IGVhcmxpZXJEZWNscy5ldmVyeSh0cy5pc1ZhcmlhYmxlRGVjbGFyYXRpb24pO1xuICB9XG5cbiAgLyoqIFdyaXRlcyB0aGUgYWN0dWFsIHZhcmlhYmxlIHN0YXRlbWVudCBvZiBhIENsb3N1cmUgdmFyaWFibGUgZGVjbGFyYXRpb24uICovXG4gIGZ1bmN0aW9uIHdyaXRlVmFyaWFibGVTdGF0ZW1lbnQobmFtZTogc3RyaW5nLCBuYW1lc3BhY2U6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPiwgdmFsdWU/OiBzdHJpbmcpIHtcbiAgICBjb25zdCBxdWFsaWZpZWROYW1lID0gbmFtZXNwYWNlLmNvbmNhdChbbmFtZV0pLmpvaW4oJy4nKTtcbiAgICBpZiAobmFtZXNwYWNlLmxlbmd0aCA9PT0gMCkgZW1pdChgdmFyIGApO1xuICAgIGVtaXQocXVhbGlmaWVkTmFtZSk7XG4gICAgaWYgKHZhbHVlKSBlbWl0KGAgPSAke3ZhbHVlfWApO1xuICAgIGVtaXQoJztcXG4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZXMgYSBDbG9zdXJlIHZhcmlhYmxlIGRlY2xhcmF0aW9uLCBpLmUuIHRoZSB2YXJpYWJsZSBzdGF0ZW1lbnQgd2l0aCBhIGxlYWRpbmcgSlNEb2NcbiAgICogY29tbWVudCBtYWtpbmcgaXQgYSBkZWNsYXJhdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIHdyaXRlVmFyaWFibGVEZWNsYXJhdGlvbihcbiAgICAgIGRlY2w6IHRzLlZhcmlhYmxlRGVjbGFyYXRpb24sIG5hbWVzcGFjZTogUmVhZG9ubHlBcnJheTxzdHJpbmc+KSB7XG4gICAgaWYgKGRlY2wubmFtZS5raW5kID09PSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXIpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBnZXRJZGVudGlmaWVyVGV4dChkZWNsLm5hbWUgYXMgdHMuSWRlbnRpZmllcik7XG4gICAgICBpZiAoQ0xPU1VSRV9FWFRFUk5TX0JMQUNLTElTVC5pbmRleE9mKG5hbWUpID49IDApIHJldHVybjtcbiAgICAgIGVtaXQoanNkb2MudG9TdHJpbmcoW3t0YWdOYW1lOiAndHlwZScsIHR5cGU6IG10dC50eXBlVG9DbG9zdXJlKGRlY2wpfV0pKTtcbiAgICAgIGVtaXQoJ1xcbicpO1xuICAgICAgd3JpdGVWYXJpYWJsZVN0YXRlbWVudChuYW1lLCBuYW1lc3BhY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvclVuaW1wbGVtZW50ZWRLaW5kKGRlY2wubmFtZSwgJ2V4dGVybnMgZm9yIHZhcmlhYmxlJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGEgSlNEb2MgZGVjbGFyYXRpb24gdGhhdCBtZXJnZXMgdGhlIHNpZ25hdHVyZXMgb2YgdGhlIGdpdmVuIGZ1bmN0aW9uIGRlY2xhcmF0aW9uIChmb3JcbiAgICogb3ZlcmxvYWRzKSwgYW5kIHJldHVybnMgdGhlIHBhcmFtZXRlciBuYW1lcyBjaG9zZW4uXG4gICAqL1xuICBmdW5jdGlvbiBlbWl0RnVuY3Rpb25UeXBlKGRlY2xzOiB0cy5GdW5jdGlvbkxpa2VEZWNsYXJhdGlvbltdLCBleHRyYVRhZ3M6IGpzZG9jLlRhZ1tdID0gW10pIHtcbiAgICBjb25zdCBbdGFncywgcGFyYW1OYW1lc10gPSBtdHQuZ2V0RnVuY3Rpb25UeXBlSlNEb2MoZGVjbHMsIGV4dHJhVGFncyk7XG4gICAgZW1pdCgnXFxuJyk7XG4gICAgZW1pdChqc2RvYy50b1N0cmluZyh0YWdzKSk7XG4gICAgcmV0dXJuIHBhcmFtTmFtZXM7XG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZUZ1bmN0aW9uKG5hbWU6IHRzLk5vZGUsIHBhcmFtczogc3RyaW5nW10sIG5hbWVzcGFjZTogUmVhZG9ubHlBcnJheTxzdHJpbmc+KSB7XG4gICAgY29uc3QgcGFyYW1zU3RyID0gcGFyYW1zLmpvaW4oJywgJyk7XG4gICAgaWYgKG5hbWVzcGFjZS5sZW5ndGggPiAwKSB7XG4gICAgICBsZXQgZnFuID0gbmFtZXNwYWNlLmpvaW4oJy4nKTtcbiAgICAgIGlmIChuYW1lLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuSWRlbnRpZmllcikge1xuICAgICAgICBmcW4gKz0gJy4nOyAgLy8gY29tcHV0ZWQgbmFtZXMgaW5jbHVkZSBbIF0gaW4gdGhlaXIgZ2V0VGV4dCgpIHJlcHJlc2VudGF0aW9uLlxuICAgICAgfVxuICAgICAgZnFuICs9IG5hbWUuZ2V0VGV4dCgpO1xuICAgICAgZW1pdChgJHtmcW59ID0gZnVuY3Rpb24oJHtwYXJhbXNTdHJ9KSB7fTtcXG5gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5hbWUua2luZCAhPT0gdHMuU3ludGF4S2luZC5JZGVudGlmaWVyKSB7XG4gICAgICAgIHJlcG9ydERpYWdub3N0aWMoZGlhZ25vc3RpY3MsIG5hbWUsICdOb24tbmFtZXNwYWNlZCBjb21wdXRlZCBuYW1lIGluIGV4dGVybnMnKTtcbiAgICAgIH1cbiAgICAgIGVtaXQoYGZ1bmN0aW9uICR7bmFtZS5nZXRUZXh0KCl9KCR7cGFyYW1zU3RyfSkge31cXG5gKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZUVudW0oZGVjbDogdHMuRW51bURlY2xhcmF0aW9uLCBuYW1lc3BhY2U6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPikge1xuICAgIGNvbnN0IG5hbWUgPSBnZXRJZGVudGlmaWVyVGV4dChkZWNsLm5hbWUpO1xuICAgIGVtaXQoJ1xcbi8qKiBAY29uc3QgKi9cXG4nKTtcbiAgICB3cml0ZVZhcmlhYmxlU3RhdGVtZW50KG5hbWUsIG5hbWVzcGFjZSwgJ3t9Jyk7XG4gICAgbmFtZXNwYWNlID0gbmFtZXNwYWNlLmNvbmNhdChbbmFtZV0pO1xuICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIGRlY2wubWVtYmVycykge1xuICAgICAgbGV0IG1lbWJlck5hbWU6IHN0cmluZ3x1bmRlZmluZWQ7XG4gICAgICBzd2l0Y2ggKG1lbWJlci5uYW1lLmtpbmQpIHtcbiAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXI6XG4gICAgICAgICAgbWVtYmVyTmFtZSA9IGdldElkZW50aWZpZXJUZXh0KG1lbWJlci5uYW1lIGFzIHRzLklkZW50aWZpZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuU3RyaW5nTGl0ZXJhbDpcbiAgICAgICAgICBjb25zdCB0ZXh0ID0gKG1lbWJlci5uYW1lIGFzIHRzLlN0cmluZ0xpdGVyYWwpLnRleHQ7XG4gICAgICAgICAgaWYgKGlzVmFsaWRDbG9zdXJlUHJvcGVydHlOYW1lKHRleHQpKSBtZW1iZXJOYW1lID0gdGV4dDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICghbWVtYmVyTmFtZSkge1xuICAgICAgICBlbWl0KGBcXG4vKiBUT0RPOiAke3RzLlN5bnRheEtpbmRbbWVtYmVyLm5hbWUua2luZF19OiAke1xuICAgICAgICAgICAgZXNjYXBlRm9yQ29tbWVudChtZW1iZXIubmFtZS5nZXRUZXh0KCkpfSAqL1xcbmApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGVtaXQoJy8qKiBAY29uc3Qge251bWJlcn0gKi9cXG4nKTtcbiAgICAgIHdyaXRlVmFyaWFibGVTdGF0ZW1lbnQobWVtYmVyTmFtZSwgbmFtZXNwYWNlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3cml0ZVR5cGVBbGlhcyhkZWNsOiB0cy5UeXBlQWxpYXNEZWNsYXJhdGlvbiwgbmFtZXNwYWNlOiBSZWFkb25seUFycmF5PHN0cmluZz4pIHtcbiAgICBjb25zdCB0eXBlU3RyID0gbXR0LnR5cGVUb0Nsb3N1cmUoZGVjbCwgdW5kZWZpbmVkKTtcbiAgICBlbWl0KGBcXG4vKiogQHR5cGVkZWYgeyR7dHlwZVN0cn19ICovXFxuYCk7XG4gICAgd3JpdGVWYXJpYWJsZVN0YXRlbWVudChnZXRJZGVudGlmaWVyVGV4dChkZWNsLm5hbWUpLCBuYW1lc3BhY2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gd3JpdGVUeXBlKFxuICAgICAgZGVjbDogdHMuSW50ZXJmYWNlRGVjbGFyYXRpb258dHMuQ2xhc3NEZWNsYXJhdGlvbiwgbmFtZXNwYWNlOiBSZWFkb25seUFycmF5PHN0cmluZz4pIHtcbiAgICBjb25zdCBuYW1lID0gZGVjbC5uYW1lO1xuICAgIGlmICghbmFtZSkge1xuICAgICAgcmVwb3J0RGlhZ25vc3RpYyhkaWFnbm9zdGljcywgZGVjbCwgJ2Fub255bW91cyB0eXBlIGluIGV4dGVybnMnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHlwZU5hbWUgPSBuYW1lc3BhY2UuY29uY2F0KFtuYW1lLmdldFRleHQoKV0pLmpvaW4oJy4nKTtcbiAgICBpZiAoQ0xPU1VSRV9FWFRFUk5TX0JMQUNLTElTVC5pbmRleE9mKHR5cGVOYW1lKSA+PSAwKSByZXR1cm47XG5cbiAgICBpZiAoaXNGaXJzdFZhbHVlRGVjbGFyYXRpb24oZGVjbCkpIHtcbiAgICAgIC8vIEVtaXQgdGhlICdmdW5jdGlvbicgdGhhdCBpcyBhY3R1YWxseSB0aGUgZGVjbGFyYXRpb24gb2YgdGhlIGludGVyZmFjZVxuICAgICAgLy8gaXRzZWxmLiAgSWYgaXQncyBhIGNsYXNzLCB0aGlzIGZ1bmN0aW9uIGFsc28gbXVzdCBpbmNsdWRlIHRoZSB0eXBlXG4gICAgICAvLyBhbm5vdGF0aW9ucyBvZiB0aGUgY29uc3RydWN0b3IuXG4gICAgICBsZXQgcGFyYW1OYW1lczogc3RyaW5nW10gPSBbXTtcbiAgICAgIGNvbnN0IGpzZG9jVGFnczoganNkb2MuVGFnW10gPSBbXTtcbiAgICAgIGxldCB3cm90ZUpzRG9jID0gZmFsc2U7XG4gICAgICBtYXliZUFkZEhlcml0YWdlQ2xhdXNlcyhqc2RvY1RhZ3MsIG10dCwgZGVjbCk7XG4gICAgICBtYXliZUFkZFRlbXBsYXRlQ2xhdXNlKGpzZG9jVGFncywgZGVjbCk7XG4gICAgICBpZiAoZGVjbC5raW5kID09PSB0cy5TeW50YXhLaW5kLkNsYXNzRGVjbGFyYXRpb24pIHtcbiAgICAgICAgLy8gVE9ETzogaXQgYXBwZWFycyB5b3UgY2FuIGp1c3Qgd3JpdGUgJ2NsYXNzIEZvbyB7IC4uLicgaW4gZXh0ZXJucy5cbiAgICAgICAgLy8gVGhpcyBjb2RlIGluc3RlYWQgdHJpZXMgdG8gdHJhbnNsYXRlIGl0IHRvIGEgZnVuY3Rpb24uXG4gICAgICAgIGpzZG9jVGFncy5wdXNoKHt0YWdOYW1lOiAnY29uc3RydWN0b3InfSwge3RhZ05hbWU6ICdzdHJ1Y3QnfSk7XG4gICAgICAgIGNvbnN0IGN0b3JzID0gKGRlY2wgYXMgdHMuQ2xhc3NEZWNsYXJhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLm1lbWJlcnMuZmlsdGVyKChtKSA9PiBtLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuQ29uc3RydWN0b3IpO1xuICAgICAgICBpZiAoY3RvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgZmlyc3RDdG9yOiB0cy5Db25zdHJ1Y3RvckRlY2xhcmF0aW9uID0gY3RvcnNbMF0gYXMgdHMuQ29uc3RydWN0b3JEZWNsYXJhdGlvbjtcbiAgICAgICAgICBpZiAoY3RvcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcGFyYW1OYW1lcyA9IGVtaXRGdW5jdGlvblR5cGUoY3RvcnMgYXMgdHMuQ29uc3RydWN0b3JEZWNsYXJhdGlvbltdLCBqc2RvY1RhZ3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJhbU5hbWVzID0gZW1pdEZ1bmN0aW9uVHlwZShbZmlyc3RDdG9yXSwganNkb2NUYWdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd3JvdGVKc0RvYyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSBpdCdzIGFuIGludGVyZmFjZTsgdGFnIGl0IGFzIHN0cnVjdHVyYWxseSB0eXBlZC5cbiAgICAgICAganNkb2NUYWdzLnB1c2goe3RhZ05hbWU6ICdyZWNvcmQnfSwge3RhZ05hbWU6ICdzdHJ1Y3QnfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXdyb3RlSnNEb2MpIGVtaXQoanNkb2MudG9TdHJpbmcoanNkb2NUYWdzKSk7XG4gICAgICB3cml0ZUZ1bmN0aW9uKG5hbWUsIHBhcmFtTmFtZXMsIG5hbWVzcGFjZSk7XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBldmVyeXRoaW5nIGV4Y2VwdCAoTWV0aG9kU2lnbmF0dXJlfE1ldGhvZERlY2xhcmF0aW9ufENvbnN0cnVjdG9yKVxuICAgIGNvbnN0IG1ldGhvZHMgPSBuZXcgTWFwPHN0cmluZywgdHMuTWV0aG9kRGVjbGFyYXRpb25bXT4oKTtcbiAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBkZWNsLm1lbWJlcnMpIHtcbiAgICAgIHN3aXRjaCAobWVtYmVyLmtpbmQpIHtcbiAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLlByb3BlcnR5U2lnbmF0dXJlOlxuICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuUHJvcGVydHlEZWNsYXJhdGlvbjpcbiAgICAgICAgICBjb25zdCBwcm9wID0gbWVtYmVyIGFzIHRzLlByb3BlcnR5U2lnbmF0dXJlO1xuICAgICAgICAgIGlmIChwcm9wLm5hbWUua2luZCA9PT0gdHMuU3ludGF4S2luZC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IG10dC50eXBlVG9DbG9zdXJlKHByb3ApO1xuICAgICAgICAgICAgaWYgKHByb3AucXVlc3Rpb25Ub2tlbiAmJiB0eXBlID09PSAnPycpIHtcbiAgICAgICAgICAgICAgLy8gQW4gb3B0aW9uYWwgJ2FueScgdHlwZSB0cmFuc2xhdGVzIHRvICc/fHVuZGVmaW5lZCcgaW4gQ2xvc3VyZS5cbiAgICAgICAgICAgICAgdHlwZSA9ICc/fHVuZGVmaW5lZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbWl0KGpzZG9jLnRvU3RyaW5nKFt7dGFnTmFtZTogJ3R5cGUnLCB0eXBlfV0pKTtcbiAgICAgICAgICAgIGlmIChoYXNNb2RpZmllckZsYWcocHJvcCwgdHMuTW9kaWZpZXJGbGFncy5TdGF0aWMpKSB7XG4gICAgICAgICAgICAgIGVtaXQoYFxcbiR7dHlwZU5hbWV9LiR7cHJvcC5uYW1lLmdldFRleHQoKX07XFxuYCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbWl0KGBcXG4ke3R5cGVOYW1lfS5wcm90b3R5cGUuJHtwcm9wLm5hbWUuZ2V0VGV4dCgpfTtcXG5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUT0RPOiBGb3Igbm93IHByb3BlcnR5IG5hbWVzIG90aGVyIHRoYW4gSWRlbnRpZmllcnMgYXJlIG5vdCBoYW5kbGVkOyBlLmcuXG4gICAgICAgICAgLy8gICAgaW50ZXJmYWNlIEZvbyB7IFwiMTIzYmFyXCI6IG51bWJlciB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5NZXRob2RTaWduYXR1cmU6XG4gICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5NZXRob2REZWNsYXJhdGlvbjpcbiAgICAgICAgICBjb25zdCBtZXRob2QgPSBtZW1iZXIgYXMgdHMuTWV0aG9kRGVjbGFyYXRpb247XG4gICAgICAgICAgY29uc3QgaXNTdGF0aWMgPSBoYXNNb2RpZmllckZsYWcobWV0aG9kLCB0cy5Nb2RpZmllckZsYWdzLlN0YXRpYyk7XG4gICAgICAgICAgY29uc3QgbWV0aG9kU2lnbmF0dXJlID0gYCR7bWV0aG9kLm5hbWUuZ2V0VGV4dCgpfSQkJCR7aXNTdGF0aWMgPyAnc3RhdGljJyA6ICdpbnN0YW5jZSd9YDtcblxuICAgICAgICAgIGlmIChtZXRob2RzLmhhcyhtZXRob2RTaWduYXR1cmUpKSB7XG4gICAgICAgICAgICBtZXRob2RzLmdldChtZXRob2RTaWduYXR1cmUpIS5wdXNoKG1ldGhvZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZHMuc2V0KG1ldGhvZFNpZ25hdHVyZSwgW21ldGhvZF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkNvbnN0cnVjdG9yOlxuICAgICAgICAgIGNvbnRpbnVlOyAgLy8gSGFuZGxlZCBhYm92ZS5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBNZW1iZXJzIGNhbiBpbmNsdWRlIHRoaW5ncyBsaWtlIGluZGV4IHNpZ25hdHVyZXMsIGZvciBlLmcuXG4gICAgICAgICAgLy8gICBpbnRlcmZhY2UgRm9vIHsgW2tleTogc3RyaW5nXTogbnVtYmVyOyB9XG4gICAgICAgICAgLy8gRm9yIG5vdywganVzdCBza2lwIGl0LlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIHRoZSBtZW1iZXIgd2Fzbid0IGhhbmRsZWQgaW4gdGhlIHN3aXRjaCBzdGF0ZW1lbnQuXG4gICAgICBsZXQgbWVtYmVyTmFtZSA9IG5hbWVzcGFjZTtcbiAgICAgIGlmIChtZW1iZXIubmFtZSkge1xuICAgICAgICBtZW1iZXJOYW1lID0gbWVtYmVyTmFtZS5jb25jYXQoW21lbWJlci5uYW1lLmdldFRleHQoKV0pO1xuICAgICAgfVxuICAgICAgZW1pdChgXFxuLyogVE9ETzogJHt0cy5TeW50YXhLaW5kW21lbWJlci5raW5kXX06ICR7bWVtYmVyTmFtZS5qb2luKCcuJyl9ICovXFxuYCk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIG1ldGhvZCBkZWNsYXJhdGlvbnMvc2lnbmF0dXJlcyBzZXBhcmF0ZWx5LCBzaW5jZSB3ZSBuZWVkIHRvIGRlYWwgd2l0aCBvdmVybG9hZHMuXG4gICAgZm9yIChjb25zdCBtZXRob2RWYXJpYW50cyBvZiBBcnJheS5mcm9tKG1ldGhvZHMudmFsdWVzKCkpKSB7XG4gICAgICBjb25zdCBmaXJzdE1ldGhvZFZhcmlhbnQgPSBtZXRob2RWYXJpYW50c1swXTtcbiAgICAgIGxldCBwYXJhbWV0ZXJOYW1lczogc3RyaW5nW107XG4gICAgICBpZiAobWV0aG9kVmFyaWFudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBwYXJhbWV0ZXJOYW1lcyA9IGVtaXRGdW5jdGlvblR5cGUobWV0aG9kVmFyaWFudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyYW1ldGVyTmFtZXMgPSBlbWl0RnVuY3Rpb25UeXBlKFtmaXJzdE1ldGhvZFZhcmlhbnRdKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1ldGhvZE5hbWVzcGFjZSA9IG5hbWVzcGFjZS5jb25jYXQoW25hbWUuZ2V0VGV4dCgpXSk7XG4gICAgICAvLyBJZiB0aGUgbWV0aG9kIGlzIHN0YXRpYywgZG9uJ3QgYWRkIHRoZSBwcm90b3R5cGUuXG4gICAgICBpZiAoIWhhc01vZGlmaWVyRmxhZyhmaXJzdE1ldGhvZFZhcmlhbnQsIHRzLk1vZGlmaWVyRmxhZ3MuU3RhdGljKSkge1xuICAgICAgICBtZXRob2ROYW1lc3BhY2UucHVzaCgncHJvdG90eXBlJyk7XG4gICAgICB9XG4gICAgICB3cml0ZUZ1bmN0aW9uKGZpcnN0TWV0aG9kVmFyaWFudC5uYW1lLCBwYXJhbWV0ZXJOYW1lcywgbWV0aG9kTmFtZXNwYWNlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbGlhc2VzIGZvciB0aGUgc3ltYm9scyBpbXBvcnRlZCBpbiB0aGUgZ2l2ZW4gZGVjbGFyYXRpb24sIHNvIHRoYXQgdGhlaXIgdHlwZXMgZ2V0XG4gICAqIHByaW50ZWQgYXMgdGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lLCBhbmQgbm90IGp1c3QgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGxvY2FsIGltcG9ydCBhbGlhcy5cbiAgICpcbiAgICogdHNpY2tsZSBnZW5lcmF0ZXMgLmpzIGZpbGVzIHRoYXQgKGF0IG1vc3QpIGNvbnRhaW4gYSBgZ29vZy5wcm92aWRlYCwgYnV0IGFyZSBub3RcbiAgICogYGdvb2cubW9kdWxlYHMuIFRoZXNlIGZpbGVzIGNhbm5vdCBleHByZXNzIGFuIGFsaWFzZWQgaW1wb3J0LiBIb3dldmVyIENsb3N1cmUgQ29tcGlsZXIgYWxsb3dzXG4gICAqIHJlZmVyZW5jaW5nIHR5cGVzIHVzaW5nIGZ1bGx5IHF1YWxpZmllZCBuYW1lcyBpbiBzdWNoIGZpbGVzLCBzbyB0c2lja2xlIGNhbiByZXNvbHZlIHRoZVxuICAgKiBpbXBvcnRlZCBtb2R1bGUgVVJJIGFuZCBwcm9kdWNlIGBwYXRoLnRvLm1vZHVsZS5TeW1ib2xgIGFzIGFuIGFsaWFzLCBhbmQgdXNlIHRoYXQgd2hlblxuICAgKiByZWZlcmVuY2luZyB0aGUgdHlwZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFkZEltcG9ydEFsaWFzZXMoZGVjbDogdHMuSW1wb3J0RGVjbGFyYXRpb258dHMuSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24pIHtcbiAgICBsZXQgbW9kdWxlVXJpOiBzdHJpbmc7XG4gICAgaWYgKHRzLmlzSW1wb3J0RGVjbGFyYXRpb24oZGVjbCkpIHtcbiAgICAgIG1vZHVsZVVyaSA9IChkZWNsLm1vZHVsZVNwZWNpZmllciBhcyB0cy5TdHJpbmdMaXRlcmFsKS50ZXh0O1xuICAgIH0gZWxzZSBpZiAodHMuaXNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZShkZWNsLm1vZHVsZVJlZmVyZW5jZSkpIHtcbiAgICAgIC8vIGltcG9ydCBmb28gPSByZXF1aXJlKCcuL2JhcicpO1xuICAgICAgbW9kdWxlVXJpID0gKGRlY2wubW9kdWxlUmVmZXJlbmNlLmV4cHJlc3Npb24gYXMgdHMuU3RyaW5nTGl0ZXJhbCkudGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW1wb3J0IGZvbyA9IGJhci5iYXouYmFtO1xuICAgICAgLy8gdW5zdXBwb3J0ZWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZ29vZ05hbWVzcGFjZSA9IGV4dHJhY3RHb29nTmFtZXNwYWNlSW1wb3J0KG1vZHVsZVVyaSk7XG4gICAgY29uc3QgbW9kdWxlTmFtZSA9IGdvb2dOYW1lc3BhY2UgfHxcbiAgICAgICAgaG9zdC5wYXRoVG9Nb2R1bGVOYW1lKFxuICAgICAgICAgICAgc291cmNlRmlsZS5maWxlTmFtZSwgcmVzb2x2ZU1vZHVsZU5hbWUoaG9zdCwgc291cmNlRmlsZS5maWxlTmFtZSwgbW9kdWxlVXJpKSk7XG5cbiAgICBpZiAodHMuaXNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbihkZWNsKSkge1xuICAgICAgLy8gaW1wb3J0IGZvbyA9IHJlcXVpcmUoJy4vYmFyJyk7XG4gICAgICBhZGRJbXBvcnRBbGlhcyhkZWNsLm5hbWUsIG1vZHVsZU5hbWUsIHVuZGVmaW5lZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0ICdwYXRoJzsgZGVjbGFyZXMgbm8gbG9jYWwgYWxpYXNlcy5cbiAgICBpZiAoIWRlY2wuaW1wb3J0Q2xhdXNlKSByZXR1cm47XG5cbiAgICBpZiAoZGVjbC5pbXBvcnRDbGF1c2UubmFtZSkge1xuICAgICAgLy8gaW1wb3J0IG5hbWUgZnJvbSAuLi4gLT4gbWFwIHRvIC5kZWZhdWx0IG9uIHRoZSBtb2R1bGUubmFtZS5cbiAgICAgIGlmIChnb29nTmFtZXNwYWNlKSB7XG4gICAgICAgIGFkZEltcG9ydEFsaWFzKGRlY2wuaW1wb3J0Q2xhdXNlLm5hbWUsIGdvb2dOYW1lc3BhY2UsIHVuZGVmaW5lZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRJbXBvcnRBbGlhcyhkZWNsLmltcG9ydENsYXVzZS5uYW1lLCBtb2R1bGVOYW1lLCAnZGVmYXVsdCcpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuYW1lZEJpbmRpbmdzID0gZGVjbC5pbXBvcnRDbGF1c2UubmFtZWRCaW5kaW5ncztcbiAgICBpZiAoIW5hbWVkQmluZGluZ3MpIHJldHVybjtcblxuICAgIGlmICh0cy5pc05hbWVzcGFjZUltcG9ydChuYW1lZEJpbmRpbmdzKSkge1xuICAgICAgLy8gaW1wb3J0ICogYXMgbmFtZSAtPiBtYXAgZGlyZWN0bHkgdG8gdGhlIG1vZHVsZS5uYW1lLlxuICAgICAgYWRkSW1wb3J0QWxpYXMobmFtZWRCaW5kaW5ncy5uYW1lLCBtb2R1bGVOYW1lLCB1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIGlmICh0cy5pc05hbWVkSW1wb3J0cyhuYW1lZEJpbmRpbmdzKSkge1xuICAgICAgLy8gaW1wb3J0IHtBIGFzIEJ9LCBtYXAgdG8gbW9kdWxlLm5hbWUuQVxuICAgICAgZm9yIChjb25zdCBuYW1lZEJpbmRpbmcgb2YgbmFtZWRCaW5kaW5ncy5lbGVtZW50cykge1xuICAgICAgICBhZGRJbXBvcnRBbGlhcyhuYW1lZEJpbmRpbmcubmFtZSwgbW9kdWxlTmFtZSwgbmFtZWRCaW5kaW5nLm5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGltcG9ydCBhbGlhcyBmb3IgdGhlIHN5bWJvbCBkZWZpbmVkIGF0IHRoZSBnaXZlbiBub2RlLiBDcmVhdGVzIGFuIGFsaWFzIG5hbWUgYmFzZWQgb25cbiAgICogdGhlIGdpdmVuIG1vZHVsZU5hbWUgYW5kIChvcHRpb25hbGx5KSB0aGUgbmFtZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFkZEltcG9ydEFsaWFzKG5vZGU6IHRzLk5vZGUsIG1vZHVsZU5hbWU6IHN0cmluZywgbmFtZTogdHMuSWRlbnRpZmllcnxzdHJpbmd8dW5kZWZpbmVkKSB7XG4gICAgbGV0IHN5bWJvbCA9IHR5cGVDaGVja2VyLmdldFN5bWJvbEF0TG9jYXRpb24obm9kZSk7XG4gICAgaWYgKCFzeW1ib2wpIHtcbiAgICAgIHJlcG9ydERpYWdub3N0aWMoZGlhZ25vc3RpY3MsIG5vZGUsIGBuYW1lZCBpbXBvcnQgaGFzIG5vIHN5bWJvbGApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgYWxpYXNOYW1lID0gbW9kdWxlTmFtZTtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhbGlhc05hbWUgKz0gJy4nICsgbmFtZTtcbiAgICB9IGVsc2UgaWYgKG5hbWUpIHtcbiAgICAgIGFsaWFzTmFtZSArPSAnLicgKyBnZXRJZGVudGlmaWVyVGV4dChuYW1lKTtcbiAgICB9XG4gICAgaWYgKHN5bWJvbC5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLkFsaWFzKSB7XG4gICAgICBzeW1ib2wgPSB0eXBlQ2hlY2tlci5nZXRBbGlhc2VkU3ltYm9sKHN5bWJvbCk7XG4gICAgfVxuICAgIG10dC5zeW1ib2xzVG9BbGlhc2VkTmFtZXMuc2V0KHN5bWJvbCwgYWxpYXNOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9kdWNlcyBhIGNvbXBpbGVyIGVycm9yIHRoYXQgcmVmZXJlbmNlcyB0aGUgTm9kZSdzIGtpbmQuIFRoaXMgaXMgdXNlZnVsIGZvciB0aGUgXCJlbHNlXCJcbiAgICogYnJhbmNoIG9mIGNvZGUgdGhhdCBpcyBhdHRlbXB0aW5nIHRvIGhhbmRsZSBhbGwgcG9zc2libGUgaW5wdXQgTm9kZSB0eXBlcywgdG8gZW5zdXJlIGFsbCBjYXNlc1xuICAgKiBjb3ZlcmVkLlxuICAgKi9cbiAgZnVuY3Rpb24gZXJyb3JVbmltcGxlbWVudGVkS2luZChub2RlOiB0cy5Ob2RlLCB3aGVyZTogc3RyaW5nKSB7XG4gICAgcmVwb3J0RGlhZ25vc3RpYyhkaWFnbm9zdGljcywgbm9kZSwgYCR7dHMuU3ludGF4S2luZFtub2RlLmtpbmRdfSBub3QgaW1wbGVtZW50ZWQgaW4gJHt3aGVyZX1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXROYW1lc3BhY2VGb3JMb2NhbERlY2xhcmF0aW9uIHJldHVybnMgdGhlIG5hbWVzcGFjZSB0aGF0IHNob3VsZCBiZSB1c2VkIGZvciB0aGUgZ2l2ZW5cbiAgICogZGVjbGFyYXRpb24sIGRlY2lkaW5nIHdoZXRoZXIgdG8gbmFtZXNwYWNlIHRoZSBzeW1ib2wgdG8gdGhlIGZpbGUgb3Igd2hldGhlciB0byBjcmVhdGUgYVxuICAgKiBnbG9iYWwgbmFtZS5cbiAgICpcbiAgICogVGhlIGZ1bmN0aW9uIGNvdmVycyB0aGVzZSBjYXNlczpcbiAgICogMSkgYSBkZWNsYXJhdGlvbiBpbiBhIC5kLnRzXG4gICAqIDFhKSB3aGVyZSB0aGUgLmQudHMgaXMgYW4gZXh0ZXJuYWwgbW9kdWxlICAgICAtLT4gbmFtZXNwYWNlXG4gICAqIDFiKSB3aGVyZSB0aGUgLmQudHMgaXMgbm90IGFuIGV4dGVybmFsIG1vZHVsZSAtLT4gZ2xvYmFsXG4gICAqIDIpIGEgZGVjbGFyYXRpb24gaW4gYSAudHMgZmlsZSAoYWxsIGFyZSB0cmVhdGVkIGFzIG1vZHVsZXMpXG4gICAqIDJhKSB0aGF0IGlzIGV4cG9ydGVkICAgICAgICAgICAgICAgICAgICAgICAgICAtLT4gbmFtZXNwYWNlXG4gICAqIDJiKSB0aGF0IGlzIHVuZXhwb3J0ZWQgICAgICAgICAgICAgICAgICAgICAgICAtLT4gZ2xvYmFsXG4gICAqXG4gICAqIEZvciAxKSwgYWxsIHN5bWJvbHMgaW4gLmQudHMgc2hvdWxkIGdlbmVyYWxseSBiZSBuYW1lc3BhY2VkIHRvIHRoZSBmaWxlIHRvIGF2b2lkIGNvbGxpc2lvbnMuXG4gICAqIEhvd2V2ZXIgLmQudHMgZmlsZXMgdGhhdCBhcmUgbm90IGV4dGVybmFsIG1vZHVsZXMgZG8gZGVjbGFyZSBnbG9iYWwgbmFtZXMgKDFiKS5cbiAgICpcbiAgICogRm9yIDIpLCBhbWJpZW50IGRlY2xhcmF0aW9ucyBpbiAudHMgZmlsZXMgbXVzdCBiZSBuYW1lc3BhY2VkLCBmb3IgdGhlIHNhbWUgY29sbGlzaW9uIHJlYXNvbnMuXG4gICAqIFRoZSBleGNlcHRpb24gaXMgMmIpLCB3aGVyZSBpbiBUeXBlU2NyaXB0LCBhbiB1bmV4cG9ydGVkIGxvY2FsIFwiZGVjbGFyZSBjb25zdCB4OiBzdHJpbmc7XCJcbiAgICogY3JlYXRlcyBhIHN5bWJvbCB0aGF0LCB3aGVuIHVzZWQgbG9jYWxseSwgaXMgZW1pdHRlZCBhcyBqdXN0IFwieFwiLiBUaGF0IGlzLCBpdCBiZWhhdmVzXG4gICAqIGxpa2UgYSB2YXJpYWJsZSBkZWNsYXJlZCBpbiBhICdkZWNsYXJlIGdsb2JhbCcgYmxvY2suIENsb3N1cmUgQ29tcGlsZXIgd291bGQgZmFpbCB0aGUgYnVpbGQgaWZcbiAgICogdGhlcmUgaXMgbm8gZGVjbGFyYXRpb24gZm9yIFwieFwiLCBzbyB0c2lja2xlIG11c3QgZ2VuZXJhdGUgYSBnbG9iYWwgZXh0ZXJuYWwgc3ltYm9sLCBpLmUuXG4gICAqIHdpdGhvdXQgdGhlIG5hbWVzcGFjZSB3cmFwcGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0TmFtZXNwYWNlRm9yVG9wTGV2ZWxEZWNsYXJhdGlvbihcbiAgICAgIGRlY2xhcmF0aW9uOiB0cy5Ob2RlLCBuYW1lc3BhY2U6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPik6IFJlYWRvbmx5QXJyYXk8c3RyaW5nPiB7XG4gICAgLy8gT25seSB1c2Ugcm9vdE5hbWVzcGFjZSBmb3IgdG9wIGxldmVsIHN5bWJvbHMsIGFueSBvdGhlciBuYW1lc3BhY2luZyAoZ2xvYmFsIG5hbWVzLCBuZXN0ZWRcbiAgICAvLyBuYW1lc3BhY2VzKSBpcyBhbHdheXMga2VwdC5cbiAgICBpZiAobmFtZXNwYWNlLmxlbmd0aCAhPT0gMCkgcmV0dXJuIG5hbWVzcGFjZTtcbiAgICAvLyBBbGwgbmFtZXMgaW4gYSBtb2R1bGUgKGV4dGVybmFsKSAuZC50cyBmaWxlIGNhbiBvbmx5IGJlIGFjY2Vzc2VkIGxvY2FsbHksIHNvIHRoZXkgYWx3YXlzIGdldFxuICAgIC8vIG5hbWVzcGFjZSBwcmVmaXhlZC5cbiAgICBpZiAoaXNEdHMgJiYgaXNFeHRlcm5hbE1vZHVsZSkgcmV0dXJuIFtyb290TmFtZXNwYWNlXTtcbiAgICAvLyBTYW1lIGZvciBleHBvcnRlZCBkZWNsYXJhdGlvbnMgaW4gcmVndWxhciAudHMgZmlsZXMuXG4gICAgaWYgKGhhc01vZGlmaWVyRmxhZyhkZWNsYXJhdGlvbiwgdHMuTW9kaWZpZXJGbGFncy5FeHBvcnQpKSByZXR1cm4gW3Jvb3ROYW1lc3BhY2VdO1xuICAgIC8vIEJ1dCBsb2NhbCBkZWNsYXJhdGlvbnMgaW4gLnRzIGZpbGVzIG9yIC5kLnRzIGZpbGVzICgxYiwgMmIpIGFyZSBnbG9iYWwsIHRvby5cbiAgICByZXR1cm4gW107XG4gIH1cblxuICBmdW5jdGlvbiB2aXNpdG9yKG5vZGU6IHRzLk5vZGUsIG5hbWVzcGFjZTogUmVhZG9ubHlBcnJheTxzdHJpbmc+KSB7XG4gICAgaWYgKG5vZGUucGFyZW50ID09PSBzb3VyY2VGaWxlKSB7XG4gICAgICBuYW1lc3BhY2UgPSBnZXROYW1lc3BhY2VGb3JUb3BMZXZlbERlY2xhcmF0aW9uKG5vZGUsIG5hbWVzcGFjZSk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChub2RlLmtpbmQpIHtcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5Nb2R1bGVEZWNsYXJhdGlvbjpcbiAgICAgICAgY29uc3QgZGVjbCA9IG5vZGUgYXMgdHMuTW9kdWxlRGVjbGFyYXRpb247XG4gICAgICAgIHN3aXRjaCAoZGVjbC5uYW1lLmtpbmQpIHtcbiAgICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuSWRlbnRpZmllcjpcbiAgICAgICAgICAgIGlmIChkZWNsLmZsYWdzICYgdHMuTm9kZUZsYWdzLkdsb2JhbEF1Z21lbnRhdGlvbikge1xuICAgICAgICAgICAgICAvLyBFLmcuIFwiZGVjbGFyZSBnbG9iYWwgeyAuLi4gfVwiLiAgUmVzZXQgdG8gdGhlIG91dGVyIG5hbWVzcGFjZS5cbiAgICAgICAgICAgICAgbmFtZXNwYWNlID0gW107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBFLmcuIFwiZGVjbGFyZSBuYW1lc3BhY2UgZm9vIHtcIlxuICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZ2V0SWRlbnRpZmllclRleHQoZGVjbC5uYW1lIGFzIHRzLklkZW50aWZpZXIpO1xuICAgICAgICAgICAgICBpZiAoaXNGaXJzdFZhbHVlRGVjbGFyYXRpb24oZGVjbCkpIHtcbiAgICAgICAgICAgICAgICBlbWl0KCcvKiogQGNvbnN0ICovXFxuJyk7XG4gICAgICAgICAgICAgICAgd3JpdGVWYXJpYWJsZVN0YXRlbWVudChuYW1lLCBuYW1lc3BhY2UsICd7fScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5hbWVzcGFjZSA9IG5hbWVzcGFjZS5jb25jYXQobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVjbC5ib2R5KSB2aXNpdG9yKGRlY2wuYm9keSwgbmFtZXNwYWNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5TdHJpbmdMaXRlcmFsOlxuICAgICAgICAgICAgLy8gRS5nLiBcImRlY2xhcmUgbW9kdWxlICdmb28nIHtcIiAobm90ZSB0aGUgcXVvdGVzKS5cbiAgICAgICAgICAgIC8vIFdlIHN0aWxsIHdhbnQgdG8gZW1pdCBleHRlcm5zIGZvciB0aGlzIG1vZHVsZSwgYnV0IENsb3N1cmUgZG9lc24ndCBwcm92aWRlIGFcbiAgICAgICAgICAgIC8vIG1lY2hhbmlzbSBmb3IgbW9kdWxlLXNjb3BlZCBleHRlcm5zLiBJbnN0ZWFkLCB3ZSBlbWl0IGluIGEgbWFuZ2xlZCBuYW1lc3BhY2UuXG4gICAgICAgICAgICAvLyBUaGUgbWFuZ2xlZCBuYW1lc3BhY2UgKGFmdGVyIHJlc29sdmluZyBmaWxlcykgbWF0Y2hlcyB0aGUgZW1pdCBmb3IgYW4gb3JpZ2luYWwgbW9kdWxlXG4gICAgICAgICAgICAvLyBmaWxlLCBzbyBlZmZlY3RpdmVseSB0aGlzIGF1Z21lbnRzIGFueSBleGlzdGluZyBtb2R1bGUuXG5cbiAgICAgICAgICAgIGNvbnN0IGltcG9ydE5hbWUgPSAoZGVjbC5uYW1lIGFzIHRzLlN0cmluZ0xpdGVyYWwpLnRleHQ7XG4gICAgICAgICAgICBjb25zdCBpbXBvcnRlZE1vZHVsZU5hbWUgPSByZXNvbHZlTW9kdWxlTmFtZShcbiAgICAgICAgICAgICAgICB7aG9zdDogbW9kdWxlUmVzb2x1dGlvbkhvc3QsIG9wdGlvbnN9LCBzb3VyY2VGaWxlLmZpbGVOYW1lLCBpbXBvcnROYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IG1hbmdsZWQgPSBtb2R1bGVOYW1lQXNJZGVudGlmaWVyKGhvc3QsIGltcG9ydGVkTW9kdWxlTmFtZSk7XG4gICAgICAgICAgICBlbWl0KGAvLyBEZXJpdmVkIGZyb206IGRlY2xhcmUgbW9kdWxlIFwiJHtpbXBvcnROYW1lfVwiXFxuYCk7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSBbbWFuZ2xlZF07XG5cbiAgICAgICAgICAgIC8vIERlY2xhcmUgXCJtYW5nbGVkJG5hbWVcIiBpZiBpdCdzIG5vdCBkZWNsYXJlZCBhbHJlYWR5IGVsc2V3aGVyZS5cbiAgICAgICAgICAgIGlmIChpc0ZpcnN0VmFsdWVEZWNsYXJhdGlvbihkZWNsKSkge1xuICAgICAgICAgICAgICBlbWl0KCcvKiogQGNvbnN0ICovXFxuJyk7XG4gICAgICAgICAgICAgIHdyaXRlVmFyaWFibGVTdGF0ZW1lbnQobWFuZ2xlZCwgW10sICd7fScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGVjbGFyZSB0aGUgY29udGVudHMgaW5zaWRlIHRoZSBcIm1hbmdsZWQkbmFtZVwiLlxuICAgICAgICAgICAgaWYgKGRlY2wuYm9keSkgdmlzaXRvcihkZWNsLmJvZHksIFttYW5nbGVkXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZXJyb3JVbmltcGxlbWVudGVkS2luZChkZWNsLm5hbWUsICdleHRlcm5zIGdlbmVyYXRpb24gb2YgbmFtZXNwYWNlJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5Nb2R1bGVCbG9jazpcbiAgICAgICAgY29uc3QgYmxvY2sgPSBub2RlIGFzIHRzLk1vZHVsZUJsb2NrO1xuICAgICAgICBmb3IgKGNvbnN0IHN0bXQgb2YgYmxvY2suc3RhdGVtZW50cykge1xuICAgICAgICAgIHZpc2l0b3Ioc3RtdCwgbmFtZXNwYWNlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5JbXBvcnRFcXVhbHNEZWNsYXJhdGlvbjpcbiAgICAgICAgY29uc3QgaW1wb3J0RXF1YWxzID0gbm9kZSBhcyB0cy5JbXBvcnRFcXVhbHNEZWNsYXJhdGlvbjtcbiAgICAgICAgY29uc3QgbG9jYWxOYW1lID0gZ2V0SWRlbnRpZmllclRleHQoaW1wb3J0RXF1YWxzLm5hbWUpO1xuICAgICAgICBpZiAobG9jYWxOYW1lID09PSAnbmcnKSB7XG4gICAgICAgICAgZW1pdChgXFxuLyogU2tpcHBpbmcgcHJvYmxlbWF0aWMgaW1wb3J0IG5nID0gLi4uOyAqL1xcbmApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbXBvcnRFcXVhbHMubW9kdWxlUmVmZXJlbmNlLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2UpIHtcbiAgICAgICAgICBhZGRJbXBvcnRBbGlhc2VzKGltcG9ydEVxdWFscyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcW4gPSBnZXRFbnRpdHlOYW1lVGV4dChpbXBvcnRFcXVhbHMubW9kdWxlUmVmZXJlbmNlKTtcbiAgICAgICAgLy8gQGNvbnN0IHNvIHRoYXQgQ2xvc3VyZSBDb21waWxlciB1bmRlcnN0YW5kcyB0aGlzIGlzIGFuIGFsaWFzLlxuICAgICAgICBpZiAobmFtZXNwYWNlLmxlbmd0aCA9PT0gMCkgZW1pdCgnLyoqIEBjb25zdCAqL1xcbicpO1xuICAgICAgICB3cml0ZVZhcmlhYmxlU3RhdGVtZW50KGxvY2FsTmFtZSwgbmFtZXNwYWNlLCBxbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkNsYXNzRGVjbGFyYXRpb246XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuSW50ZXJmYWNlRGVjbGFyYXRpb246XG4gICAgICAgIHdyaXRlVHlwZShub2RlIGFzIHRzLkludGVyZmFjZURlY2xhcmF0aW9uIHwgdHMuQ2xhc3NEZWNsYXJhdGlvbiwgbmFtZXNwYWNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuRnVuY3Rpb25EZWNsYXJhdGlvbjpcbiAgICAgICAgY29uc3QgZm5EZWNsID0gbm9kZSBhcyB0cy5GdW5jdGlvbkRlY2xhcmF0aW9uO1xuICAgICAgICBjb25zdCBuYW1lID0gZm5EZWNsLm5hbWU7XG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgIHJlcG9ydERpYWdub3N0aWMoZGlhZ25vc3RpY3MsIGZuRGVjbCwgJ2Fub255bW91cyBmdW5jdGlvbiBpbiBleHRlcm5zJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2F0aGVyIHVwIGFsbCBvdmVybG9hZHMgb2YgdGhpcyBmdW5jdGlvbi5cbiAgICAgICAgY29uc3Qgc3ltID0gdHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihuYW1lKSE7XG4gICAgICAgIGNvbnN0IGRlY2xzID0gc3ltLmRlY2xhcmF0aW9ucyEuZmlsdGVyKHRzLmlzRnVuY3Rpb25EZWNsYXJhdGlvbik7XG4gICAgICAgIC8vIE9ubHkgZW1pdCB0aGUgZmlyc3QgZGVjbGFyYXRpb24gb2YgZWFjaCBvdmVybG9hZGVkIGZ1bmN0aW9uLlxuICAgICAgICBpZiAoZm5EZWNsICE9PSBkZWNsc1swXSkgYnJlYWs7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IGVtaXRGdW5jdGlvblR5cGUoZGVjbHMpO1xuICAgICAgICB3cml0ZUZ1bmN0aW9uKG5hbWUsIHBhcmFtcywgbmFtZXNwYWNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuVmFyaWFibGVTdGF0ZW1lbnQ6XG4gICAgICAgIGZvciAoY29uc3QgZGVjbCBvZiAobm9kZSBhcyB0cy5WYXJpYWJsZVN0YXRlbWVudCkuZGVjbGFyYXRpb25MaXN0LmRlY2xhcmF0aW9ucykge1xuICAgICAgICAgIHdyaXRlVmFyaWFibGVEZWNsYXJhdGlvbihkZWNsLCBuYW1lc3BhY2UpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkVudW1EZWNsYXJhdGlvbjpcbiAgICAgICAgd3JpdGVFbnVtKG5vZGUgYXMgdHMuRW51bURlY2xhcmF0aW9uLCBuYW1lc3BhY2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5UeXBlQWxpYXNEZWNsYXJhdGlvbjpcbiAgICAgICAgd3JpdGVUeXBlQWxpYXMobm9kZSBhcyB0cy5UeXBlQWxpYXNEZWNsYXJhdGlvbiwgbmFtZXNwYWNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRzLlN5bnRheEtpbmQuSW1wb3J0RGVjbGFyYXRpb246XG4gICAgICAgIGFkZEltcG9ydEFsaWFzZXMobm9kZSBhcyB0cy5JbXBvcnREZWNsYXJhdGlvbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLk5hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uOlxuICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkV4cG9ydEFzc2lnbm1lbnQ6XG4gICAgICAgIC8vIEhhbmRsZWQgb24gdGhlIGZpbGUgbGV2ZWwuXG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc3QgbG9jYXRpb25TdHIgPSBuYW1lc3BhY2Uuam9pbignLicpIHx8IHBhdGguYmFzZW5hbWUobm9kZS5nZXRTb3VyY2VGaWxlKCkuZmlsZU5hbWUpO1xuICAgICAgICBlbWl0KGBcXG4vLyBUT0RPKHRzaWNrbGUpOiAke3RzLlN5bnRheEtpbmRbbm9kZS5raW5kXX0gaW4gJHtsb2NhdGlvblN0cn1cXG5gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG4iXX0=