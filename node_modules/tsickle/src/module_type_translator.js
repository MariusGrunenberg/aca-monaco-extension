/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/module_type_translator", ["require", "exports", "tsickle/src/googmodule", "tsickle/src/jsdoc", "tsickle/src/transformer_util", "tsickle/src/type_translator", "tsickle/src/typescript"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * @fileoverview module_type_translator builds on top of type_translator, adding functionality to
     * translate types within the scope of a single module. The main entry point is
     * ModuleTypeTranslator.
     */
    var googmodule = require("tsickle/src/googmodule");
    var jsdoc = require("tsickle/src/jsdoc");
    var transformer_util_1 = require("tsickle/src/transformer_util");
    var typeTranslator = require("tsickle/src/type_translator");
    var ts = require("tsickle/src/typescript");
    /**
     * MutableJSDoc encapsulates a (potential) JSDoc comment on a specific node, and allows code to
     * modify (including delete) it.
     */
    var MutableJSDoc = /** @class */ (function () {
        function MutableJSDoc(node, sourceComment, tags) {
            this.node = node;
            this.sourceComment = sourceComment;
            this.tags = tags;
        }
        MutableJSDoc.prototype.updateComment = function (escapeExtraTags) {
            var text = jsdoc.toStringWithoutStartEnd(this.tags, escapeExtraTags);
            if (this.sourceComment) {
                if (!text) {
                    // Delete the (now empty) comment.
                    var comments_1 = ts.getSyntheticLeadingComments(this.node);
                    var idx = comments_1.indexOf(this.sourceComment);
                    comments_1.splice(idx, 1);
                    this.sourceComment = null;
                    return;
                }
                this.sourceComment.text = text;
                return;
            }
            // Don't add an empty comment.
            if (!text)
                return;
            var comment = {
                kind: ts.SyntaxKind.MultiLineCommentTrivia,
                text: text,
                hasTrailingNewLine: true,
                pos: -1,
                end: -1,
            };
            var comments = ts.getSyntheticLeadingComments(this.node) || [];
            comments.push(comment);
            ts.setSyntheticLeadingComments(this.node, comments);
        };
        return MutableJSDoc;
    }());
    exports.MutableJSDoc = MutableJSDoc;
    /** Returns the Closure name of a function parameter, special-casing destructuring. */
    function getParameterName(param, index) {
        switch (param.name.kind) {
            case ts.SyntaxKind.Identifier:
                var name_1 = transformer_util_1.getIdentifierText(param.name);
                // TypeScript allows parameters named "arguments", but Closure
                // disallows this, even in externs.
                if (name_1 === 'arguments')
                    name_1 = 'tsickle_arguments';
                return name_1;
            case ts.SyntaxKind.ArrayBindingPattern:
            case ts.SyntaxKind.ObjectBindingPattern:
                // Closure crashes if you put a binding pattern in the externs.
                // Avoid this by just generating an unused name; the name is
                // ignored anyway.
                return "__" + index;
            default:
                // The above list of kinds is exhaustive.  param.name is 'never' at this point.
                var paramName = param.name;
                throw new Error("unhandled function parameter kind: " + ts.SyntaxKind[paramName.kind]);
        }
    }
    /**
     * ModuleTypeTranslator encapsulates knowledge and helper functions to translate types in the scope
     * of a specific module. This includes managing Closure forward declare statements and any symbol
     * aliases in scope for a whole file.
     */
    var ModuleTypeTranslator = /** @class */ (function () {
        function ModuleTypeTranslator(sourceFile, typeChecker, host, diagnostics, isForExterns) {
            this.sourceFile = sourceFile;
            this.typeChecker = typeChecker;
            this.host = host;
            this.diagnostics = diagnostics;
            this.isForExterns = isForExterns;
            /**
             * A mapping of aliases for symbols in the current file, used when emitting types. TypeScript
             * emits imported symbols with unpredictable prefixes. To generate correct type annotations,
             * tsickle creates its own aliases for types, and registers them in this map (see
             * `emitImportDeclaration` and `forwardDeclare()` below). The aliases are then used when emitting
             * types.
             */
            this.symbolsToAliasedNames = new Map();
            /**
             * The set of module symbols forward declared in the local namespace (with goog.forwarDeclare).
             *
             * Symbols not imported must be declared, which is done by adding forward declares to
             * `extraImports` below.
             */
            this.forwardDeclaredModules = new Set();
            /**
             * The list of generated goog.forwardDeclare statements for this module. These are inserted into
             * the module's body statements after translation.
             */
            this.forwardDeclares = [];
            /** A counter to generate unique names for goog.forwardDeclare variables. */
            this.forwardDeclareCounter = 0;
        }
        ModuleTypeTranslator.prototype.debugWarn = function (context, messageText) {
            transformer_util_1.reportDebugWarning(this.host, context, messageText);
        };
        ModuleTypeTranslator.prototype.error = function (node, messageText) {
            transformer_util_1.reportDiagnostic(this.diagnostics, node, messageText);
        };
        /**
         * Convert a TypeScript ts.Type into the equivalent Closure type.
         *
         * @param context The ts.Node containing the type reference; used for resolving symbols
         *     in context.
         * @param type The type to translate; if not provided, the Node's type will be used.
         * @param resolveAlias If true, do not emit aliases as their symbol, but rather as the resolved
         *     type underlying the alias. This should be true only when emitting the typedef itself.
         */
        ModuleTypeTranslator.prototype.typeToClosure = function (context, type) {
            if (this.host.untyped) {
                return '?';
            }
            var typeChecker = this.typeChecker;
            if (!type) {
                type = typeChecker.getTypeAtLocation(context);
            }
            return this.newTypeTranslator(context).translate(type);
        };
        ModuleTypeTranslator.prototype.newTypeTranslator = function (context) {
            var _this = this;
            // In externs, there is no local scope, so all types must be relative to the file level scope.
            var translationContext = this.isForExterns ? this.sourceFile : context;
            var translator = new typeTranslator.TypeTranslator(this.host, this.typeChecker, translationContext, this.host.typeBlackListPaths, this.symbolsToAliasedNames, function (sym) { return _this.ensureSymbolDeclared(sym); });
            translator.isForExterns = this.isForExterns;
            translator.warn = function (msg) { return _this.debugWarn(context, msg); };
            return translator;
        };
        ModuleTypeTranslator.prototype.isBlackListed = function (context) {
            var type = this.typeChecker.getTypeAtLocation(context);
            var sym = type.symbol;
            if (!sym)
                return false;
            if (sym.flags & ts.SymbolFlags.Alias) {
                sym = this.typeChecker.getAliasedSymbol(sym);
            }
            return this.newTypeTranslator(context).isBlackListed(sym);
        };
        /**
         * Get the ts.Symbol at a location or throw.
         * The TypeScript API can return undefined when fetching a symbol, but in many contexts we know it
         * won't (e.g. our input is already type-checked).
         */
        ModuleTypeTranslator.prototype.mustGetSymbolAtLocation = function (node) {
            var sym = this.typeChecker.getSymbolAtLocation(node);
            if (!sym)
                throw new Error('no symbol');
            return sym;
        };
        /** Finds an exported (i.e. not global) declaration for the given symbol. */
        ModuleTypeTranslator.prototype.findExportedDeclaration = function (sym) {
            var _this = this;
            // TODO(martinprobst): it's unclear when a symbol wouldn't have a declaration, maybe just for
            // some builtins (e.g. Symbol)?
            if (!sym.declarations || sym.declarations.length === 0)
                return undefined;
            // A symbol declared in this file does not need to be imported.
            if (sym.declarations.some(function (d) { return d.getSourceFile() === _this.sourceFile; }))
                return undefined;
            // Find an exported declaration.
            // Because tsickle runs with the --declaration flag, all types referenced from exported types
            // must be exported, too, so there must either be some declaration that is exported, or the
            // symbol is actually a global declaration (declared in a script file, not a module).
            var decl = sym.declarations.find(function (d) {
                // Check for Export | Default (default being a default export).
                if (!transformer_util_1.hasModifierFlag(d, ts.ModifierFlags.ExportDefault))
                    return false;
                // Exclude symbols declared in `declare global {...}` blocks, they are global and don't need
                // imports.
                var current = d;
                while (current) {
                    if (current.flags & ts.NodeFlags.GlobalAugmentation)
                        return false;
                    current = current.parent;
                }
                return true;
            });
            return decl;
        };
        /**
         * Returns the `const x = goog.forwardDeclare...` text for an import of the given `importPath`.
         * This also registers aliases for symbols from the module that map to this forward declare.
         */
        ModuleTypeTranslator.prototype.forwardDeclare = function (importPath, moduleSymbol, isExplicitImport, isDefaultImport) {
            var _this = this;
            if (isDefaultImport === void 0) { isDefaultImport = false; }
            var e_1, _a;
            if (this.host.untyped)
                return;
            // Already imported? Do not emit a duplicate forward declare.
            if (this.forwardDeclaredModules.has(moduleSymbol))
                return;
            var nsImport = googmodule.extractGoogNamespaceImport(importPath);
            var forwardDeclarePrefix = "tsickle_forward_declare_" + ++this.forwardDeclareCounter;
            var moduleNamespace = nsImport !== null ?
                nsImport :
                this.host.pathToModuleName(this.sourceFile.fileName, importPath);
            // In TypeScript, importing a module for use in a type annotation does not cause a runtime load.
            // In Closure Compiler, goog.require'ing a module causes a runtime load, so emitting requires
            // here would cause a change in load order, which is observable (and can lead to errors).
            // Instead, goog.forwardDeclare types, which allows using them in type annotations without
            // causing a load. See below for the exception to the rule.
            // const forwardDeclarePrefix = goog.forwardDeclare(moduleNamespace)
            this.forwardDeclares.push(ts.createVariableStatement(undefined, ts.createVariableDeclarationList([ts.createVariableDeclaration(forwardDeclarePrefix, undefined, ts.createCall(ts.createPropertyAccess(ts.createIdentifier('goog'), 'forwardDeclare'), undefined, [ts.createLiteral(moduleNamespace)]))], ts.NodeFlags.Const)));
            this.forwardDeclaredModules.add(moduleSymbol);
            var exports = this.typeChecker.getExportsOfModule(moduleSymbol).map(function (e) {
                if (e.flags & ts.SymbolFlags.Alias) {
                    e = _this.typeChecker.getAliasedSymbol(e);
                }
                return e;
            });
            var hasValues = exports.some(function (e) {
                var isValue = (e.flags & ts.SymbolFlags.Value) !== 0;
                var isConstEnum = (e.flags & ts.SymbolFlags.ConstEnum) !== 0;
                // const enums are inlined by TypeScript (if preserveConstEnums=false), so there is never a
                // value import generated for them. That means for the purpose of force-importing modules,
                // they do not count as values. If preserveConstEnums=true, this shouldn't hurt.
                return isValue && !isConstEnum;
            });
            if (isExplicitImport && !hasValues) {
                // Closure Compiler's toolchain will drop files that are never goog.require'd *before* type
                // checking (e.g. when using --closure_entry_point or similar tools). This causes errors
                // complaining about values not matching 'NoResolvedType', or modules not having a certain
                // member.
                // To fix, explicitly goog.require() modules that only export types. This should usually not
                // cause breakages due to load order (as no symbols are accessible from the module - though
                // contrived code could observe changes in side effects).
                // This is a heuristic - if the module exports some values, but those are never imported,
                // the file will still end up not being imported. Hopefully modules that export values are
                // imported for their value in some place.
                // goog.require("${moduleNamespace}");
                var hardRequire = ts.createStatement(ts.createCall(ts.createPropertyAccess(ts.createIdentifier('goog'), 'require'), undefined, [transformer_util_1.createSingleQuoteStringLiteral(moduleNamespace)]));
                var comment = {
                    kind: ts.SyntaxKind.SingleLineCommentTrivia,
                    text: ' force type-only module to be loaded',
                    hasTrailingNewLine: true,
                    pos: -1,
                    end: -1,
                };
                ts.setSyntheticTrailingComments(hardRequire, [comment]);
                this.forwardDeclares.push(hardRequire);
            }
            try {
                for (var exports_1 = __values(exports), exports_1_1 = exports_1.next(); !exports_1_1.done; exports_1_1 = exports_1.next()) {
                    var sym = exports_1_1.value;
                    // goog: imports don't actually use the .default property that TS thinks they have.
                    var qualifiedName = nsImport && isDefaultImport ? forwardDeclarePrefix :
                        forwardDeclarePrefix + '.' + sym.name;
                    this.symbolsToAliasedNames.set(sym, qualifiedName);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (exports_1_1 && !exports_1_1.done && (_a = exports_1.return)) _a.call(exports_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        ModuleTypeTranslator.prototype.ensureSymbolDeclared = function (sym) {
            var decl = this.findExportedDeclaration(sym);
            if (!decl)
                return;
            if (this.isForExterns) {
                this.error(decl, "declaration from module used in ambient type: " + sym.name);
                return;
            }
            // Actually import the symbol.
            var sourceFile = decl.getSourceFile();
            if (sourceFile === ts.getOriginalNode(this.sourceFile))
                return;
            var moduleSymbol = this.typeChecker.getSymbolAtLocation(sourceFile);
            // A source file might not have a symbol if it's not a module (no ES6 im/exports).
            if (!moduleSymbol)
                return;
            // TODO(martinprobst): this should possibly use fileNameToModuleId.
            this.forwardDeclare(sourceFile.fileName, moduleSymbol, false);
        };
        ModuleTypeTranslator.prototype.insertForwardDeclares = function (sourceFile) {
            var insertion = 0;
            // Skip over a leading file comment holder.
            if (sourceFile.statements.length &&
                sourceFile.statements[0].kind === ts.SyntaxKind.NotEmittedStatement) {
                insertion++;
            }
            return ts.updateSourceFileNode(sourceFile, __spread(sourceFile.statements.slice(0, insertion), this.forwardDeclares, sourceFile.statements.slice(insertion)));
        };
        /**
         * Parses and synthesizes comments on node, and returns the JSDoc from it, if any.
         * @param reportWarnings if true, will report warnings from parsing the JSDoc. Set to false if
         *     this is not the "main" location dealing with a node to avoid duplicated warnings.
         */
        ModuleTypeTranslator.prototype.getJSDoc = function (node, reportWarnings) {
            var _a = __read(this.parseJSDoc(node, reportWarnings), 1), tags = _a[0];
            return tags;
        };
        ModuleTypeTranslator.prototype.getMutableJSDoc = function (node) {
            var _a = __read(this.parseJSDoc(node, /* reportWarnings */ true), 2), tags = _a[0], comment = _a[1];
            return new MutableJSDoc(node, comment, tags);
        };
        ModuleTypeTranslator.prototype.parseJSDoc = function (node, reportWarnings) {
            // synthesizeLeadingComments below changes text locations for node, so extract the location here
            // in case it is needed later to report diagnostics.
            var start = node.getFullStart();
            var length = node.getLeadingTriviaWidth(this.sourceFile);
            var comments = jsdoc.synthesizeLeadingComments(node);
            if (!comments || comments.length === 0)
                return [[], null];
            for (var i = comments.length - 1; i >= 0; i--) {
                var comment = comments[i];
                var parsed = jsdoc.parse(comment);
                if (parsed) {
                    if (reportWarnings && parsed.warnings) {
                        var range = comment.originalRange || { pos: start, end: start + length };
                        transformer_util_1.reportDiagnostic(this.diagnostics, node, parsed.warnings.join('\n'), range, ts.DiagnosticCategory.Warning);
                    }
                    return [parsed.tags, comment];
                }
            }
            return [[], null];
        };
        ModuleTypeTranslator.prototype.blacklistTypeParameters = function (context, decls) {
            this.newTypeTranslator(context).blacklistTypeParameters(this.symbolsToAliasedNames, decls);
        };
        /**
         * Creates the jsdoc for methods, including overloads.
         * If overloaded, merges the signatures in the list of SignatureDeclarations into a single jsdoc.
         * - Total number of parameters will be the maximum count found across all variants.
         * - Different names at the same parameter index will be joined with "_or_"
         * - Variable args (...type[] in TypeScript) will be output as "...type",
         *    except if found at the same index as another argument.
         * @param fnDecls Pass > 1 declaration for overloads of same name
         * @return The list of parameter names that should be used to emit the actual
         *    function statement; for overloads, name will have been merged.
         */
        ModuleTypeTranslator.prototype.getFunctionTypeJSDoc = function (fnDecls, extraTags) {
            if (extraTags === void 0) { extraTags = []; }
            var e_2, _a, e_3, _b, e_4, _c, e_5, _d, e_6, _e, e_7, _f;
            var typeChecker = this.typeChecker;
            // De-duplicate tags and docs found for the fnDecls.
            var tagsByName = new Map();
            function addTag(tag) {
                var existing = tagsByName.get(tag.tagName);
                tagsByName.set(tag.tagName, existing ? jsdoc.merge([existing, tag]) : tag);
            }
            try {
                for (var extraTags_1 = __values(extraTags), extraTags_1_1 = extraTags_1.next(); !extraTags_1_1.done; extraTags_1_1 = extraTags_1.next()) {
                    var extraTag = extraTags_1_1.value;
                    addTag(extraTag);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (extraTags_1_1 && !extraTags_1_1.done && (_a = extraTags_1.return)) _a.call(extraTags_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            var lens = fnDecls.map(function (fnDecl) { return fnDecl.parameters.length; });
            var minArgsCount = Math.min.apply(Math, __spread(lens));
            var maxArgsCount = Math.max.apply(Math, __spread(lens));
            var isConstructor = fnDecls.find(function (d) { return d.kind === ts.SyntaxKind.Constructor; }) !== undefined;
            // For each parameter index i, paramTags[i] is an array of parameters
            // that can be found at index i.  E.g.
            //    function foo(x: string)
            //    function foo(y: number, z: string)
            // then paramTags[0] = [info about x, info about y].
            var paramTags = [];
            var returnTags = [];
            var typeParameterNames = new Set();
            try {
                for (var fnDecls_1 = __values(fnDecls), fnDecls_1_1 = fnDecls_1.next(); !fnDecls_1_1.done; fnDecls_1_1 = fnDecls_1.next()) {
                    var fnDecl = fnDecls_1_1.value;
                    // Construct the JSDoc comment by reading the existing JSDoc, if
                    // any, and merging it with the known types of the function
                    // parameters and return type.
                    var tags = this.getJSDoc(fnDecl, /* reportWarnings */ false);
                    try {
                        // Copy all the tags other than @param/@return into the new
                        // JSDoc without any change; @param/@return are handled specially.
                        // TODO: there may be problems if an annotation doesn't apply to all overloads;
                        // is it worth checking for this and erroring?
                        for (var tags_1 = __values(tags), tags_1_1 = tags_1.next(); !tags_1_1.done; tags_1_1 = tags_1.next()) {
                            var tag = tags_1_1.value;
                            if (tag.tagName === 'param' || tag.tagName === 'return')
                                continue;
                            addTag(tag);
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (tags_1_1 && !tags_1_1.done && (_c = tags_1.return)) _c.call(tags_1);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                    // Add @abstract on "abstract" declarations.
                    if (transformer_util_1.hasModifierFlag(fnDecl, ts.ModifierFlags.Abstract)) {
                        addTag({ tagName: 'abstract' });
                    }
                    // Add any @template tags.
                    // Multiple declarations with the same template variable names should work:
                    // the declarations get turned into union types, and Closure Compiler will need
                    // to find a union where all type arguments are satisfied.
                    if (fnDecl.typeParameters) {
                        try {
                            for (var _g = __values(fnDecl.typeParameters), _h = _g.next(); !_h.done; _h = _g.next()) {
                                var tp = _h.value;
                                typeParameterNames.add(transformer_util_1.getIdentifierText(tp.name));
                            }
                        }
                        catch (e_5_1) { e_5 = { error: e_5_1 }; }
                        finally {
                            try {
                                if (_h && !_h.done && (_d = _g.return)) _d.call(_g);
                            }
                            finally { if (e_5) throw e_5.error; }
                        }
                    }
                    // Merge the parameters into a single list of merged names and list of types
                    var sig = typeChecker.getSignatureFromDeclaration(fnDecl);
                    if (!sig || !sig.declaration)
                        throw new Error("invalid signature " + fnDecl.name);
                    if (sig.declaration.kind === ts.SyntaxKindJSDocSignature) {
                        throw new Error("JSDoc signature " + fnDecl.name);
                    }
                    for (var i = 0; i < sig.declaration.parameters.length; i++) {
                        var paramNode = sig.declaration.parameters[i];
                        var name_2 = getParameterName(paramNode, i);
                        var isThisParam = name_2 === 'this';
                        var newTag = {
                            tagName: isThisParam ? 'this' : 'param',
                            optional: paramNode.initializer !== undefined || paramNode.questionToken !== undefined,
                            parameterName: isThisParam ? undefined : name_2,
                        };
                        var type = typeChecker.getTypeAtLocation(paramNode);
                        if (paramNode.dotDotDotToken !== undefined) {
                            newTag.restParam = true;
                            // In TypeScript you write "...x: number[]", but in Closure
                            // you don't write the array: "@param {...number} x".  Unwrap
                            // the Array<> wrapper.
                            var typeRef = type;
                            if (!typeRef.typeArguments)
                                throw new Error('invalid rest param');
                            type = typeRef.typeArguments[0];
                        }
                        newTag.type = this.typeToClosure(fnDecl, type);
                        try {
                            for (var tags_2 = __values(tags), tags_2_1 = tags_2.next(); !tags_2_1.done; tags_2_1 = tags_2.next()) {
                                var _j = tags_2_1.value, tagName = _j.tagName, parameterName = _j.parameterName, text = _j.text;
                                if (tagName === 'param' && parameterName === newTag.parameterName) {
                                    newTag.text = text;
                                    break;
                                }
                            }
                        }
                        catch (e_6_1) { e_6 = { error: e_6_1 }; }
                        finally {
                            try {
                                if (tags_2_1 && !tags_2_1.done && (_e = tags_2.return)) _e.call(tags_2);
                            }
                            finally { if (e_6) throw e_6.error; }
                        }
                        if (!paramTags[i])
                            paramTags.push([]);
                        paramTags[i].push(newTag);
                    }
                    // Return type.
                    if (!isConstructor) {
                        var retType = typeChecker.getReturnTypeOfSignature(sig);
                        var retTypeString = this.typeToClosure(fnDecl, retType);
                        var returnDoc = void 0;
                        try {
                            for (var tags_3 = __values(tags), tags_3_1 = tags_3.next(); !tags_3_1.done; tags_3_1 = tags_3.next()) {
                                var _k = tags_3_1.value, tagName = _k.tagName, text = _k.text;
                                if (tagName === 'return') {
                                    returnDoc = text;
                                    break;
                                }
                            }
                        }
                        catch (e_7_1) { e_7 = { error: e_7_1 }; }
                        finally {
                            try {
                                if (tags_3_1 && !tags_3_1.done && (_f = tags_3.return)) _f.call(tags_3);
                            }
                            finally { if (e_7) throw e_7.error; }
                        }
                        returnTags.push({
                            tagName: 'return',
                            type: retTypeString,
                            text: returnDoc,
                        });
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (fnDecls_1_1 && !fnDecls_1_1.done && (_b = fnDecls_1.return)) _b.call(fnDecls_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
            var newDoc = Array.from(tagsByName.values());
            if (typeParameterNames.size > 0) {
                newDoc.push({ tagName: 'template', text: Array.from(typeParameterNames.values()).join(', ') });
            }
            // Merge the JSDoc tags for each overloaded parameter.
            // Ensure each parameter has a unique name; the merging process can otherwise
            // accidentally generate the same parameter name twice.
            var paramNames = new Set();
            var foundOptional = false;
            for (var i = 0; i < maxArgsCount; i++) {
                var paramTag = jsdoc.merge(paramTags[i]);
                if (paramNames.has(paramTag.parameterName)) {
                    paramTag.parameterName += i.toString();
                }
                paramNames.add(paramTag.parameterName);
                // If the tag is optional, mark parameters following optional as optional,
                // even if they are not, since Closure restricts this, see
                // https://github.com/google/closure-compiler/issues/2314
                if (!paramTag.restParam && (paramTag.optional || foundOptional || i >= minArgsCount)) {
                    foundOptional = true;
                    paramTag.optional = true;
                }
                newDoc.push(paramTag);
                if (paramTag.restParam) {
                    // Cannot have any parameters after a rest param.
                    // Just dump the remaining parameters.
                    break;
                }
            }
            // Merge the JSDoc tags for each overloaded return.
            if (!isConstructor) {
                newDoc.push(jsdoc.merge(returnTags));
            }
            return [newDoc, newDoc.filter(function (t) { return t.tagName === 'param'; }).map(function (t) { return t.parameterName; })];
        };
        return ModuleTypeTranslator;
    }());
    exports.ModuleTypeTranslator = ModuleTypeTranslator;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kdWxlX3R5cGVfdHJhbnNsYXRvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9tb2R1bGVfdHlwZV90cmFuc2xhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBRUg7Ozs7T0FJRztJQUVILG1EQUEyQztJQUMzQyx5Q0FBaUM7SUFFakMsaUVBQTRJO0lBQzVJLDREQUFvRDtJQUNwRCwyQ0FBbUM7SUFFbkM7OztPQUdHO0lBQ0g7UUFDRSxzQkFDWSxJQUFhLEVBQVUsYUFBeUMsRUFDakUsSUFBaUI7WUFEaEIsU0FBSSxHQUFKLElBQUksQ0FBUztZQUFVLGtCQUFhLEdBQWIsYUFBYSxDQUE0QjtZQUNqRSxTQUFJLEdBQUosSUFBSSxDQUFhO1FBQUcsQ0FBQztRQUVoQyxvQ0FBYSxHQUFiLFVBQWMsZUFBNkI7WUFDekMsSUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLHVCQUF1QixDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsZUFBZSxDQUFDLENBQUM7WUFDdkUsSUFBSSxJQUFJLENBQUMsYUFBYSxFQUFFO2dCQUN0QixJQUFJLENBQUMsSUFBSSxFQUFFO29CQUNULGtDQUFrQztvQkFDbEMsSUFBTSxVQUFRLEdBQUcsRUFBRSxDQUFDLDJCQUEyQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUUsQ0FBQztvQkFDNUQsSUFBTSxHQUFHLEdBQUcsVUFBUSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7b0JBQ2pELFVBQVEsQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO29CQUN4QixJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQztvQkFDMUIsT0FBTztpQkFDUjtnQkFDRCxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7Z0JBQy9CLE9BQU87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Q0FBQyxhQUFhLElBQUksQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDO2lCQUN4QztnQkFDRCxVQUFVLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsQ0FBQztnQkFDdkMsMEVBQTBFO2dCQUMxRSwwREFBMEQ7Z0JBQzFELHlEQUF5RDtnQkFDekQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxJQUFJLGFBQWEsSUFBSSxDQUFDLElBQUksWUFBWSxDQUFDLEVBQUU7b0JBQ3BGLGFBQWEsR0FBRyxJQUFJLENBQUM7b0JBQ3JCLFFBQVEsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO2lCQUMxQjtnQkFDRCxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUN0QixJQUFJLFFBQVEsQ0FBQyxTQUFTLEVBQUU7b0JBQ3RCLGlEQUFpRDtvQkFDakQsc0NBQXNDO29CQUN0QyxNQUFNO2lCQUNQO2FBQ0Y7WUFFRCxtREFBbUQ7WUFDbkQsSUFBSSxDQUFDLGFBQWEsRUFBRTtnQkFDbEIsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7YUFDdEM7WUFFRCxPQUFPLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxNQUFNLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxDQUFDLENBQUMsT0FBTyxLQUFLLE9BQU8sRUFBckIsQ0FBcUIsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFBLENBQUMsSUFBSSxPQUFBLENBQUMsQ0FBQyxhQUFjLEVBQWhCLENBQWdCLENBQUMsQ0FBQyxDQUFDO1FBQ3hGLENBQUM7UUFDSCwyQkFBQztJQUFELENBQUMsQUExYkQsSUEwYkM7SUExYlksb0RBQW9CIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgbW9kdWxlX3R5cGVfdHJhbnNsYXRvciBidWlsZHMgb24gdG9wIG9mIHR5cGVfdHJhbnNsYXRvciwgYWRkaW5nIGZ1bmN0aW9uYWxpdHkgdG9cbiAqIHRyYW5zbGF0ZSB0eXBlcyB3aXRoaW4gdGhlIHNjb3BlIG9mIGEgc2luZ2xlIG1vZHVsZS4gVGhlIG1haW4gZW50cnkgcG9pbnQgaXNcbiAqIE1vZHVsZVR5cGVUcmFuc2xhdG9yLlxuICovXG5cbmltcG9ydCAqIGFzIGdvb2dtb2R1bGUgZnJvbSAnLi9nb29nbW9kdWxlJztcbmltcG9ydCAqIGFzIGpzZG9jIGZyb20gJy4vanNkb2MnO1xuaW1wb3J0IHtBbm5vdGF0b3JIb3N0LCBpc0FtYmllbnR9IGZyb20gJy4vanNkb2NfdHJhbnNmb3JtZXInO1xuaW1wb3J0IHtjcmVhdGVTaW5nbGVRdW90ZVN0cmluZ0xpdGVyYWwsIGdldElkZW50aWZpZXJUZXh0LCBoYXNNb2RpZmllckZsYWcsIHJlcG9ydERlYnVnV2FybmluZywgcmVwb3J0RGlhZ25vc3RpY30gZnJvbSAnLi90cmFuc2Zvcm1lcl91dGlsJztcbmltcG9ydCAqIGFzIHR5cGVUcmFuc2xhdG9yIGZyb20gJy4vdHlwZV90cmFuc2xhdG9yJztcbmltcG9ydCAqIGFzIHRzIGZyb20gJy4vdHlwZXNjcmlwdCc7XG5cbi8qKlxuICogTXV0YWJsZUpTRG9jIGVuY2Fwc3VsYXRlcyBhIChwb3RlbnRpYWwpIEpTRG9jIGNvbW1lbnQgb24gYSBzcGVjaWZpYyBub2RlLCBhbmQgYWxsb3dzIGNvZGUgdG9cbiAqIG1vZGlmeSAoaW5jbHVkaW5nIGRlbGV0ZSkgaXQuXG4gKi9cbmV4cG9ydCBjbGFzcyBNdXRhYmxlSlNEb2Mge1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIHByaXZhdGUgbm9kZTogdHMuTm9kZSwgcHJpdmF0ZSBzb3VyY2VDb21tZW50OiB0cy5TeW50aGVzaXplZENvbW1lbnR8bnVsbCxcbiAgICAgIHB1YmxpYyB0YWdzOiBqc2RvYy5UYWdbXSkge31cblxuICB1cGRhdGVDb21tZW50KGVzY2FwZUV4dHJhVGFncz86IFNldDxzdHJpbmc+KSB7XG4gICAgY29uc3QgdGV4dCA9IGpzZG9jLnRvU3RyaW5nV2l0aG91dFN0YXJ0RW5kKHRoaXMudGFncywgZXNjYXBlRXh0cmFUYWdzKTtcbiAgICBpZiAodGhpcy5zb3VyY2VDb21tZW50KSB7XG4gICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgLy8gRGVsZXRlIHRoZSAobm93IGVtcHR5KSBjb21tZW50LlxuICAgICAgICBjb25zdCBjb21tZW50cyA9IHRzLmdldFN5bnRoZXRpY0xlYWRpbmdDb21tZW50cyh0aGlzLm5vZGUpITtcbiAgICAgICAgY29uc3QgaWR4ID0gY29tbWVudHMuaW5kZXhPZih0aGlzLnNvdXJjZUNvbW1lbnQpO1xuICAgICAgICBjb21tZW50cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgdGhpcy5zb3VyY2VDb21tZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zb3VyY2VDb21tZW50LnRleHQgPSB0ZXh0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERvbid0IGFkZCBhbiBlbXB0eSBjb21tZW50LlxuICAgIGlmICghdGV4dCkgcmV0dXJuO1xuXG4gICAgY29uc3QgY29tbWVudDogdHMuU3ludGhlc2l6ZWRDb21tZW50ID0ge1xuICAgICAga2luZDogdHMuU3ludGF4S2luZC5NdWx0aUxpbmVDb21tZW50VHJpdmlhLFxuICAgICAgdGV4dCxcbiAgICAgIGhhc1RyYWlsaW5nTmV3TGluZTogdHJ1ZSxcbiAgICAgIHBvczogLTEsXG4gICAgICBlbmQ6IC0xLFxuICAgIH07XG4gICAgY29uc3QgY29tbWVudHMgPSB0cy5nZXRTeW50aGV0aWNMZWFkaW5nQ29tbWVudHModGhpcy5ub2RlKSB8fCBbXTtcbiAgICBjb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgIHRzLnNldFN5bnRoZXRpY0xlYWRpbmdDb21tZW50cyh0aGlzLm5vZGUsIGNvbW1lbnRzKTtcbiAgfVxufVxuXG4vKiogUmV0dXJucyB0aGUgQ2xvc3VyZSBuYW1lIG9mIGEgZnVuY3Rpb24gcGFyYW1ldGVyLCBzcGVjaWFsLWNhc2luZyBkZXN0cnVjdHVyaW5nLiAqL1xuZnVuY3Rpb24gZ2V0UGFyYW1ldGVyTmFtZShwYXJhbTogdHMuUGFyYW1ldGVyRGVjbGFyYXRpb24sIGluZGV4OiBudW1iZXIpOiBzdHJpbmcge1xuICBzd2l0Y2ggKHBhcmFtLm5hbWUua2luZCkge1xuICAgIGNhc2UgdHMuU3ludGF4S2luZC5JZGVudGlmaWVyOlxuICAgICAgbGV0IG5hbWUgPSBnZXRJZGVudGlmaWVyVGV4dChwYXJhbS5uYW1lIGFzIHRzLklkZW50aWZpZXIpO1xuICAgICAgLy8gVHlwZVNjcmlwdCBhbGxvd3MgcGFyYW1ldGVycyBuYW1lZCBcImFyZ3VtZW50c1wiLCBidXQgQ2xvc3VyZVxuICAgICAgLy8gZGlzYWxsb3dzIHRoaXMsIGV2ZW4gaW4gZXh0ZXJucy5cbiAgICAgIGlmIChuYW1lID09PSAnYXJndW1lbnRzJykgbmFtZSA9ICd0c2lja2xlX2FyZ3VtZW50cyc7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICBjYXNlIHRzLlN5bnRheEtpbmQuQXJyYXlCaW5kaW5nUGF0dGVybjpcbiAgICBjYXNlIHRzLlN5bnRheEtpbmQuT2JqZWN0QmluZGluZ1BhdHRlcm46XG4gICAgICAvLyBDbG9zdXJlIGNyYXNoZXMgaWYgeW91IHB1dCBhIGJpbmRpbmcgcGF0dGVybiBpbiB0aGUgZXh0ZXJucy5cbiAgICAgIC8vIEF2b2lkIHRoaXMgYnkganVzdCBnZW5lcmF0aW5nIGFuIHVudXNlZCBuYW1lOyB0aGUgbmFtZSBpc1xuICAgICAgLy8gaWdub3JlZCBhbnl3YXkuXG4gICAgICByZXR1cm4gYF9fJHtpbmRleH1gO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBUaGUgYWJvdmUgbGlzdCBvZiBraW5kcyBpcyBleGhhdXN0aXZlLiAgcGFyYW0ubmFtZSBpcyAnbmV2ZXInIGF0IHRoaXMgcG9pbnQuXG4gICAgICBjb25zdCBwYXJhbU5hbWUgPSBwYXJhbS5uYW1lIGFzIHRzLk5vZGU7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuaGFuZGxlZCBmdW5jdGlvbiBwYXJhbWV0ZXIga2luZDogJHt0cy5TeW50YXhLaW5kW3BhcmFtTmFtZS5raW5kXX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIE1vZHVsZVR5cGVUcmFuc2xhdG9yIGVuY2Fwc3VsYXRlcyBrbm93bGVkZ2UgYW5kIGhlbHBlciBmdW5jdGlvbnMgdG8gdHJhbnNsYXRlIHR5cGVzIGluIHRoZSBzY29wZVxuICogb2YgYSBzcGVjaWZpYyBtb2R1bGUuIFRoaXMgaW5jbHVkZXMgbWFuYWdpbmcgQ2xvc3VyZSBmb3J3YXJkIGRlY2xhcmUgc3RhdGVtZW50cyBhbmQgYW55IHN5bWJvbFxuICogYWxpYXNlcyBpbiBzY29wZSBmb3IgYSB3aG9sZSBmaWxlLlxuICovXG5leHBvcnQgY2xhc3MgTW9kdWxlVHlwZVRyYW5zbGF0b3Ige1xuICAvKipcbiAgICogQSBtYXBwaW5nIG9mIGFsaWFzZXMgZm9yIHN5bWJvbHMgaW4gdGhlIGN1cnJlbnQgZmlsZSwgdXNlZCB3aGVuIGVtaXR0aW5nIHR5cGVzLiBUeXBlU2NyaXB0XG4gICAqIGVtaXRzIGltcG9ydGVkIHN5bWJvbHMgd2l0aCB1bnByZWRpY3RhYmxlIHByZWZpeGVzLiBUbyBnZW5lcmF0ZSBjb3JyZWN0IHR5cGUgYW5ub3RhdGlvbnMsXG4gICAqIHRzaWNrbGUgY3JlYXRlcyBpdHMgb3duIGFsaWFzZXMgZm9yIHR5cGVzLCBhbmQgcmVnaXN0ZXJzIHRoZW0gaW4gdGhpcyBtYXAgKHNlZVxuICAgKiBgZW1pdEltcG9ydERlY2xhcmF0aW9uYCBhbmQgYGZvcndhcmREZWNsYXJlKClgIGJlbG93KS4gVGhlIGFsaWFzZXMgYXJlIHRoZW4gdXNlZCB3aGVuIGVtaXR0aW5nXG4gICAqIHR5cGVzLlxuICAgKi9cbiAgc3ltYm9sc1RvQWxpYXNlZE5hbWVzID0gbmV3IE1hcDx0cy5TeW1ib2wsIHN0cmluZz4oKTtcblxuICAvKipcbiAgICogVGhlIHNldCBvZiBtb2R1bGUgc3ltYm9scyBmb3J3YXJkIGRlY2xhcmVkIGluIHRoZSBsb2NhbCBuYW1lc3BhY2UgKHdpdGggZ29vZy5mb3J3YXJEZWNsYXJlKS5cbiAgICpcbiAgICogU3ltYm9scyBub3QgaW1wb3J0ZWQgbXVzdCBiZSBkZWNsYXJlZCwgd2hpY2ggaXMgZG9uZSBieSBhZGRpbmcgZm9yd2FyZCBkZWNsYXJlcyB0b1xuICAgKiBgZXh0cmFJbXBvcnRzYCBiZWxvdy5cbiAgICovXG4gIHByaXZhdGUgZm9yd2FyZERlY2xhcmVkTW9kdWxlcyA9IG5ldyBTZXQ8dHMuU3ltYm9sPigpO1xuICAvKipcbiAgICogVGhlIGxpc3Qgb2YgZ2VuZXJhdGVkIGdvb2cuZm9yd2FyZERlY2xhcmUgc3RhdGVtZW50cyBmb3IgdGhpcyBtb2R1bGUuIFRoZXNlIGFyZSBpbnNlcnRlZCBpbnRvXG4gICAqIHRoZSBtb2R1bGUncyBib2R5IHN0YXRlbWVudHMgYWZ0ZXIgdHJhbnNsYXRpb24uXG4gICAqL1xuICBwcml2YXRlIGZvcndhcmREZWNsYXJlczogdHMuU3RhdGVtZW50W10gPSBbXTtcbiAgLyoqIEEgY291bnRlciB0byBnZW5lcmF0ZSB1bmlxdWUgbmFtZXMgZm9yIGdvb2cuZm9yd2FyZERlY2xhcmUgdmFyaWFibGVzLiAqL1xuICBwcml2YXRlIGZvcndhcmREZWNsYXJlQ291bnRlciA9IDA7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgICBwdWJsaWMgc291cmNlRmlsZTogdHMuU291cmNlRmlsZSxcbiAgICAgIHB1YmxpYyB0eXBlQ2hlY2tlcjogdHMuVHlwZUNoZWNrZXIsXG4gICAgICBwcml2YXRlIGhvc3Q6IEFubm90YXRvckhvc3QsXG4gICAgICBwcml2YXRlIGRpYWdub3N0aWNzOiB0cy5EaWFnbm9zdGljW10sXG4gICAgICBwcml2YXRlIGlzRm9yRXh0ZXJuczogYm9vbGVhbixcbiAgKSB7fVxuXG4gIGRlYnVnV2Fybihjb250ZXh0OiB0cy5Ob2RlLCBtZXNzYWdlVGV4dDogc3RyaW5nKSB7XG4gICAgcmVwb3J0RGVidWdXYXJuaW5nKHRoaXMuaG9zdCwgY29udGV4dCwgbWVzc2FnZVRleHQpO1xuICB9XG5cbiAgZXJyb3Iobm9kZTogdHMuTm9kZSwgbWVzc2FnZVRleHQ6IHN0cmluZykge1xuICAgIHJlcG9ydERpYWdub3N0aWModGhpcy5kaWFnbm9zdGljcywgbm9kZSwgbWVzc2FnZVRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBUeXBlU2NyaXB0IHRzLlR5cGUgaW50byB0aGUgZXF1aXZhbGVudCBDbG9zdXJlIHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSBjb250ZXh0IFRoZSB0cy5Ob2RlIGNvbnRhaW5pbmcgdGhlIHR5cGUgcmVmZXJlbmNlOyB1c2VkIGZvciByZXNvbHZpbmcgc3ltYm9sc1xuICAgKiAgICAgaW4gY29udGV4dC5cbiAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgdG8gdHJhbnNsYXRlOyBpZiBub3QgcHJvdmlkZWQsIHRoZSBOb2RlJ3MgdHlwZSB3aWxsIGJlIHVzZWQuXG4gICAqIEBwYXJhbSByZXNvbHZlQWxpYXMgSWYgdHJ1ZSwgZG8gbm90IGVtaXQgYWxpYXNlcyBhcyB0aGVpciBzeW1ib2wsIGJ1dCByYXRoZXIgYXMgdGhlIHJlc29sdmVkXG4gICAqICAgICB0eXBlIHVuZGVybHlpbmcgdGhlIGFsaWFzLiBUaGlzIHNob3VsZCBiZSB0cnVlIG9ubHkgd2hlbiBlbWl0dGluZyB0aGUgdHlwZWRlZiBpdHNlbGYuXG4gICAqL1xuICB0eXBlVG9DbG9zdXJlKGNvbnRleHQ6IHRzLk5vZGUsIHR5cGU/OiB0cy5UeXBlKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy5ob3N0LnVudHlwZWQpIHtcbiAgICAgIHJldHVybiAnPyc7XG4gICAgfVxuXG4gICAgY29uc3QgdHlwZUNoZWNrZXIgPSB0aGlzLnR5cGVDaGVja2VyO1xuICAgIGlmICghdHlwZSkge1xuICAgICAgdHlwZSA9IHR5cGVDaGVja2VyLmdldFR5cGVBdExvY2F0aW9uKGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5uZXdUeXBlVHJhbnNsYXRvcihjb250ZXh0KS50cmFuc2xhdGUodHlwZSk7XG4gIH1cblxuICBuZXdUeXBlVHJhbnNsYXRvcihjb250ZXh0OiB0cy5Ob2RlKSB7XG4gICAgLy8gSW4gZXh0ZXJucywgdGhlcmUgaXMgbm8gbG9jYWwgc2NvcGUsIHNvIGFsbCB0eXBlcyBtdXN0IGJlIHJlbGF0aXZlIHRvIHRoZSBmaWxlIGxldmVsIHNjb3BlLlxuICAgIGNvbnN0IHRyYW5zbGF0aW9uQ29udGV4dCA9IHRoaXMuaXNGb3JFeHRlcm5zID8gdGhpcy5zb3VyY2VGaWxlIDogY29udGV4dDtcblxuICAgIGNvbnN0IHRyYW5zbGF0b3IgPSBuZXcgdHlwZVRyYW5zbGF0b3IuVHlwZVRyYW5zbGF0b3IoXG4gICAgICAgIHRoaXMuaG9zdCwgdGhpcy50eXBlQ2hlY2tlciwgdHJhbnNsYXRpb25Db250ZXh0LCB0aGlzLmhvc3QudHlwZUJsYWNrTGlzdFBhdGhzLFxuICAgICAgICB0aGlzLnN5bWJvbHNUb0FsaWFzZWROYW1lcywgKHN5bTogdHMuU3ltYm9sKSA9PiB0aGlzLmVuc3VyZVN5bWJvbERlY2xhcmVkKHN5bSkpO1xuICAgIHRyYW5zbGF0b3IuaXNGb3JFeHRlcm5zID0gdGhpcy5pc0ZvckV4dGVybnM7XG4gICAgdHJhbnNsYXRvci53YXJuID0gbXNnID0+IHRoaXMuZGVidWdXYXJuKGNvbnRleHQsIG1zZyk7XG4gICAgcmV0dXJuIHRyYW5zbGF0b3I7XG4gIH1cblxuICBpc0JsYWNrTGlzdGVkKGNvbnRleHQ6IHRzLk5vZGUpIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy50eXBlQ2hlY2tlci5nZXRUeXBlQXRMb2NhdGlvbihjb250ZXh0KTtcbiAgICBsZXQgc3ltID0gdHlwZS5zeW1ib2w7XG4gICAgaWYgKCFzeW0pIHJldHVybiBmYWxzZTtcbiAgICBpZiAoc3ltLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuQWxpYXMpIHtcbiAgICAgIHN5bSA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0QWxpYXNlZFN5bWJvbChzeW0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5uZXdUeXBlVHJhbnNsYXRvcihjb250ZXh0KS5pc0JsYWNrTGlzdGVkKHN5bSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB0cy5TeW1ib2wgYXQgYSBsb2NhdGlvbiBvciB0aHJvdy5cbiAgICogVGhlIFR5cGVTY3JpcHQgQVBJIGNhbiByZXR1cm4gdW5kZWZpbmVkIHdoZW4gZmV0Y2hpbmcgYSBzeW1ib2wsIGJ1dCBpbiBtYW55IGNvbnRleHRzIHdlIGtub3cgaXRcbiAgICogd29uJ3QgKGUuZy4gb3VyIGlucHV0IGlzIGFscmVhZHkgdHlwZS1jaGVja2VkKS5cbiAgICovXG4gIG11c3RHZXRTeW1ib2xBdExvY2F0aW9uKG5vZGU6IHRzLk5vZGUpOiB0cy5TeW1ib2wge1xuICAgIGNvbnN0IHN5bSA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihub2RlKTtcbiAgICBpZiAoIXN5bSkgdGhyb3cgbmV3IEVycm9yKCdubyBzeW1ib2wnKTtcbiAgICByZXR1cm4gc3ltO1xuICB9XG5cbiAgLyoqIEZpbmRzIGFuIGV4cG9ydGVkIChpLmUuIG5vdCBnbG9iYWwpIGRlY2xhcmF0aW9uIGZvciB0aGUgZ2l2ZW4gc3ltYm9sLiAqL1xuICBwcm90ZWN0ZWQgZmluZEV4cG9ydGVkRGVjbGFyYXRpb24oc3ltOiB0cy5TeW1ib2wpOiB0cy5EZWNsYXJhdGlvbnx1bmRlZmluZWQge1xuICAgIC8vIFRPRE8obWFydGlucHJvYnN0KTogaXQncyB1bmNsZWFyIHdoZW4gYSBzeW1ib2wgd291bGRuJ3QgaGF2ZSBhIGRlY2xhcmF0aW9uLCBtYXliZSBqdXN0IGZvclxuICAgIC8vIHNvbWUgYnVpbHRpbnMgKGUuZy4gU3ltYm9sKT9cbiAgICBpZiAoIXN5bS5kZWNsYXJhdGlvbnMgfHwgc3ltLmRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDApIHJldHVybiB1bmRlZmluZWQ7XG4gICAgLy8gQSBzeW1ib2wgZGVjbGFyZWQgaW4gdGhpcyBmaWxlIGRvZXMgbm90IG5lZWQgdG8gYmUgaW1wb3J0ZWQuXG4gICAgaWYgKHN5bS5kZWNsYXJhdGlvbnMuc29tZShkID0+IGQuZ2V0U291cmNlRmlsZSgpID09PSB0aGlzLnNvdXJjZUZpbGUpKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgLy8gRmluZCBhbiBleHBvcnRlZCBkZWNsYXJhdGlvbi5cbiAgICAvLyBCZWNhdXNlIHRzaWNrbGUgcnVucyB3aXRoIHRoZSAtLWRlY2xhcmF0aW9uIGZsYWcsIGFsbCB0eXBlcyByZWZlcmVuY2VkIGZyb20gZXhwb3J0ZWQgdHlwZXNcbiAgICAvLyBtdXN0IGJlIGV4cG9ydGVkLCB0b28sIHNvIHRoZXJlIG11c3QgZWl0aGVyIGJlIHNvbWUgZGVjbGFyYXRpb24gdGhhdCBpcyBleHBvcnRlZCwgb3IgdGhlXG4gICAgLy8gc3ltYm9sIGlzIGFjdHVhbGx5IGEgZ2xvYmFsIGRlY2xhcmF0aW9uIChkZWNsYXJlZCBpbiBhIHNjcmlwdCBmaWxlLCBub3QgYSBtb2R1bGUpLlxuICAgIGNvbnN0IGRlY2wgPSBzeW0uZGVjbGFyYXRpb25zLmZpbmQoZCA9PiB7XG4gICAgICAvLyBDaGVjayBmb3IgRXhwb3J0IHwgRGVmYXVsdCAoZGVmYXVsdCBiZWluZyBhIGRlZmF1bHQgZXhwb3J0KS5cbiAgICAgIGlmICghaGFzTW9kaWZpZXJGbGFnKGQsIHRzLk1vZGlmaWVyRmxhZ3MuRXhwb3J0RGVmYXVsdCkpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIEV4Y2x1ZGUgc3ltYm9scyBkZWNsYXJlZCBpbiBgZGVjbGFyZSBnbG9iYWwgey4uLn1gIGJsb2NrcywgdGhleSBhcmUgZ2xvYmFsIGFuZCBkb24ndCBuZWVkXG4gICAgICAvLyBpbXBvcnRzLlxuICAgICAgbGV0IGN1cnJlbnQ6IHRzLk5vZGV8dW5kZWZpbmVkID0gZDtcbiAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgIGlmIChjdXJyZW50LmZsYWdzICYgdHMuTm9kZUZsYWdzLkdsb2JhbEF1Z21lbnRhdGlvbikgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVjbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgY29uc3QgeCA9IGdvb2cuZm9yd2FyZERlY2xhcmUuLi5gIHRleHQgZm9yIGFuIGltcG9ydCBvZiB0aGUgZ2l2ZW4gYGltcG9ydFBhdGhgLlxuICAgKiBUaGlzIGFsc28gcmVnaXN0ZXJzIGFsaWFzZXMgZm9yIHN5bWJvbHMgZnJvbSB0aGUgbW9kdWxlIHRoYXQgbWFwIHRvIHRoaXMgZm9yd2FyZCBkZWNsYXJlLlxuICAgKi9cbiAgZm9yd2FyZERlY2xhcmUoXG4gICAgICBpbXBvcnRQYXRoOiBzdHJpbmcsIG1vZHVsZVN5bWJvbDogdHMuU3ltYm9sLCBpc0V4cGxpY2l0SW1wb3J0OiBib29sZWFuLFxuICAgICAgaXNEZWZhdWx0SW1wb3J0ID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5ob3N0LnVudHlwZWQpIHJldHVybjtcbiAgICAvLyBBbHJlYWR5IGltcG9ydGVkPyBEbyBub3QgZW1pdCBhIGR1cGxpY2F0ZSBmb3J3YXJkIGRlY2xhcmUuXG4gICAgaWYgKHRoaXMuZm9yd2FyZERlY2xhcmVkTW9kdWxlcy5oYXMobW9kdWxlU3ltYm9sKSkgcmV0dXJuO1xuICAgIGNvbnN0IG5zSW1wb3J0ID0gZ29vZ21vZHVsZS5leHRyYWN0R29vZ05hbWVzcGFjZUltcG9ydChpbXBvcnRQYXRoKTtcbiAgICBjb25zdCBmb3J3YXJkRGVjbGFyZVByZWZpeCA9IGB0c2lja2xlX2ZvcndhcmRfZGVjbGFyZV8keysrdGhpcy5mb3J3YXJkRGVjbGFyZUNvdW50ZXJ9YDtcbiAgICBjb25zdCBtb2R1bGVOYW1lc3BhY2UgPSBuc0ltcG9ydCAhPT0gbnVsbCA/XG4gICAgICAgIG5zSW1wb3J0IDpcbiAgICAgICAgdGhpcy5ob3N0LnBhdGhUb01vZHVsZU5hbWUodGhpcy5zb3VyY2VGaWxlLmZpbGVOYW1lLCBpbXBvcnRQYXRoKTtcblxuICAgIC8vIEluIFR5cGVTY3JpcHQsIGltcG9ydGluZyBhIG1vZHVsZSBmb3IgdXNlIGluIGEgdHlwZSBhbm5vdGF0aW9uIGRvZXMgbm90IGNhdXNlIGEgcnVudGltZSBsb2FkLlxuICAgIC8vIEluIENsb3N1cmUgQ29tcGlsZXIsIGdvb2cucmVxdWlyZSdpbmcgYSBtb2R1bGUgY2F1c2VzIGEgcnVudGltZSBsb2FkLCBzbyBlbWl0dGluZyByZXF1aXJlc1xuICAgIC8vIGhlcmUgd291bGQgY2F1c2UgYSBjaGFuZ2UgaW4gbG9hZCBvcmRlciwgd2hpY2ggaXMgb2JzZXJ2YWJsZSAoYW5kIGNhbiBsZWFkIHRvIGVycm9ycykuXG4gICAgLy8gSW5zdGVhZCwgZ29vZy5mb3J3YXJkRGVjbGFyZSB0eXBlcywgd2hpY2ggYWxsb3dzIHVzaW5nIHRoZW0gaW4gdHlwZSBhbm5vdGF0aW9ucyB3aXRob3V0XG4gICAgLy8gY2F1c2luZyBhIGxvYWQuIFNlZSBiZWxvdyBmb3IgdGhlIGV4Y2VwdGlvbiB0byB0aGUgcnVsZS5cbiAgICAvLyBjb25zdCBmb3J3YXJkRGVjbGFyZVByZWZpeCA9IGdvb2cuZm9yd2FyZERlY2xhcmUobW9kdWxlTmFtZXNwYWNlKVxuICAgIHRoaXMuZm9yd2FyZERlY2xhcmVzLnB1c2godHMuY3JlYXRlVmFyaWFibGVTdGF0ZW1lbnQoXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdHMuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbkxpc3QoXG4gICAgICAgICAgICBbdHMuY3JlYXRlVmFyaWFibGVEZWNsYXJhdGlvbihcbiAgICAgICAgICAgICAgICBmb3J3YXJkRGVjbGFyZVByZWZpeCwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHRzLmNyZWF0ZUNhbGwoXG4gICAgICAgICAgICAgICAgICAgIHRzLmNyZWF0ZVByb3BlcnR5QWNjZXNzKHRzLmNyZWF0ZUlkZW50aWZpZXIoJ2dvb2cnKSwgJ2ZvcndhcmREZWNsYXJlJyksXG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgW3RzLmNyZWF0ZUxpdGVyYWwobW9kdWxlTmFtZXNwYWNlKV0pKV0sXG4gICAgICAgICAgICB0cy5Ob2RlRmxhZ3MuQ29uc3QpKSk7XG4gICAgdGhpcy5mb3J3YXJkRGVjbGFyZWRNb2R1bGVzLmFkZChtb2R1bGVTeW1ib2wpO1xuICAgIGNvbnN0IGV4cG9ydHMgPSB0aGlzLnR5cGVDaGVja2VyLmdldEV4cG9ydHNPZk1vZHVsZShtb2R1bGVTeW1ib2wpLm1hcChlID0+IHtcbiAgICAgIGlmIChlLmZsYWdzICYgdHMuU3ltYm9sRmxhZ3MuQWxpYXMpIHtcbiAgICAgICAgZSA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0QWxpYXNlZFN5bWJvbChlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuICAgIGNvbnN0IGhhc1ZhbHVlcyA9IGV4cG9ydHMuc29tZShlID0+IHtcbiAgICAgIGNvbnN0IGlzVmFsdWUgPSAoZS5mbGFncyAmIHRzLlN5bWJvbEZsYWdzLlZhbHVlKSAhPT0gMDtcbiAgICAgIGNvbnN0IGlzQ29uc3RFbnVtID0gKGUuZmxhZ3MgJiB0cy5TeW1ib2xGbGFncy5Db25zdEVudW0pICE9PSAwO1xuICAgICAgLy8gY29uc3QgZW51bXMgYXJlIGlubGluZWQgYnkgVHlwZVNjcmlwdCAoaWYgcHJlc2VydmVDb25zdEVudW1zPWZhbHNlKSwgc28gdGhlcmUgaXMgbmV2ZXIgYVxuICAgICAgLy8gdmFsdWUgaW1wb3J0IGdlbmVyYXRlZCBmb3IgdGhlbS4gVGhhdCBtZWFucyBmb3IgdGhlIHB1cnBvc2Ugb2YgZm9yY2UtaW1wb3J0aW5nIG1vZHVsZXMsXG4gICAgICAvLyB0aGV5IGRvIG5vdCBjb3VudCBhcyB2YWx1ZXMuIElmIHByZXNlcnZlQ29uc3RFbnVtcz10cnVlLCB0aGlzIHNob3VsZG4ndCBodXJ0LlxuICAgICAgcmV0dXJuIGlzVmFsdWUgJiYgIWlzQ29uc3RFbnVtO1xuICAgIH0pO1xuICAgIGlmIChpc0V4cGxpY2l0SW1wb3J0ICYmICFoYXNWYWx1ZXMpIHtcbiAgICAgIC8vIENsb3N1cmUgQ29tcGlsZXIncyB0b29sY2hhaW4gd2lsbCBkcm9wIGZpbGVzIHRoYXQgYXJlIG5ldmVyIGdvb2cucmVxdWlyZSdkICpiZWZvcmUqIHR5cGVcbiAgICAgIC8vIGNoZWNraW5nIChlLmcuIHdoZW4gdXNpbmcgLS1jbG9zdXJlX2VudHJ5X3BvaW50IG9yIHNpbWlsYXIgdG9vbHMpLiBUaGlzIGNhdXNlcyBlcnJvcnNcbiAgICAgIC8vIGNvbXBsYWluaW5nIGFib3V0IHZhbHVlcyBub3QgbWF0Y2hpbmcgJ05vUmVzb2x2ZWRUeXBlJywgb3IgbW9kdWxlcyBub3QgaGF2aW5nIGEgY2VydGFpblxuICAgICAgLy8gbWVtYmVyLlxuICAgICAgLy8gVG8gZml4LCBleHBsaWNpdGx5IGdvb2cucmVxdWlyZSgpIG1vZHVsZXMgdGhhdCBvbmx5IGV4cG9ydCB0eXBlcy4gVGhpcyBzaG91bGQgdXN1YWxseSBub3RcbiAgICAgIC8vIGNhdXNlIGJyZWFrYWdlcyBkdWUgdG8gbG9hZCBvcmRlciAoYXMgbm8gc3ltYm9scyBhcmUgYWNjZXNzaWJsZSBmcm9tIHRoZSBtb2R1bGUgLSB0aG91Z2hcbiAgICAgIC8vIGNvbnRyaXZlZCBjb2RlIGNvdWxkIG9ic2VydmUgY2hhbmdlcyBpbiBzaWRlIGVmZmVjdHMpLlxuICAgICAgLy8gVGhpcyBpcyBhIGhldXJpc3RpYyAtIGlmIHRoZSBtb2R1bGUgZXhwb3J0cyBzb21lIHZhbHVlcywgYnV0IHRob3NlIGFyZSBuZXZlciBpbXBvcnRlZCxcbiAgICAgIC8vIHRoZSBmaWxlIHdpbGwgc3RpbGwgZW5kIHVwIG5vdCBiZWluZyBpbXBvcnRlZC4gSG9wZWZ1bGx5IG1vZHVsZXMgdGhhdCBleHBvcnQgdmFsdWVzIGFyZVxuICAgICAgLy8gaW1wb3J0ZWQgZm9yIHRoZWlyIHZhbHVlIGluIHNvbWUgcGxhY2UuXG4gICAgICAvLyBnb29nLnJlcXVpcmUoXCIke21vZHVsZU5hbWVzcGFjZX1cIik7XG4gICAgICBjb25zdCBoYXJkUmVxdWlyZSA9IHRzLmNyZWF0ZVN0YXRlbWVudCh0cy5jcmVhdGVDYWxsKFxuICAgICAgICAgIHRzLmNyZWF0ZVByb3BlcnR5QWNjZXNzKHRzLmNyZWF0ZUlkZW50aWZpZXIoJ2dvb2cnKSwgJ3JlcXVpcmUnKSwgdW5kZWZpbmVkLFxuICAgICAgICAgIFtjcmVhdGVTaW5nbGVRdW90ZVN0cmluZ0xpdGVyYWwobW9kdWxlTmFtZXNwYWNlKV0pKTtcbiAgICAgIGNvbnN0IGNvbW1lbnQ6IHRzLlN5bnRoZXNpemVkQ29tbWVudCA9IHtcbiAgICAgICAga2luZDogdHMuU3ludGF4S2luZC5TaW5nbGVMaW5lQ29tbWVudFRyaXZpYSxcbiAgICAgICAgdGV4dDogJyBmb3JjZSB0eXBlLW9ubHkgbW9kdWxlIHRvIGJlIGxvYWRlZCcsXG4gICAgICAgIGhhc1RyYWlsaW5nTmV3TGluZTogdHJ1ZSxcbiAgICAgICAgcG9zOiAtMSxcbiAgICAgICAgZW5kOiAtMSxcbiAgICAgIH07XG4gICAgICB0cy5zZXRTeW50aGV0aWNUcmFpbGluZ0NvbW1lbnRzKGhhcmRSZXF1aXJlLCBbY29tbWVudF0pO1xuICAgICAgdGhpcy5mb3J3YXJkRGVjbGFyZXMucHVzaChoYXJkUmVxdWlyZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc3ltIG9mIGV4cG9ydHMpIHtcbiAgICAgIC8vIGdvb2c6IGltcG9ydHMgZG9uJ3QgYWN0dWFsbHkgdXNlIHRoZSAuZGVmYXVsdCBwcm9wZXJ0eSB0aGF0IFRTIHRoaW5rcyB0aGV5IGhhdmUuXG4gICAgICBjb25zdCBxdWFsaWZpZWROYW1lID0gbnNJbXBvcnQgJiYgaXNEZWZhdWx0SW1wb3J0ID8gZm9yd2FyZERlY2xhcmVQcmVmaXggOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcndhcmREZWNsYXJlUHJlZml4ICsgJy4nICsgc3ltLm5hbWU7XG4gICAgICB0aGlzLnN5bWJvbHNUb0FsaWFzZWROYW1lcy5zZXQoc3ltLCBxdWFsaWZpZWROYW1lKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgZW5zdXJlU3ltYm9sRGVjbGFyZWQoc3ltOiB0cy5TeW1ib2wpIHtcbiAgICBjb25zdCBkZWNsID0gdGhpcy5maW5kRXhwb3J0ZWREZWNsYXJhdGlvbihzeW0pO1xuICAgIGlmICghZGVjbCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLmlzRm9yRXh0ZXJucykge1xuICAgICAgdGhpcy5lcnJvcihkZWNsLCBgZGVjbGFyYXRpb24gZnJvbSBtb2R1bGUgdXNlZCBpbiBhbWJpZW50IHR5cGU6ICR7c3ltLm5hbWV9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQWN0dWFsbHkgaW1wb3J0IHRoZSBzeW1ib2wuXG4gICAgY29uc3Qgc291cmNlRmlsZSA9IGRlY2wuZ2V0U291cmNlRmlsZSgpO1xuICAgIGlmIChzb3VyY2VGaWxlID09PSB0cy5nZXRPcmlnaW5hbE5vZGUodGhpcy5zb3VyY2VGaWxlKSkgcmV0dXJuO1xuICAgIGNvbnN0IG1vZHVsZVN5bWJvbCA9IHRoaXMudHlwZUNoZWNrZXIuZ2V0U3ltYm9sQXRMb2NhdGlvbihzb3VyY2VGaWxlKTtcbiAgICAvLyBBIHNvdXJjZSBmaWxlIG1pZ2h0IG5vdCBoYXZlIGEgc3ltYm9sIGlmIGl0J3Mgbm90IGEgbW9kdWxlIChubyBFUzYgaW0vZXhwb3J0cykuXG4gICAgaWYgKCFtb2R1bGVTeW1ib2wpIHJldHVybjtcbiAgICAvLyBUT0RPKG1hcnRpbnByb2JzdCk6IHRoaXMgc2hvdWxkIHBvc3NpYmx5IHVzZSBmaWxlTmFtZVRvTW9kdWxlSWQuXG4gICAgdGhpcy5mb3J3YXJkRGVjbGFyZShzb3VyY2VGaWxlLmZpbGVOYW1lLCBtb2R1bGVTeW1ib2wsIGZhbHNlKTtcbiAgfVxuXG4gIGluc2VydEZvcndhcmREZWNsYXJlcyhzb3VyY2VGaWxlOiB0cy5Tb3VyY2VGaWxlKSB7XG4gICAgbGV0IGluc2VydGlvbiA9IDA7XG4gICAgLy8gU2tpcCBvdmVyIGEgbGVhZGluZyBmaWxlIGNvbW1lbnQgaG9sZGVyLlxuICAgIGlmIChzb3VyY2VGaWxlLnN0YXRlbWVudHMubGVuZ3RoICYmXG4gICAgICAgIHNvdXJjZUZpbGUuc3RhdGVtZW50c1swXS5raW5kID09PSB0cy5TeW50YXhLaW5kLk5vdEVtaXR0ZWRTdGF0ZW1lbnQpIHtcbiAgICAgIGluc2VydGlvbisrO1xuICAgIH1cbiAgICByZXR1cm4gdHMudXBkYXRlU291cmNlRmlsZU5vZGUoc291cmNlRmlsZSwgW1xuICAgICAgLi4uc291cmNlRmlsZS5zdGF0ZW1lbnRzLnNsaWNlKDAsIGluc2VydGlvbiksXG4gICAgICAuLi50aGlzLmZvcndhcmREZWNsYXJlcyxcbiAgICAgIC4uLnNvdXJjZUZpbGUuc3RhdGVtZW50cy5zbGljZShpbnNlcnRpb24pLFxuICAgIF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbmQgc3ludGhlc2l6ZXMgY29tbWVudHMgb24gbm9kZSwgYW5kIHJldHVybnMgdGhlIEpTRG9jIGZyb20gaXQsIGlmIGFueS5cbiAgICogQHBhcmFtIHJlcG9ydFdhcm5pbmdzIGlmIHRydWUsIHdpbGwgcmVwb3J0IHdhcm5pbmdzIGZyb20gcGFyc2luZyB0aGUgSlNEb2MuIFNldCB0byBmYWxzZSBpZlxuICAgKiAgICAgdGhpcyBpcyBub3QgdGhlIFwibWFpblwiIGxvY2F0aW9uIGRlYWxpbmcgd2l0aCBhIG5vZGUgdG8gYXZvaWQgZHVwbGljYXRlZCB3YXJuaW5ncy5cbiAgICovXG4gIGdldEpTRG9jKG5vZGU6IHRzLk5vZGUsIHJlcG9ydFdhcm5pbmdzOiBib29sZWFuKToganNkb2MuVGFnW10ge1xuICAgIGNvbnN0IFt0YWdzLCBdID0gdGhpcy5wYXJzZUpTRG9jKG5vZGUsIHJlcG9ydFdhcm5pbmdzKTtcbiAgICByZXR1cm4gdGFncztcbiAgfVxuXG4gIGdldE11dGFibGVKU0RvYyhub2RlOiB0cy5Ob2RlKTogTXV0YWJsZUpTRG9jIHtcbiAgICBjb25zdCBbdGFncywgY29tbWVudF0gPSB0aGlzLnBhcnNlSlNEb2Mobm9kZSwgLyogcmVwb3J0V2FybmluZ3MgKi8gdHJ1ZSk7XG4gICAgcmV0dXJuIG5ldyBNdXRhYmxlSlNEb2Mobm9kZSwgY29tbWVudCwgdGFncyk7XG4gIH1cblxuICBwcml2YXRlIHBhcnNlSlNEb2Mobm9kZTogdHMuTm9kZSwgcmVwb3J0V2FybmluZ3M6IGJvb2xlYW4pOlxuICAgICAgW2pzZG9jLlRhZ1tdLCB0cy5TeW50aGVzaXplZENvbW1lbnR8bnVsbF0ge1xuICAgIC8vIHN5bnRoZXNpemVMZWFkaW5nQ29tbWVudHMgYmVsb3cgY2hhbmdlcyB0ZXh0IGxvY2F0aW9ucyBmb3Igbm9kZSwgc28gZXh0cmFjdCB0aGUgbG9jYXRpb24gaGVyZVxuICAgIC8vIGluIGNhc2UgaXQgaXMgbmVlZGVkIGxhdGVyIHRvIHJlcG9ydCBkaWFnbm9zdGljcy5cbiAgICBjb25zdCBzdGFydCA9IG5vZGUuZ2V0RnVsbFN0YXJ0KCk7XG4gICAgY29uc3QgbGVuZ3RoID0gbm9kZS5nZXRMZWFkaW5nVHJpdmlhV2lkdGgodGhpcy5zb3VyY2VGaWxlKTtcblxuICAgIGNvbnN0IGNvbW1lbnRzID0ganNkb2Muc3ludGhlc2l6ZUxlYWRpbmdDb21tZW50cyhub2RlKTtcbiAgICBpZiAoIWNvbW1lbnRzIHx8IGNvbW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtbXSwgbnVsbF07XG5cbiAgICBmb3IgKGxldCBpID0gY29tbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGNvbW1lbnQgPSBjb21tZW50c1tpXTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IGpzZG9jLnBhcnNlKGNvbW1lbnQpO1xuICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICBpZiAocmVwb3J0V2FybmluZ3MgJiYgcGFyc2VkLndhcm5pbmdzKSB7XG4gICAgICAgICAgY29uc3QgcmFuZ2UgPSBjb21tZW50Lm9yaWdpbmFsUmFuZ2UgfHwge3Bvczogc3RhcnQsIGVuZDogc3RhcnQgKyBsZW5ndGh9O1xuICAgICAgICAgIHJlcG9ydERpYWdub3N0aWMoXG4gICAgICAgICAgICAgIHRoaXMuZGlhZ25vc3RpY3MsIG5vZGUsIHBhcnNlZC53YXJuaW5ncy5qb2luKCdcXG4nKSwgcmFuZ2UsXG4gICAgICAgICAgICAgIHRzLkRpYWdub3N0aWNDYXRlZ29yeS5XYXJuaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3BhcnNlZC50YWdzLCBjb21tZW50XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtbXSwgbnVsbF07XG4gIH1cblxuICBibGFja2xpc3RUeXBlUGFyYW1ldGVycyhcbiAgICAgIGNvbnRleHQ6IHRzLk5vZGUsIGRlY2xzOiBSZWFkb25seUFycmF5PHRzLlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbj58dW5kZWZpbmVkKSB7XG4gICAgdGhpcy5uZXdUeXBlVHJhbnNsYXRvcihjb250ZXh0KS5ibGFja2xpc3RUeXBlUGFyYW1ldGVycyh0aGlzLnN5bWJvbHNUb0FsaWFzZWROYW1lcywgZGVjbHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIGpzZG9jIGZvciBtZXRob2RzLCBpbmNsdWRpbmcgb3ZlcmxvYWRzLlxuICAgKiBJZiBvdmVybG9hZGVkLCBtZXJnZXMgdGhlIHNpZ25hdHVyZXMgaW4gdGhlIGxpc3Qgb2YgU2lnbmF0dXJlRGVjbGFyYXRpb25zIGludG8gYSBzaW5nbGUganNkb2MuXG4gICAqIC0gVG90YWwgbnVtYmVyIG9mIHBhcmFtZXRlcnMgd2lsbCBiZSB0aGUgbWF4aW11bSBjb3VudCBmb3VuZCBhY3Jvc3MgYWxsIHZhcmlhbnRzLlxuICAgKiAtIERpZmZlcmVudCBuYW1lcyBhdCB0aGUgc2FtZSBwYXJhbWV0ZXIgaW5kZXggd2lsbCBiZSBqb2luZWQgd2l0aCBcIl9vcl9cIlxuICAgKiAtIFZhcmlhYmxlIGFyZ3MgKC4uLnR5cGVbXSBpbiBUeXBlU2NyaXB0KSB3aWxsIGJlIG91dHB1dCBhcyBcIi4uLnR5cGVcIixcbiAgICogICAgZXhjZXB0IGlmIGZvdW5kIGF0IHRoZSBzYW1lIGluZGV4IGFzIGFub3RoZXIgYXJndW1lbnQuXG4gICAqIEBwYXJhbSBmbkRlY2xzIFBhc3MgPiAxIGRlY2xhcmF0aW9uIGZvciBvdmVybG9hZHMgb2Ygc2FtZSBuYW1lXG4gICAqIEByZXR1cm4gVGhlIGxpc3Qgb2YgcGFyYW1ldGVyIG5hbWVzIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZW1pdCB0aGUgYWN0dWFsXG4gICAqICAgIGZ1bmN0aW9uIHN0YXRlbWVudDsgZm9yIG92ZXJsb2FkcywgbmFtZSB3aWxsIGhhdmUgYmVlbiBtZXJnZWQuXG4gICAqL1xuICBnZXRGdW5jdGlvblR5cGVKU0RvYyhmbkRlY2xzOiB0cy5TaWduYXR1cmVEZWNsYXJhdGlvbltdLCBleHRyYVRhZ3M6IGpzZG9jLlRhZ1tdID0gW10pOlxuICAgICAgW2pzZG9jLlRhZ1tdLCBzdHJpbmdbXV0ge1xuICAgIGNvbnN0IHR5cGVDaGVja2VyID0gdGhpcy50eXBlQ2hlY2tlcjtcblxuICAgIC8vIERlLWR1cGxpY2F0ZSB0YWdzIGFuZCBkb2NzIGZvdW5kIGZvciB0aGUgZm5EZWNscy5cbiAgICBjb25zdCB0YWdzQnlOYW1lID0gbmV3IE1hcDxzdHJpbmcsIGpzZG9jLlRhZz4oKTtcbiAgICBmdW5jdGlvbiBhZGRUYWcodGFnOiBqc2RvYy5UYWcpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGFnc0J5TmFtZS5nZXQodGFnLnRhZ05hbWUpO1xuICAgICAgdGFnc0J5TmFtZS5zZXQodGFnLnRhZ05hbWUsIGV4aXN0aW5nID8ganNkb2MubWVyZ2UoW2V4aXN0aW5nLCB0YWddKSA6IHRhZyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZXh0cmFUYWcgb2YgZXh0cmFUYWdzKSBhZGRUYWcoZXh0cmFUYWcpO1xuXG4gICAgY29uc3QgbGVucyA9IGZuRGVjbHMubWFwKGZuRGVjbCA9PiBmbkRlY2wucGFyYW1ldGVycy5sZW5ndGgpO1xuICAgIGNvbnN0IG1pbkFyZ3NDb3VudCA9IE1hdGgubWluKC4uLmxlbnMpO1xuICAgIGNvbnN0IG1heEFyZ3NDb3VudCA9IE1hdGgubWF4KC4uLmxlbnMpO1xuICAgIGNvbnN0IGlzQ29uc3RydWN0b3IgPSBmbkRlY2xzLmZpbmQoZCA9PiBkLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuQ29uc3RydWN0b3IpICE9PSB1bmRlZmluZWQ7XG4gICAgLy8gRm9yIGVhY2ggcGFyYW1ldGVyIGluZGV4IGksIHBhcmFtVGFnc1tpXSBpcyBhbiBhcnJheSBvZiBwYXJhbWV0ZXJzXG4gICAgLy8gdGhhdCBjYW4gYmUgZm91bmQgYXQgaW5kZXggaS4gIEUuZy5cbiAgICAvLyAgICBmdW5jdGlvbiBmb28oeDogc3RyaW5nKVxuICAgIC8vICAgIGZ1bmN0aW9uIGZvbyh5OiBudW1iZXIsIHo6IHN0cmluZylcbiAgICAvLyB0aGVuIHBhcmFtVGFnc1swXSA9IFtpbmZvIGFib3V0IHgsIGluZm8gYWJvdXQgeV0uXG4gICAgY29uc3QgcGFyYW1UYWdzOiBqc2RvYy5UYWdbXVtdID0gW107XG4gICAgY29uc3QgcmV0dXJuVGFnczoganNkb2MuVGFnW10gPSBbXTtcbiAgICBjb25zdCB0eXBlUGFyYW1ldGVyTmFtZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAgIGZvciAoY29uc3QgZm5EZWNsIG9mIGZuRGVjbHMpIHtcbiAgICAgIC8vIENvbnN0cnVjdCB0aGUgSlNEb2MgY29tbWVudCBieSByZWFkaW5nIHRoZSBleGlzdGluZyBKU0RvYywgaWZcbiAgICAgIC8vIGFueSwgYW5kIG1lcmdpbmcgaXQgd2l0aCB0aGUga25vd24gdHlwZXMgb2YgdGhlIGZ1bmN0aW9uXG4gICAgICAvLyBwYXJhbWV0ZXJzIGFuZCByZXR1cm4gdHlwZS5cbiAgICAgIGNvbnN0IHRhZ3MgPSB0aGlzLmdldEpTRG9jKGZuRGVjbCwgLyogcmVwb3J0V2FybmluZ3MgKi8gZmFsc2UpO1xuXG4gICAgICAvLyBDb3B5IGFsbCB0aGUgdGFncyBvdGhlciB0aGFuIEBwYXJhbS9AcmV0dXJuIGludG8gdGhlIG5ld1xuICAgICAgLy8gSlNEb2Mgd2l0aG91dCBhbnkgY2hhbmdlOyBAcGFyYW0vQHJldHVybiBhcmUgaGFuZGxlZCBzcGVjaWFsbHkuXG4gICAgICAvLyBUT0RPOiB0aGVyZSBtYXkgYmUgcHJvYmxlbXMgaWYgYW4gYW5ub3RhdGlvbiBkb2Vzbid0IGFwcGx5IHRvIGFsbCBvdmVybG9hZHM7XG4gICAgICAvLyBpcyBpdCB3b3J0aCBjaGVja2luZyBmb3IgdGhpcyBhbmQgZXJyb3Jpbmc/XG4gICAgICBmb3IgKGNvbnN0IHRhZyBvZiB0YWdzKSB7XG4gICAgICAgIGlmICh0YWcudGFnTmFtZSA9PT0gJ3BhcmFtJyB8fCB0YWcudGFnTmFtZSA9PT0gJ3JldHVybicpIGNvbnRpbnVlO1xuICAgICAgICBhZGRUYWcodGFnKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIEBhYnN0cmFjdCBvbiBcImFic3RyYWN0XCIgZGVjbGFyYXRpb25zLlxuICAgICAgaWYgKGhhc01vZGlmaWVyRmxhZyhmbkRlY2wsIHRzLk1vZGlmaWVyRmxhZ3MuQWJzdHJhY3QpKSB7XG4gICAgICAgIGFkZFRhZyh7dGFnTmFtZTogJ2Fic3RyYWN0J30pO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgYW55IEB0ZW1wbGF0ZSB0YWdzLlxuICAgICAgLy8gTXVsdGlwbGUgZGVjbGFyYXRpb25zIHdpdGggdGhlIHNhbWUgdGVtcGxhdGUgdmFyaWFibGUgbmFtZXMgc2hvdWxkIHdvcms6XG4gICAgICAvLyB0aGUgZGVjbGFyYXRpb25zIGdldCB0dXJuZWQgaW50byB1bmlvbiB0eXBlcywgYW5kIENsb3N1cmUgQ29tcGlsZXIgd2lsbCBuZWVkXG4gICAgICAvLyB0byBmaW5kIGEgdW5pb24gd2hlcmUgYWxsIHR5cGUgYXJndW1lbnRzIGFyZSBzYXRpc2ZpZWQuXG4gICAgICBpZiAoZm5EZWNsLnR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgdHAgb2YgZm5EZWNsLnR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgdHlwZVBhcmFtZXRlck5hbWVzLmFkZChnZXRJZGVudGlmaWVyVGV4dCh0cC5uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIE1lcmdlIHRoZSBwYXJhbWV0ZXJzIGludG8gYSBzaW5nbGUgbGlzdCBvZiBtZXJnZWQgbmFtZXMgYW5kIGxpc3Qgb2YgdHlwZXNcbiAgICAgIGNvbnN0IHNpZyA9IHR5cGVDaGVja2VyLmdldFNpZ25hdHVyZUZyb21EZWNsYXJhdGlvbihmbkRlY2wpO1xuICAgICAgaWYgKCFzaWcgfHwgIXNpZy5kZWNsYXJhdGlvbikgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHNpZ25hdHVyZSAke2ZuRGVjbC5uYW1lfWApO1xuICAgICAgaWYgKHNpZy5kZWNsYXJhdGlvbi5raW5kID09PSB0cy5TeW50YXhLaW5kSlNEb2NTaWduYXR1cmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBKU0RvYyBzaWduYXR1cmUgJHtmbkRlY2wubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnLmRlY2xhcmF0aW9uLnBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGFyYW1Ob2RlID0gc2lnLmRlY2xhcmF0aW9uLnBhcmFtZXRlcnNbaV07XG5cbiAgICAgICAgY29uc3QgbmFtZSA9IGdldFBhcmFtZXRlck5hbWUocGFyYW1Ob2RlLCBpKTtcbiAgICAgICAgY29uc3QgaXNUaGlzUGFyYW0gPSBuYW1lID09PSAndGhpcyc7XG5cbiAgICAgICAgY29uc3QgbmV3VGFnOiBqc2RvYy5UYWcgPSB7XG4gICAgICAgICAgdGFnTmFtZTogaXNUaGlzUGFyYW0gPyAndGhpcycgOiAncGFyYW0nLFxuICAgICAgICAgIG9wdGlvbmFsOiBwYXJhbU5vZGUuaW5pdGlhbGl6ZXIgIT09IHVuZGVmaW5lZCB8fCBwYXJhbU5vZGUucXVlc3Rpb25Ub2tlbiAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgIHBhcmFtZXRlck5hbWU6IGlzVGhpc1BhcmFtID8gdW5kZWZpbmVkIDogbmFtZSxcbiAgICAgICAgfTtcblxuICAgICAgICBsZXQgdHlwZSA9IHR5cGVDaGVja2VyLmdldFR5cGVBdExvY2F0aW9uKHBhcmFtTm9kZSk7XG4gICAgICAgIGlmIChwYXJhbU5vZGUuZG90RG90RG90VG9rZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5ld1RhZy5yZXN0UGFyYW0gPSB0cnVlO1xuICAgICAgICAgIC8vIEluIFR5cGVTY3JpcHQgeW91IHdyaXRlIFwiLi4ueDogbnVtYmVyW11cIiwgYnV0IGluIENsb3N1cmVcbiAgICAgICAgICAvLyB5b3UgZG9uJ3Qgd3JpdGUgdGhlIGFycmF5OiBcIkBwYXJhbSB7Li4ubnVtYmVyfSB4XCIuICBVbndyYXBcbiAgICAgICAgICAvLyB0aGUgQXJyYXk8PiB3cmFwcGVyLlxuICAgICAgICAgIGNvbnN0IHR5cGVSZWYgPSB0eXBlIGFzIHRzLlR5cGVSZWZlcmVuY2U7XG4gICAgICAgICAgaWYgKCF0eXBlUmVmLnR5cGVBcmd1bWVudHMpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCByZXN0IHBhcmFtJyk7XG4gICAgICAgICAgdHlwZSA9IHR5cGVSZWYudHlwZUFyZ3VtZW50cyFbMF07XG4gICAgICAgIH1cbiAgICAgICAgbmV3VGFnLnR5cGUgPSB0aGlzLnR5cGVUb0Nsb3N1cmUoZm5EZWNsLCB0eXBlKTtcblxuICAgICAgICBmb3IgKGNvbnN0IHt0YWdOYW1lLCBwYXJhbWV0ZXJOYW1lLCB0ZXh0fSBvZiB0YWdzKSB7XG4gICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdwYXJhbScgJiYgcGFyYW1ldGVyTmFtZSA9PT0gbmV3VGFnLnBhcmFtZXRlck5hbWUpIHtcbiAgICAgICAgICAgIG5ld1RhZy50ZXh0ID0gdGV4dDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmFtVGFnc1tpXSkgcGFyYW1UYWdzLnB1c2goW10pO1xuICAgICAgICBwYXJhbVRhZ3NbaV0ucHVzaChuZXdUYWcpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gdHlwZS5cbiAgICAgIGlmICghaXNDb25zdHJ1Y3Rvcikge1xuICAgICAgICBjb25zdCByZXRUeXBlID0gdHlwZUNoZWNrZXIuZ2V0UmV0dXJuVHlwZU9mU2lnbmF0dXJlKHNpZyk7XG4gICAgICAgIGNvbnN0IHJldFR5cGVTdHJpbmc6IHN0cmluZyA9IHRoaXMudHlwZVRvQ2xvc3VyZShmbkRlY2wsIHJldFR5cGUpO1xuICAgICAgICBsZXQgcmV0dXJuRG9jOiBzdHJpbmd8dW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IHt0YWdOYW1lLCB0ZXh0fSBvZiB0YWdzKSB7XG4gICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdyZXR1cm4nKSB7XG4gICAgICAgICAgICByZXR1cm5Eb2MgPSB0ZXh0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblRhZ3MucHVzaCh7XG4gICAgICAgICAgdGFnTmFtZTogJ3JldHVybicsXG4gICAgICAgICAgdHlwZTogcmV0VHlwZVN0cmluZyxcbiAgICAgICAgICB0ZXh0OiByZXR1cm5Eb2MsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG5ld0RvYyA9IEFycmF5LmZyb20odGFnc0J5TmFtZS52YWx1ZXMoKSk7XG5cbiAgICBpZiAodHlwZVBhcmFtZXRlck5hbWVzLnNpemUgPiAwKSB7XG4gICAgICBuZXdEb2MucHVzaCh7dGFnTmFtZTogJ3RlbXBsYXRlJywgdGV4dDogQXJyYXkuZnJvbSh0eXBlUGFyYW1ldGVyTmFtZXMudmFsdWVzKCkpLmpvaW4oJywgJyl9KTtcbiAgICB9XG5cbiAgICAvLyBNZXJnZSB0aGUgSlNEb2MgdGFncyBmb3IgZWFjaCBvdmVybG9hZGVkIHBhcmFtZXRlci5cbiAgICAvLyBFbnN1cmUgZWFjaCBwYXJhbWV0ZXIgaGFzIGEgdW5pcXVlIG5hbWU7IHRoZSBtZXJnaW5nIHByb2Nlc3MgY2FuIG90aGVyd2lzZVxuICAgIC8vIGFjY2lkZW50YWxseSBnZW5lcmF0ZSB0aGUgc2FtZSBwYXJhbWV0ZXIgbmFtZSB0d2ljZS5cbiAgICBjb25zdCBwYXJhbU5hbWVzID0gbmV3IFNldCgpO1xuICAgIGxldCBmb3VuZE9wdGlvbmFsID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhBcmdzQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcGFyYW1UYWcgPSBqc2RvYy5tZXJnZShwYXJhbVRhZ3NbaV0pO1xuICAgICAgaWYgKHBhcmFtTmFtZXMuaGFzKHBhcmFtVGFnLnBhcmFtZXRlck5hbWUpKSB7XG4gICAgICAgIHBhcmFtVGFnLnBhcmFtZXRlck5hbWUgKz0gaS50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgcGFyYW1OYW1lcy5hZGQocGFyYW1UYWcucGFyYW1ldGVyTmFtZSk7XG4gICAgICAvLyBJZiB0aGUgdGFnIGlzIG9wdGlvbmFsLCBtYXJrIHBhcmFtZXRlcnMgZm9sbG93aW5nIG9wdGlvbmFsIGFzIG9wdGlvbmFsLFxuICAgICAgLy8gZXZlbiBpZiB0aGV5IGFyZSBub3QsIHNpbmNlIENsb3N1cmUgcmVzdHJpY3RzIHRoaXMsIHNlZVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL2lzc3Vlcy8yMzE0XG4gICAgICBpZiAoIXBhcmFtVGFnLnJlc3RQYXJhbSAmJiAocGFyYW1UYWcub3B0aW9uYWwgfHwgZm91bmRPcHRpb25hbCB8fCBpID49IG1pbkFyZ3NDb3VudCkpIHtcbiAgICAgICAgZm91bmRPcHRpb25hbCA9IHRydWU7XG4gICAgICAgIHBhcmFtVGFnLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG5ld0RvYy5wdXNoKHBhcmFtVGFnKTtcbiAgICAgIGlmIChwYXJhbVRhZy5yZXN0UGFyYW0pIHtcbiAgICAgICAgLy8gQ2Fubm90IGhhdmUgYW55IHBhcmFtZXRlcnMgYWZ0ZXIgYSByZXN0IHBhcmFtLlxuICAgICAgICAvLyBKdXN0IGR1bXAgdGhlIHJlbWFpbmluZyBwYXJhbWV0ZXJzLlxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNZXJnZSB0aGUgSlNEb2MgdGFncyBmb3IgZWFjaCBvdmVybG9hZGVkIHJldHVybi5cbiAgICBpZiAoIWlzQ29uc3RydWN0b3IpIHtcbiAgICAgIG5ld0RvYy5wdXNoKGpzZG9jLm1lcmdlKHJldHVyblRhZ3MpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW25ld0RvYywgbmV3RG9jLmZpbHRlcih0ID0+IHQudGFnTmFtZSA9PT0gJ3BhcmFtJykubWFwKHQgPT4gdC5wYXJhbWV0ZXJOYW1lISldO1xuICB9XG59XG4iXX0=