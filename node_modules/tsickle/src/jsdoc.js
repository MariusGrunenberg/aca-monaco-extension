/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("tsickle/src/jsdoc", ["require", "exports", "tsickle/src/typescript"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ts = require("tsickle/src/typescript");
    /**
     * A list of all JSDoc tags allowed by the Closure compiler.
     * The public Closure docs don't list all the tags it allows; this list comes
     * from the compiler source itself.
     * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/parsing/Annotation.java
     * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/parsing/ParserConfig.properties
     */
    var JSDOC_TAGS_WHITELIST = new Set([
        'abstract', 'argument',
        'author', 'consistentIdGenerator',
        'const', 'constant',
        'constructor', 'copyright',
        'define', 'deprecated',
        'desc', 'dict',
        'disposes', 'enhance',
        'enhanceable', 'enum',
        'export', 'expose',
        'extends', 'externs',
        'fileoverview', 'final',
        'hassoydelcall', 'hassoydeltemplate',
        'hidden', 'id',
        'idGenerator', 'ignore',
        'implements', 'implicitCast',
        'inheritDoc', 'interface',
        'jaggerInject', 'jaggerModule',
        'jaggerProvide', 'jaggerProvidePromise',
        'lends', 'license',
        'link', 'meaning',
        'modifies', 'modName',
        'mods', 'ngInject',
        'noalias', 'nocollapse',
        'nocompile', 'nosideeffects',
        'override', 'owner',
        'package', 'param',
        'pintomodule', 'polymerBehavior',
        'preserve', 'preserveTry',
        'private', 'protected',
        'public', 'record',
        'requirecss', 'requires',
        'return', 'returns',
        'see', 'stableIdGenerator',
        'struct', 'suppress',
        'template', 'this',
        'throws', 'type',
        'typedef', 'unrestricted',
        'version', 'wizaction',
        'wizmodule',
    ]);
    /**
     * A list of JSDoc @tags that are never allowed in TypeScript source. These are Closure tags that
     * can be expressed in the TypeScript surface syntax. As tsickle's emit will mangle type names,
     * these will cause Closure Compiler issues and should not be used.
     */
    var JSDOC_TAGS_BLACKLIST = new Set([
        'augments', 'class', 'constructs', 'constructor', 'enum', 'extends', 'field',
        'function', 'implements', 'interface', 'lends', 'namespace', 'private', 'public',
        'record', 'static', 'template', 'this', 'type', 'typedef',
    ]);
    /**
     * A list of JSDoc @tags that might include a {type} after them. Only banned when a type is passed.
     * Note that this does not include tags that carry a non-type system type, e.g. \@suppress.
     */
    var JSDOC_TAGS_WITH_TYPES = new Set([
        'const',
        'export',
        'param',
        'return',
    ]);
    /**
     * parse parses JSDoc out of a comment string.
     * Returns null if comment is not JSDoc.
     */
    // TODO(martinprobst): representing JSDoc as a list of tags is too simplistic. We need functionality
    // such as merging (below), de-duplicating certain tags (@deprecated), and special treatment for
    // others (e.g. @suppress). We should introduce a proper model class with a more suitable data
    // strucure (e.g. a Map<TagName, Values[]>).
    function parse(comment) {
        // TODO(evanm): this is a pile of hacky regexes for now, because we
        // would rather use the better TypeScript implementation of JSDoc
        // parsing.  https://github.com/Microsoft/TypeScript/issues/7393
        if (comment.kind !== ts.SyntaxKind.MultiLineCommentTrivia)
            return null;
        // comment.text does not include /* and */, so must start with '*' for JSDoc.
        if (comment.text[0] !== '*')
            return null;
        var text = comment.text.substring(1).trim();
        return parseContents(text);
    }
    exports.parse = parse;
    /**
     * Returns the input string with line endings normalized to '\n'.
     */
    function normalizeLineEndings(input) {
        return input.replace(/\r\n/g, '\n');
    }
    exports.normalizeLineEndings = normalizeLineEndings;
    /**
     * parseContents parses JSDoc out of a comment text.
     * Returns null if comment is not JSDoc.
     *
     * @param commentText a comment's text content, i.e. the comment w/o /* and * /.
     */
    function parseContents(commentText) {
        var e_1, _a, _b, _c;
        // Make sure we have proper line endings before parsing on Windows.
        commentText = normalizeLineEndings(commentText);
        // Strip all the " * " bits from the front of each line.
        commentText = commentText.replace(/^\s*\*? ?/gm, '');
        var lines = commentText.split('\n');
        var tags = [];
        var warnings = [];
        try {
            for (var lines_1 = __values(lines), lines_1_1 = lines_1.next(); !lines_1_1.done; lines_1_1 = lines_1.next()) {
                var line = lines_1_1.value;
                var match = line.match(/^\s*@(\S+) *(.*)/);
                if (match) {
                    var _d = __read(match, 3), _ = _d[0], tagName = _d[1], text = _d[2];
                    if (tagName === 'returns') {
                        // A synonym for 'return'.
                        tagName = 'return';
                    }
                    var type = void 0;
                    if (JSDOC_TAGS_BLACKLIST.has(tagName)) {
                        warnings.push("@" + tagName + " annotations are redundant with TypeScript equivalents");
                        continue; // Drop the tag so Closure won't process it.
                    }
                    else if (JSDOC_TAGS_WITH_TYPES.has(tagName) && text[0] === '{') {
                        warnings.push("the type annotation on @" + tagName + " is redundant with its TypeScript type, " +
                            "remove the {...} part");
                        continue;
                    }
                    else if (tagName === 'suppress') {
                        var suppressMatch = text.match(/^\{(.*)\}(.*)$/);
                        if (!suppressMatch) {
                            warnings.push("malformed @suppress tag: \"" + text + "\"");
                        }
                        else {
                            _b = __read(suppressMatch, 3), type = _b[1], text = _b[2];
                        }
                    }
                    else if (tagName === 'dict') {
                        warnings.push('use index signatures (`[k: string]: type`) instead of @dict');
                        continue;
                    }
                    // Grab the parameter name from @param tags.
                    var parameterName = void 0;
                    if (tagName === 'param') {
                        match = text.match(/^(\S+) ?(.*)/);
                        if (match)
                            _c = __read(match, 3), _ = _c[0], parameterName = _c[1], text = _c[2];
                    }
                    var tag = { tagName: tagName };
                    if (parameterName)
                        tag.parameterName = parameterName;
                    if (text)
                        tag.text = text;
                    if (type)
                        tag.type = type;
                    tags.push(tag);
                }
                else {
                    // Text without a preceding @tag on it is either the plain text
                    // documentation or a continuation of a previous tag.
                    if (tags.length === 0) {
                        tags.push({ tagName: '', text: line });
                    }
                    else {
                        var lastTag = tags[tags.length - 1];
                        lastTag.text = (lastTag.text || '') + '\n' + line;
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (lines_1_1 && !lines_1_1.done && (_a = lines_1.return)) _a.call(lines_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (warnings.length > 0) {
            return { tags: tags, warnings: warnings };
        }
        return { tags: tags };
    }
    exports.parseContents = parseContents;
    /**
     * Serializes a Tag into a string usable in a comment.
     * Returns a string like " @foo {bar} baz" (note the whitespace).
     */
    function tagToString(tag, escapeExtraTags) {
        if (escapeExtraTags === void 0) { escapeExtraTags = new Set(); }
        var out = '';
        if (tag.tagName) {
            if (!JSDOC_TAGS_WHITELIST.has(tag.tagName) || escapeExtraTags.has(tag.tagName)) {
                // Escape tags we don't understand.  This is a subtle
                // compromise between multiple issues.
                // 1) If we pass through these non-Closure tags, the user will
                //    get a warning from Closure, and the point of tsickle is
                //    to insulate the user from Closure.
                // 2) The output of tsickle is for Closure but also may be read
                //    by humans, for example non-TypeScript users of Angular.
                // 3) Finally, we don't want to warn because users should be
                //    free to add whichever JSDoc they feel like.  If the user
                //    wants help ensuring they didn't typo a tag, that is the
                //    responsibility of a linter.
                out += " \\@" + tag.tagName;
            }
            else {
                out += " @" + tag.tagName;
            }
        }
        if (tag.type) {
            out += ' {';
            if (tag.restParam) {
                out += '...';
            }
            out += tag.type;
            if (tag.optional) {
                out += '=';
            }
            out += '}';
        }
        if (tag.parameterName) {
            out += ' ' + tag.parameterName;
        }
        if (tag.text) {
            out += ' ' + tag.text.replace(/@/g, '\\@');
        }
        return out;
    }
    /** Tags that must only occur onces in a comment (filtered below). */
    var SINGLETON_TAGS = new Set(['deprecated']);
    /** Tags that conflict with \@type in Closure Compiler (e.g. \@param). */
    exports.TAGS_CONFLICTING_WITH_TYPE = new Set(['param', 'return']);
    /**
     * synthesizeLeadingComments parses the leading comments of node, converts them
     * to synthetic comments, and makes sure the original text comments do not get
     * emitted by TypeScript.
     */
    function synthesizeLeadingComments(node) {
        var existing = ts.getSyntheticLeadingComments(node);
        if (existing)
            return existing;
        var text = node.getFullText();
        var synthComments = getLeadingCommentRangesSynthesized(text, node.getFullStart());
        if (synthComments.length) {
            ts.setSyntheticLeadingComments(node, synthComments);
            suppressLeadingCommentsRecursively(node);
        }
        return synthComments;
    }
    exports.synthesizeLeadingComments = synthesizeLeadingComments;
    /**
     * parseLeadingCommentRangesSynthesized parses the leading comment ranges out of the given text and
     * converts them to SynthesizedComments.
     * @param offset the offset of text in the source file, e.g. node.getFullStart().
     */
    // VisibleForTesting
    function getLeadingCommentRangesSynthesized(text, offset) {
        if (offset === void 0) { offset = 0; }
        var comments = ts.getLeadingCommentRanges(text, 0) || [];
        return comments.map(function (cr) {
            // Confusingly, CommentRange in TypeScript includes start and end markers, but
            // SynthesizedComments do not.
            var commentText = cr.kind === ts.SyntaxKind.SingleLineCommentTrivia ?
                text.substring(cr.pos + 2, cr.end) :
                text.substring(cr.pos + 2, cr.end - 2);
            return __assign({}, cr, { text: commentText, pos: -1, end: -1, originalRange: { pos: cr.pos + offset, end: cr.end + offset } });
        });
    }
    exports.getLeadingCommentRangesSynthesized = getLeadingCommentRangesSynthesized;
    /**
     * suppressCommentsRecursively prevents emit of leading comments on node, and any recursive nodes
     * underneath it that start at the same offset.
     */
    function suppressLeadingCommentsRecursively(node) {
        // TypeScript emits leading comments on a node, unless:
        // - the comment was emitted by the parent node
        // - the node has the NoLeadingComments emit flag.
        // However, transformation steps sometimes copy nodes without keeping their emit flags, so just
        // setting NoLeadingComments recursively is not enough, we must also set the text range to avoid
        // the copied node to have comments emitted.
        var originalStart = node.getFullStart();
        var actualStart = node.getStart();
        function suppressCommentsInternal(node) {
            ts.setEmitFlags(node, ts.EmitFlags.NoLeadingComments);
            return !!ts.forEachChild(node, function (child) {
                if (child.pos !== originalStart)
                    return true;
                return suppressCommentsInternal(child);
            });
        }
        suppressCommentsInternal(node);
    }
    exports.suppressLeadingCommentsRecursively = suppressLeadingCommentsRecursively;
    function toSynthesizedComment(tags, escapeExtraTags) {
        return {
            kind: ts.SyntaxKind.MultiLineCommentTrivia,
            text: toStringWithoutStartEnd(tags, escapeExtraTags),
            pos: -1,
            end: -1,
            hasTrailingNewLine: true,
        };
    }
    exports.toSynthesizedComment = toSynthesizedComment;
    /** Serializes a Comment out to a string, but does not include the start and end comment tokens. */
    function toStringWithoutStartEnd(tags, escapeExtraTags) {
        if (escapeExtraTags === void 0) { escapeExtraTags = new Set(); }
        return serialize(tags, false, escapeExtraTags);
    }
    exports.toStringWithoutStartEnd = toStringWithoutStartEnd;
    /** Serializes a Comment out to a string usable in source code. */
    function toString(tags, escapeExtraTags) {
        if (escapeExtraTags === void 0) { escapeExtraTags = new Set(); }
        return serialize(tags, true, escapeExtraTags);
    }
    exports.toString = toString;
    function serialize(tags, includeStartEnd, escapeExtraTags) {
        if (escapeExtraTags === void 0) { escapeExtraTags = new Set(); }
        var e_2, _a;
        if (tags.length === 0)
            return '';
        if (tags.length === 1) {
            var tag = tags[0];
            if ((tag.tagName === 'type' || tag.tagName === 'typedef' || tag.tagName === 'nocollapse') &&
                (!tag.text || !tag.text.match('\n'))) {
                // Special-case one-liner "type" and "nocollapse" tags to fit on one line, e.g.
                //   /** @type {foo} */
                var text = tagToString(tag, escapeExtraTags);
                return includeStartEnd ? "/**" + text + " */" : "*" + text + " ";
            }
            // Otherwise, fall through to the multi-line output.
        }
        var out = includeStartEnd ? '/**\n' : '*\n';
        var emitted = new Set();
        try {
            for (var tags_1 = __values(tags), tags_1_1 = tags_1.next(); !tags_1_1.done; tags_1_1 = tags_1.next()) {
                var tag = tags_1_1.value;
                if (emitted.has(tag.tagName) && SINGLETON_TAGS.has(tag.tagName)) {
                    continue;
                }
                emitted.add(tag.tagName);
                out += ' *';
                // If the tagToString is multi-line, insert " * " prefixes on subsequent lines.
                out += tagToString(tag, escapeExtraTags).split('\n').join('\n * ');
                out += '\n';
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (tags_1_1 && !tags_1_1.done && (_a = tags_1.return)) _a.call(tags_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        out += includeStartEnd ? ' */\n' : ' ';
        return out;
    }
    /** Merges multiple tags (of the same tagName type) into a single unified tag. */
    function merge(tags) {
        var e_3, _a;
        var tagNames = new Set();
        var parameterNames = new Set();
        var types = new Set();
        var texts = new Set();
        // If any of the tags are optional/rest, then the merged output is optional/rest.
        var optional = false;
        var restParam = false;
        try {
            for (var tags_2 = __values(tags), tags_2_1 = tags_2.next(); !tags_2_1.done; tags_2_1 = tags_2.next()) {
                var tag_1 = tags_2_1.value;
                tagNames.add(tag_1.tagName);
                if (tag_1.parameterName !== undefined)
                    parameterNames.add(tag_1.parameterName);
                if (tag_1.type !== undefined)
                    types.add(tag_1.type);
                if (tag_1.text !== undefined)
                    texts.add(tag_1.text);
                if (tag_1.optional)
                    optional = true;
                if (tag_1.restParam)
                    restParam = true;
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (tags_2_1 && !tags_2_1.done && (_a = tags_2.return)) _a.call(tags_2);
            }
            finally { if (e_3) throw e_3.error; }
        }
        if (tagNames.size !== 1) {
            throw new Error("cannot merge differing tags: " + JSON.stringify(tags));
        }
        var tagName = tagNames.values().next().value;
        var parameterName = parameterNames.size > 0 ? Array.from(parameterNames).join('_or_') : undefined;
        var type = types.size > 0 ? Array.from(types).join('|') : undefined;
        var text = texts.size > 0 ? Array.from(texts).join(' / ') : undefined;
        var tag = { tagName: tagName, parameterName: parameterName, type: type, text: text };
        // Note: a param can either be optional or a rest param; if we merged an
        // optional and rest param together, prefer marking it as a rest param.
        if (restParam) {
            tag.restParam = true;
        }
        else if (optional) {
            tag.optional = true;
        }
        return tag;
    }
    exports.merge = merge;
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoianNkb2MuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvanNkb2MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBRUgsMkNBQW1DO0lBc0NuQzs7Ozs7O09BTUc7SUFDSCxJQUFNLG9CQUFvQixHQUFHLElBQUksR0FBRyxDQUFDO1FBQ25DLFVBQVUsRUFBTyxVQUFVO1FBQzNCLFFBQVEsRUFBUyx1QkFBdUI7UUFDeEMsT0FBTyxFQUFVLFVBQVU7UUFDM0IsYUFBYSxFQUFJLFdBQVc7UUFDNUIsUUFBUSxFQUFTLFlBQVk7UUFDN0IsTUFBTSxFQUFXLE1BQU07UUFDdkIsVUFBVSxFQUFPLFNBQVM7UUFDMUIsYUFBYSxFQUFJLE1BQU07UUFDdkIsUUFBUSxFQUFTLFFBQVE7UUFDekIsU0FBUyxFQUFRLFNBQVM7UUFDMUIsY0FBYyxFQUFHLE9BQU87UUFDeEIsZUFBZSxFQUFFLG1CQUFtQjtRQUNwQyxRQUFRLEVBQVMsSUFBSTtRQUNyQixhQUFhLEVBQUksUUFBUTtRQUN6QixZQUFZLEVBQUssY0FBYztRQUMvQixZQUFZLEVBQUssV0FBVztRQUM1QixjQUFjLEVBQUcsY0FBYztRQUMvQixlQUFlLEVBQUUsc0JBQXNCO1FBQ3ZDLE9BQU8sRUFBVSxTQUFTO1FBQzFCLE1BQU0sRUFBVyxTQUFTO1FBQzFCLFVBQVUsRUFBTyxTQUFTO1FBQzFCLE1BQU0sRUFBVyxVQUFVO1FBQzNCLFNBQVMsRUFBUSxZQUFZO1FBQzdCLFdBQVcsRUFBTSxlQUFlO1FBQ2hDLFVBQVUsRUFBTyxPQUFPO1FBQ3hCLFNBQVMsRUFBUSxPQUFPO1FBQ3hCLGFBQWEsRUFBSSxpQkFBaUI7UUFDbEMsVUFBVSxFQUFPLGFBQWE7UUFDOUIsU0FBUyxFQUFRLFdBQVc7UUFDNUIsUUFBUSxFQUFTLFFBQVE7UUFDekIsWUFBWSxFQUFLLFVBQVU7UUFDM0Is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QyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7UUFDdEUsSUFBTSxJQUFJLEdBQUcsS0FBSyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7UUFDeEUsSUFBTSxHQUFHLEdBQVEsRUFBQyxPQUFPLFNBQUEsRUFBRSxhQUFhLGVBQUEsRUFBRSxJQUFJLE1BQUEsRUFBRSxJQUFJLE1BQUEsRUFBQyxDQUFDO1FBQ3RELHdFQUF3RTtRQUN4RSx1RUFBdUU7UUFDdkUsSUFBSSxTQUFTLEVBQUU7WUFDYixHQUFHLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztTQUN0QjthQUFNLElBQUksUUFBUSxFQUFFO1lBQ25CLEdBQUcsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1NBQ3JCO1FBQ0QsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBbENELHNCQWtDQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0ICogYXMgdHMgZnJvbSAnLi90eXBlc2NyaXB0JztcblxuLyoqXG4gKiBUeXBlU2NyaXB0IGhhcyBhbiBBUEkgZm9yIEpTRG9jIGFscmVhZHksIGJ1dCBpdCdzIG5vdCBleHBvc2VkLlxuICogaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy83MzkzXG4gKiBGb3Igbm93IHdlIGNyZWF0ZSB0eXBlcyB0aGF0IGFyZSBzaW1pbGFyIHRvIHRoZWlycyBzbyB0aGF0IG1pZ3JhdGluZ1xuICogdG8gdGhlaXIgQVBJIHdpbGwgYmUgZWFzaWVyLiAgU2VlIGUuZy4gdHMuSlNEb2NUYWcgYW5kIHRzLkpTRG9jQ29tbWVudC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUYWcge1xuICAvKipcbiAgICogdGFnTmFtZSBpcyBlLmcuIFwicGFyYW1cIiBpbiBhbiBAcGFyYW0gZGVjbGFyYXRpb24uICBJdCBpcyB0aGUgZW1wdHkgc3RyaW5nXG4gICAqIGZvciB0aGUgcGxhaW4gdGV4dCBkb2N1bWVudGF0aW9uIHRoYXQgb2NjdXJzIGJlZm9yZSBhbnkgQGZvbyBsaW5lcy5cbiAgICovXG4gIHRhZ05hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIHBhcmFtZXRlck5hbWUgaXMgdGhlIHRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiBwYXJhbWV0ZXIsIGUuZy4gXCJmb29cIlxuICAgKiBpbiBgXFxAcGFyYW0gZm9vIFRoZSBmb28gcGFyYW1gXG4gICAqL1xuICBwYXJhbWV0ZXJOYW1lPzogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHR5cGUgb2YgYSBKU0RvYyBcXEBwYXJhbSwgXFxAdHlwZSBldGMgdGFnLCByZW5kZXJlZCBpbiBjdXJseSBicmFjZXMuXG4gICAqIENhbiBhbHNvIGhvbGQgdGhlIHR5cGUgb2YgYW4gXFxAc3VwcHJlc3MuXG4gICAqL1xuICB0eXBlPzogc3RyaW5nO1xuICAvKiogb3B0aW9uYWwgaXMgdHJ1ZSBmb3Igb3B0aW9uYWwgZnVuY3Rpb24gcGFyYW1ldGVycy4gKi9cbiAgb3B0aW9uYWw/OiBib29sZWFuO1xuICAvKiogcmVzdFBhcmFtIGlzIHRydWUgZm9yIFwiLi4ueDogZm9vW11cIiBmdW5jdGlvbiBwYXJhbWV0ZXJzLiAqL1xuICByZXN0UGFyYW0/OiBib29sZWFuO1xuICAvKipcbiAgICogZGVzdHJ1Y3R1cmluZyBpcyB0cnVlIGZvciBkZXN0cnVjdHVyaW5nIGJpbmQgcGFyYW1ldGVycywgd2hpY2ggcmVxdWlyZVxuICAgKiBub24tbnVsbCBhcmd1bWVudHMgb24gdGhlIENsb3N1cmUgc2lkZS4gIENhbiBsaWtlbHkgcmVtb3ZlIHRoaXNcbiAgICogb25jZSBUeXBlU2NyaXB0IG51bGxhYmxlIHR5cGVzIGFyZSBhdmFpbGFibGUuXG4gICAqL1xuICBkZXN0cnVjdHVyaW5nPzogYm9vbGVhbjtcbiAgLyoqIEFueSByZW1haW5pbmcgdGV4dCBvbiB0aGUgdGFnLCBlLmcuIHRoZSBkZXNjcmlwdGlvbi4gKi9cbiAgdGV4dD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBBIGxpc3Qgb2YgYWxsIEpTRG9jIHRhZ3MgYWxsb3dlZCBieSB0aGUgQ2xvc3VyZSBjb21waWxlci5cbiAqIFRoZSBwdWJsaWMgQ2xvc3VyZSBkb2NzIGRvbid0IGxpc3QgYWxsIHRoZSB0YWdzIGl0IGFsbG93czsgdGhpcyBsaXN0IGNvbWVzXG4gKiBmcm9tIHRoZSBjb21waWxlciBzb3VyY2UgaXRzZWxmLlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL2Jsb2IvbWFzdGVyL3NyYy9jb20vZ29vZ2xlL2phdmFzY3JpcHQvanNjb21wL3BhcnNpbmcvQW5ub3RhdGlvbi5qYXZhXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtY29tcGlsZXIvYmxvYi9tYXN0ZXIvc3JjL2NvbS9nb29nbGUvamF2YXNjcmlwdC9qc2NvbXAvcGFyc2luZy9QYXJzZXJDb25maWcucHJvcGVydGllc1xuICovXG5jb25zdCBKU0RPQ19UQUdTX1dISVRFTElTVCA9IG5ldyBTZXQoW1xuICAnYWJzdHJhY3QnLCAgICAgICdhcmd1bWVudCcsXG4gICdhdXRob3InLCAgICAgICAgJ2NvbnNpc3RlbnRJZEdlbmVyYXRvcicsXG4gICdjb25zdCcsICAgICAgICAgJ2NvbnN0YW50JyxcbiAgJ2NvbnN0cnVjdG9yJywgICAnY29weXJpZ2h0JyxcbiAgJ2RlZmluZScsICAgICAgICAnZGVwcmVjYXRlZCcsXG4gICdkZXNjJywgICAgICAgICAgJ2RpY3QnLFxuICAnZGlzcG9zZXMnLCAgICAgICdlbmhhbmNlJyxcbiAgJ2VuaGFuY2VhYmxlJywgICAnZW51bScsXG4gICdleHBvcnQnLCAgICAgICAgJ2V4cG9zZScsXG4gICdleHRlbmRzJywgICAgICAgJ2V4dGVybnMnLFxuICAnZmlsZW92ZXJ2aWV3JywgICdmaW5hbCcsXG4gICdoYXNzb3lkZWxjYWxsJywgJ2hhc3NveWRlbHRlbXBsYXRlJyxcbiAgJ2hpZGRlbicsICAgICAgICAnaWQnLFxuICAnaWRHZW5lcmF0b3InLCAgICdpZ25vcmUnLFxuICAnaW1wbGVtZW50cycsICAgICdpbXBsaWNpdENhc3QnLFxuICAnaW5oZXJpdERvYycsICAgICdpbnRlcmZhY2UnLFxuICAnamFnZ2VySW5qZWN0JywgICdqYWdnZXJNb2R1bGUnLFxuICAnamFnZ2VyUHJvdmlkZScsICdqYWdnZXJQcm92aWRlUHJvbWlzZScsXG4gICdsZW5kcycsICAgICAgICAgJ2xpY2Vuc2UnLFxuICAnbGluaycsICAgICAgICAgICdtZWFuaW5nJyxcbiAgJ21vZGlmaWVzJywgICAgICAnbW9kTmFtZScsXG4gICdtb2RzJywgICAgICAgICAgJ25nSW5qZWN0JyxcbiAgJ25vYWxpYXMnLCAgICAgICAnbm9jb2xsYXBzZScsXG4gICdub2NvbXBpbGUnLCAgICAgJ25vc2lkZWVmZmVjdHMnLFxuICAnb3ZlcnJpZGUnLCAgICAgICdvd25lcicsXG4gICdwYWNrYWdlJywgICAgICAgJ3BhcmFtJyxcbiAgJ3BpbnRvbW9kdWxlJywgICAncG9seW1lckJlaGF2aW9yJyxcbiAgJ3ByZXNlcnZlJywgICAgICAncHJlc2VydmVUcnknLFxuICAncHJpdmF0ZScsICAgICAgICdwcm90ZWN0ZWQnLFxuICAncHVibGljJywgICAgICAgICdyZWNvcmQnLFxuICAncmVxdWlyZWNzcycsICAgICdyZXF1aXJlcycsXG4gICdyZXR1cm4nLCAgICAgICAgJ3JldHVybnMnLFxuICAnc2VlJywgICAgICAgICAgICdzdGFibGVJZEdlbmVyYXRvcicsXG4gICdzdHJ1Y3QnLCAgICAgICAgJ3N1cHByZXNzJyxcbiAgJ3RlbXBsYXRlJywgICAgICAndGhpcycsXG4gICd0aHJvd3MnLCAgICAgICAgJ3R5cGUnLFxuICAndHlwZWRlZicsICAgICAgICd1bnJlc3RyaWN0ZWQnLFxuICAndmVyc2lvbicsICAgICAgICd3aXphY3Rpb24nLFxuICAnd2l6bW9kdWxlJyxcbl0pO1xuXG4vKipcbiAqIEEgbGlzdCBvZiBKU0RvYyBAdGFncyB0aGF0IGFyZSBuZXZlciBhbGxvd2VkIGluIFR5cGVTY3JpcHQgc291cmNlLiBUaGVzZSBhcmUgQ2xvc3VyZSB0YWdzIHRoYXRcbiAqIGNhbiBiZSBleHByZXNzZWQgaW4gdGhlIFR5cGVTY3JpcHQgc3VyZmFjZSBzeW50YXguIEFzIHRzaWNrbGUncyBlbWl0IHdpbGwgbWFuZ2xlIHR5cGUgbmFtZXMsXG4gKiB0aGVzZSB3aWxsIGNhdXNlIENsb3N1cmUgQ29tcGlsZXIgaXNzdWVzIGFuZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKi9cbmNvbnN0IEpTRE9DX1RBR1NfQkxBQ0tMSVNUID0gbmV3IFNldChbXG4gICdhdWdtZW50cycsICdjbGFzcycsICAgICAgJ2NvbnN0cnVjdHMnLCAnY29uc3RydWN0b3InLCAnZW51bScsICAgICAgJ2V4dGVuZHMnLCAnZmllbGQnLFxuICAnZnVuY3Rpb24nLCAnaW1wbGVtZW50cycsICdpbnRlcmZhY2UnLCAgJ2xlbmRzJywgICAgICAgJ25hbWVzcGFjZScsICdwcml2YXRlJywgJ3B1YmxpYycsXG4gICdyZWNvcmQnLCAgICdzdGF0aWMnLCAgICAgJ3RlbXBsYXRlJywgICAndGhpcycsICAgICAgICAndHlwZScsICAgICAgJ3R5cGVkZWYnLFxuXSk7XG5cbi8qKlxuICogQSBsaXN0IG9mIEpTRG9jIEB0YWdzIHRoYXQgbWlnaHQgaW5jbHVkZSBhIHt0eXBlfSBhZnRlciB0aGVtLiBPbmx5IGJhbm5lZCB3aGVuIGEgdHlwZSBpcyBwYXNzZWQuXG4gKiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBpbmNsdWRlIHRhZ3MgdGhhdCBjYXJyeSBhIG5vbi10eXBlIHN5c3RlbSB0eXBlLCBlLmcuIFxcQHN1cHByZXNzLlxuICovXG5jb25zdCBKU0RPQ19UQUdTX1dJVEhfVFlQRVMgPSBuZXcgU2V0KFtcbiAgJ2NvbnN0JyxcbiAgJ2V4cG9ydCcsXG4gICdwYXJhbScsXG4gICdyZXR1cm4nLFxuXSk7XG5cbi8qKlxuICogUmVzdWx0IG9mIHBhcnNpbmcgYSBKU0RvYyBjb21tZW50LiBTdWNoIGNvbW1lbnRzIGVzc2VudGlhbGx5IGFyZSBidWlsdCBvZiBhIGxpc3Qgb2YgdGFncy5cbiAqIEluIGFkZGl0aW9uIHRvIHRoZSB0YWdzLCB0aGlzIG1pZ2h0IGFsc28gY29udGFpbiB3YXJuaW5ncyB0byBpbmRpY2F0ZSBub24tZmF0YWwgcHJvYmxlbXNcbiAqIHdoaWxlIGZpbmRpbmcgdGhlIHRhZ3MuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGFyc2VkSlNEb2NDb21tZW50IHtcbiAgdGFnczogVGFnW107XG4gIHdhcm5pbmdzPzogc3RyaW5nW107XG59XG5cbi8qKlxuICogcGFyc2UgcGFyc2VzIEpTRG9jIG91dCBvZiBhIGNvbW1lbnQgc3RyaW5nLlxuICogUmV0dXJucyBudWxsIGlmIGNvbW1lbnQgaXMgbm90IEpTRG9jLlxuICovXG4vLyBUT0RPKG1hcnRpbnByb2JzdCk6IHJlcHJlc2VudGluZyBKU0RvYyBhcyBhIGxpc3Qgb2YgdGFncyBpcyB0b28gc2ltcGxpc3RpYy4gV2UgbmVlZCBmdW5jdGlvbmFsaXR5XG4vLyBzdWNoIGFzIG1lcmdpbmcgKGJlbG93KSwgZGUtZHVwbGljYXRpbmcgY2VydGFpbiB0YWdzIChAZGVwcmVjYXRlZCksIGFuZCBzcGVjaWFsIHRyZWF0bWVudCBmb3Jcbi8vIG90aGVycyAoZS5nLiBAc3VwcHJlc3MpLiBXZSBzaG91bGQgaW50cm9kdWNlIGEgcHJvcGVyIG1vZGVsIGNsYXNzIHdpdGggYSBtb3JlIHN1aXRhYmxlIGRhdGFcbi8vIHN0cnVjdXJlIChlLmcuIGEgTWFwPFRhZ05hbWUsIFZhbHVlc1tdPikuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2UoY29tbWVudDogdHMuU3ludGhlc2l6ZWRDb21tZW50KTogUGFyc2VkSlNEb2NDb21tZW50fG51bGwge1xuICAvLyBUT0RPKGV2YW5tKTogdGhpcyBpcyBhIHBpbGUgb2YgaGFja3kgcmVnZXhlcyBmb3Igbm93LCBiZWNhdXNlIHdlXG4gIC8vIHdvdWxkIHJhdGhlciB1c2UgdGhlIGJldHRlciBUeXBlU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIEpTRG9jXG4gIC8vIHBhcnNpbmcuICBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzczOTNcbiAgaWYgKGNvbW1lbnQua2luZCAhPT0gdHMuU3ludGF4S2luZC5NdWx0aUxpbmVDb21tZW50VHJpdmlhKSByZXR1cm4gbnVsbDtcbiAgLy8gY29tbWVudC50ZXh0IGRvZXMgbm90IGluY2x1ZGUgLyogYW5kICovLCBzbyBtdXN0IHN0YXJ0IHdpdGggJyonIGZvciBKU0RvYy5cbiAgaWYgKGNvbW1lbnQudGV4dFswXSAhPT0gJyonKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgdGV4dCA9IGNvbW1lbnQudGV4dC5zdWJzdHJpbmcoMSkudHJpbSgpO1xuICByZXR1cm4gcGFyc2VDb250ZW50cyh0ZXh0KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnB1dCBzdHJpbmcgd2l0aCBsaW5lIGVuZGluZ3Mgbm9ybWFsaXplZCB0byAnXFxuJy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUxpbmVFbmRpbmdzKGlucHV0OiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKTtcbn1cblxuLyoqXG4gKiBwYXJzZUNvbnRlbnRzIHBhcnNlcyBKU0RvYyBvdXQgb2YgYSBjb21tZW50IHRleHQuXG4gKiBSZXR1cm5zIG51bGwgaWYgY29tbWVudCBpcyBub3QgSlNEb2MuXG4gKlxuICogQHBhcmFtIGNvbW1lbnRUZXh0IGEgY29tbWVudCdzIHRleHQgY29udGVudCwgaS5lLiB0aGUgY29tbWVudCB3L28gLyogYW5kICogLy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29udGVudHMoY29tbWVudFRleHQ6IHN0cmluZyk6IFBhcnNlZEpTRG9jQ29tbWVudHxudWxsIHtcbiAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgcHJvcGVyIGxpbmUgZW5kaW5ncyBiZWZvcmUgcGFyc2luZyBvbiBXaW5kb3dzLlxuICBjb21tZW50VGV4dCA9IG5vcm1hbGl6ZUxpbmVFbmRpbmdzKGNvbW1lbnRUZXh0KTtcbiAgLy8gU3RyaXAgYWxsIHRoZSBcIiAqIFwiIGJpdHMgZnJvbSB0aGUgZnJvbnQgb2YgZWFjaCBsaW5lLlxuICBjb21tZW50VGV4dCA9IGNvbW1lbnRUZXh0LnJlcGxhY2UoL15cXHMqXFwqPyA/L2dtLCAnJyk7XG4gIGNvbnN0IGxpbmVzID0gY29tbWVudFRleHQuc3BsaXQoJ1xcbicpO1xuICBjb25zdCB0YWdzOiBUYWdbXSA9IFtdO1xuICBjb25zdCB3YXJuaW5nczogc3RyaW5nW10gPSBbXTtcbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgbGV0IG1hdGNoID0gbGluZS5tYXRjaCgvXlxccypAKFxcUyspICooLiopLyk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBsZXQgW18sIHRhZ05hbWUsIHRleHRdID0gbWF0Y2g7XG4gICAgICBpZiAodGFnTmFtZSA9PT0gJ3JldHVybnMnKSB7XG4gICAgICAgIC8vIEEgc3lub255bSBmb3IgJ3JldHVybicuXG4gICAgICAgIHRhZ05hbWUgPSAncmV0dXJuJztcbiAgICAgIH1cbiAgICAgIGxldCB0eXBlOiBzdHJpbmd8dW5kZWZpbmVkO1xuICAgICAgaWYgKEpTRE9DX1RBR1NfQkxBQ0tMSVNULmhhcyh0YWdOYW1lKSkge1xuICAgICAgICB3YXJuaW5ncy5wdXNoKGBAJHt0YWdOYW1lfSBhbm5vdGF0aW9ucyBhcmUgcmVkdW5kYW50IHdpdGggVHlwZVNjcmlwdCBlcXVpdmFsZW50c2ApO1xuICAgICAgICBjb250aW51ZTsgIC8vIERyb3AgdGhlIHRhZyBzbyBDbG9zdXJlIHdvbid0IHByb2Nlc3MgaXQuXG4gICAgICB9IGVsc2UgaWYgKEpTRE9DX1RBR1NfV0lUSF9UWVBFUy5oYXModGFnTmFtZSkgJiYgdGV4dFswXSA9PT0gJ3snKSB7XG4gICAgICAgIHdhcm5pbmdzLnB1c2goXG4gICAgICAgICAgICBgdGhlIHR5cGUgYW5ub3RhdGlvbiBvbiBAJHt0YWdOYW1lfSBpcyByZWR1bmRhbnQgd2l0aCBpdHMgVHlwZVNjcmlwdCB0eXBlLCBgICtcbiAgICAgICAgICAgIGByZW1vdmUgdGhlIHsuLi59IHBhcnRgKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHRhZ05hbWUgPT09ICdzdXBwcmVzcycpIHtcbiAgICAgICAgY29uc3Qgc3VwcHJlc3NNYXRjaCA9IHRleHQubWF0Y2goL15cXHsoLiopXFx9KC4qKSQvKTtcbiAgICAgICAgaWYgKCFzdXBwcmVzc01hdGNoKSB7XG4gICAgICAgICAgd2FybmluZ3MucHVzaChgbWFsZm9ybWVkIEBzdXBwcmVzcyB0YWc6IFwiJHt0ZXh0fVwiYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgWywgdHlwZSwgdGV4dF0gPSBzdXBwcmVzc01hdGNoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRhZ05hbWUgPT09ICdkaWN0Jykge1xuICAgICAgICB3YXJuaW5ncy5wdXNoKCd1c2UgaW5kZXggc2lnbmF0dXJlcyAoYFtrOiBzdHJpbmddOiB0eXBlYCkgaW5zdGVhZCBvZiBAZGljdCcpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gR3JhYiB0aGUgcGFyYW1ldGVyIG5hbWUgZnJvbSBAcGFyYW0gdGFncy5cbiAgICAgIGxldCBwYXJhbWV0ZXJOYW1lOiBzdHJpbmd8dW5kZWZpbmVkO1xuICAgICAgaWYgKHRhZ05hbWUgPT09ICdwYXJhbScpIHtcbiAgICAgICAgbWF0Y2ggPSB0ZXh0Lm1hdGNoKC9eKFxcUyspID8oLiopLyk7XG4gICAgICAgIGlmIChtYXRjaCkgW18sIHBhcmFtZXRlck5hbWUsIHRleHRdID0gbWF0Y2g7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRhZzogVGFnID0ge3RhZ05hbWV9O1xuICAgICAgaWYgKHBhcmFtZXRlck5hbWUpIHRhZy5wYXJhbWV0ZXJOYW1lID0gcGFyYW1ldGVyTmFtZTtcbiAgICAgIGlmICh0ZXh0KSB0YWcudGV4dCA9IHRleHQ7XG4gICAgICBpZiAodHlwZSkgdGFnLnR5cGUgPSB0eXBlO1xuICAgICAgdGFncy5wdXNoKHRhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRleHQgd2l0aG91dCBhIHByZWNlZGluZyBAdGFnIG9uIGl0IGlzIGVpdGhlciB0aGUgcGxhaW4gdGV4dFxuICAgICAgLy8gZG9jdW1lbnRhdGlvbiBvciBhIGNvbnRpbnVhdGlvbiBvZiBhIHByZXZpb3VzIHRhZy5cbiAgICAgIGlmICh0YWdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0YWdzLnB1c2goe3RhZ05hbWU6ICcnLCB0ZXh0OiBsaW5lfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsYXN0VGFnID0gdGFnc1t0YWdzLmxlbmd0aCAtIDFdO1xuICAgICAgICBsYXN0VGFnLnRleHQgPSAobGFzdFRhZy50ZXh0IHx8ICcnKSArICdcXG4nICsgbGluZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4ge3RhZ3MsIHdhcm5pbmdzfTtcbiAgfVxuICByZXR1cm4ge3RhZ3N9O1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZXMgYSBUYWcgaW50byBhIHN0cmluZyB1c2FibGUgaW4gYSBjb21tZW50LlxuICogUmV0dXJucyBhIHN0cmluZyBsaWtlIFwiIEBmb28ge2Jhcn0gYmF6XCIgKG5vdGUgdGhlIHdoaXRlc3BhY2UpLlxuICovXG5mdW5jdGlvbiB0YWdUb1N0cmluZyh0YWc6IFRhZywgZXNjYXBlRXh0cmFUYWdzID0gbmV3IFNldDxzdHJpbmc+KCkpOiBzdHJpbmcge1xuICBsZXQgb3V0ID0gJyc7XG4gIGlmICh0YWcudGFnTmFtZSkge1xuICAgIGlmICghSlNET0NfVEFHU19XSElURUxJU1QuaGFzKHRhZy50YWdOYW1lKSB8fCBlc2NhcGVFeHRyYVRhZ3MuaGFzKHRhZy50YWdOYW1lKSkge1xuICAgICAgLy8gRXNjYXBlIHRhZ3Mgd2UgZG9uJ3QgdW5kZXJzdGFuZC4gIFRoaXMgaXMgYSBzdWJ0bGVcbiAgICAgIC8vIGNvbXByb21pc2UgYmV0d2VlbiBtdWx0aXBsZSBpc3N1ZXMuXG4gICAgICAvLyAxKSBJZiB3ZSBwYXNzIHRocm91Z2ggdGhlc2Ugbm9uLUNsb3N1cmUgdGFncywgdGhlIHVzZXIgd2lsbFxuICAgICAgLy8gICAgZ2V0IGEgd2FybmluZyBmcm9tIENsb3N1cmUsIGFuZCB0aGUgcG9pbnQgb2YgdHNpY2tsZSBpc1xuICAgICAgLy8gICAgdG8gaW5zdWxhdGUgdGhlIHVzZXIgZnJvbSBDbG9zdXJlLlxuICAgICAgLy8gMikgVGhlIG91dHB1dCBvZiB0c2lja2xlIGlzIGZvciBDbG9zdXJlIGJ1dCBhbHNvIG1heSBiZSByZWFkXG4gICAgICAvLyAgICBieSBodW1hbnMsIGZvciBleGFtcGxlIG5vbi1UeXBlU2NyaXB0IHVzZXJzIG9mIEFuZ3VsYXIuXG4gICAgICAvLyAzKSBGaW5hbGx5LCB3ZSBkb24ndCB3YW50IHRvIHdhcm4gYmVjYXVzZSB1c2VycyBzaG91bGQgYmVcbiAgICAgIC8vICAgIGZyZWUgdG8gYWRkIHdoaWNoZXZlciBKU0RvYyB0aGV5IGZlZWwgbGlrZS4gIElmIHRoZSB1c2VyXG4gICAgICAvLyAgICB3YW50cyBoZWxwIGVuc3VyaW5nIHRoZXkgZGlkbid0IHR5cG8gYSB0YWcsIHRoYXQgaXMgdGhlXG4gICAgICAvLyAgICByZXNwb25zaWJpbGl0eSBvZiBhIGxpbnRlci5cbiAgICAgIG91dCArPSBgIFxcXFxAJHt0YWcudGFnTmFtZX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gYCBAJHt0YWcudGFnTmFtZX1gO1xuICAgIH1cbiAgfVxuICBpZiAodGFnLnR5cGUpIHtcbiAgICBvdXQgKz0gJyB7JztcbiAgICBpZiAodGFnLnJlc3RQYXJhbSkge1xuICAgICAgb3V0ICs9ICcuLi4nO1xuICAgIH1cbiAgICBvdXQgKz0gdGFnLnR5cGU7XG4gICAgaWYgKHRhZy5vcHRpb25hbCkge1xuICAgICAgb3V0ICs9ICc9JztcbiAgICB9XG4gICAgb3V0ICs9ICd9JztcbiAgfVxuICBpZiAodGFnLnBhcmFtZXRlck5hbWUpIHtcbiAgICBvdXQgKz0gJyAnICsgdGFnLnBhcmFtZXRlck5hbWU7XG4gIH1cbiAgaWYgKHRhZy50ZXh0KSB7XG4gICAgb3V0ICs9ICcgJyArIHRhZy50ZXh0LnJlcGxhY2UoL0AvZywgJ1xcXFxAJyk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuLyoqIFRhZ3MgdGhhdCBtdXN0IG9ubHkgb2NjdXIgb25jZXMgaW4gYSBjb21tZW50IChmaWx0ZXJlZCBiZWxvdykuICovXG5jb25zdCBTSU5HTEVUT05fVEFHUyA9IG5ldyBTZXQoWydkZXByZWNhdGVkJ10pO1xuXG4vKiogVGFncyB0aGF0IGNvbmZsaWN0IHdpdGggXFxAdHlwZSBpbiBDbG9zdXJlIENvbXBpbGVyIChlLmcuIFxcQHBhcmFtKS4gKi9cbmV4cG9ydCBjb25zdCBUQUdTX0NPTkZMSUNUSU5HX1dJVEhfVFlQRSA9IG5ldyBTZXQoWydwYXJhbScsICdyZXR1cm4nXSk7XG5cbi8qKlxuICogQSBzeW50aGVzaXplZCBjb21tZW50IHRoYXQgKHBvc3NpYmx5KSBpbmNsdWRlcyB0aGUgb3JpZ2luYWwgY29tbWVudCByYW5nZSBpdCB3YXMgY3JlYXRlZCBmcm9tLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN5bnRoZXNpemVkQ29tbWVudFdpdGhPcmlnaW5hbCBleHRlbmRzIHRzLlN5bnRoZXNpemVkQ29tbWVudCB7XG4gIC8qKlxuICAgKiBUaGUgb3JpZ2luYWwgdGV4dCByYW5nZSBvZiB0aGUgY29tbWVudCAocmVsYXRpdmUgdG8gdGhlIHNvdXJjZSBmaWxlJ3MgZnVsbCB0ZXh0KS5cbiAgICovXG4gIG9yaWdpbmFsUmFuZ2U/OiB0cy5UZXh0UmFuZ2U7XG59XG5cbi8qKlxuICogc3ludGhlc2l6ZUxlYWRpbmdDb21tZW50cyBwYXJzZXMgdGhlIGxlYWRpbmcgY29tbWVudHMgb2Ygbm9kZSwgY29udmVydHMgdGhlbVxuICogdG8gc3ludGhldGljIGNvbW1lbnRzLCBhbmQgbWFrZXMgc3VyZSB0aGUgb3JpZ2luYWwgdGV4dCBjb21tZW50cyBkbyBub3QgZ2V0XG4gKiBlbWl0dGVkIGJ5IFR5cGVTY3JpcHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzeW50aGVzaXplTGVhZGluZ0NvbW1lbnRzKG5vZGU6IHRzLk5vZGUpOiBTeW50aGVzaXplZENvbW1lbnRXaXRoT3JpZ2luYWxbXSB7XG4gIGNvbnN0IGV4aXN0aW5nID0gdHMuZ2V0U3ludGhldGljTGVhZGluZ0NvbW1lbnRzKG5vZGUpO1xuICBpZiAoZXhpc3RpbmcpIHJldHVybiBleGlzdGluZztcbiAgY29uc3QgdGV4dCA9IG5vZGUuZ2V0RnVsbFRleHQoKTtcbiAgY29uc3Qgc3ludGhDb21tZW50cyA9IGdldExlYWRpbmdDb21tZW50UmFuZ2VzU3ludGhlc2l6ZWQodGV4dCwgbm9kZS5nZXRGdWxsU3RhcnQoKSk7XG4gIGlmIChzeW50aENvbW1lbnRzLmxlbmd0aCkge1xuICAgIHRzLnNldFN5bnRoZXRpY0xlYWRpbmdDb21tZW50cyhub2RlLCBzeW50aENvbW1lbnRzKTtcbiAgICBzdXBwcmVzc0xlYWRpbmdDb21tZW50c1JlY3Vyc2l2ZWx5KG5vZGUpO1xuICB9XG4gIHJldHVybiBzeW50aENvbW1lbnRzO1xufVxuXG4vKipcbiAqIHBhcnNlTGVhZGluZ0NvbW1lbnRSYW5nZXNTeW50aGVzaXplZCBwYXJzZXMgdGhlIGxlYWRpbmcgY29tbWVudCByYW5nZXMgb3V0IG9mIHRoZSBnaXZlbiB0ZXh0IGFuZFxuICogY29udmVydHMgdGhlbSB0byBTeW50aGVzaXplZENvbW1lbnRzLlxuICogQHBhcmFtIG9mZnNldCB0aGUgb2Zmc2V0IG9mIHRleHQgaW4gdGhlIHNvdXJjZSBmaWxlLCBlLmcuIG5vZGUuZ2V0RnVsbFN0YXJ0KCkuXG4gKi9cbi8vIFZpc2libGVGb3JUZXN0aW5nXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGVhZGluZ0NvbW1lbnRSYW5nZXNTeW50aGVzaXplZChcbiAgICB0ZXh0OiBzdHJpbmcsIG9mZnNldCA9IDApOiBTeW50aGVzaXplZENvbW1lbnRXaXRoT3JpZ2luYWxbXSB7XG4gIGNvbnN0IGNvbW1lbnRzID0gdHMuZ2V0TGVhZGluZ0NvbW1lbnRSYW5nZXModGV4dCwgMCkgfHwgW107XG4gIHJldHVybiBjb21tZW50cy5tYXAoKGNyKTogU3ludGhlc2l6ZWRDb21tZW50V2l0aE9yaWdpbmFsID0+IHtcbiAgICAvLyBDb25mdXNpbmdseSwgQ29tbWVudFJhbmdlIGluIFR5cGVTY3JpcHQgaW5jbHVkZXMgc3RhcnQgYW5kIGVuZCBtYXJrZXJzLCBidXRcbiAgICAvLyBTeW50aGVzaXplZENvbW1lbnRzIGRvIG5vdC5cbiAgICBjb25zdCBjb21tZW50VGV4dCA9IGNyLmtpbmQgPT09IHRzLlN5bnRheEtpbmQuU2luZ2xlTGluZUNvbW1lbnRUcml2aWEgP1xuICAgICAgICB0ZXh0LnN1YnN0cmluZyhjci5wb3MgKyAyLCBjci5lbmQpIDpcbiAgICAgICAgdGV4dC5zdWJzdHJpbmcoY3IucG9zICsgMiwgY3IuZW5kIC0gMik7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNyLFxuICAgICAgdGV4dDogY29tbWVudFRleHQsXG4gICAgICBwb3M6IC0xLFxuICAgICAgZW5kOiAtMSxcbiAgICAgIG9yaWdpbmFsUmFuZ2U6IHtwb3M6IGNyLnBvcyArIG9mZnNldCwgZW5kOiBjci5lbmQgKyBvZmZzZXR9XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qKlxuICogc3VwcHJlc3NDb21tZW50c1JlY3Vyc2l2ZWx5IHByZXZlbnRzIGVtaXQgb2YgbGVhZGluZyBjb21tZW50cyBvbiBub2RlLCBhbmQgYW55IHJlY3Vyc2l2ZSBub2Rlc1xuICogdW5kZXJuZWF0aCBpdCB0aGF0IHN0YXJ0IGF0IHRoZSBzYW1lIG9mZnNldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1cHByZXNzTGVhZGluZ0NvbW1lbnRzUmVjdXJzaXZlbHkobm9kZTogdHMuTm9kZSkge1xuICAvLyBUeXBlU2NyaXB0IGVtaXRzIGxlYWRpbmcgY29tbWVudHMgb24gYSBub2RlLCB1bmxlc3M6XG4gIC8vIC0gdGhlIGNvbW1lbnQgd2FzIGVtaXR0ZWQgYnkgdGhlIHBhcmVudCBub2RlXG4gIC8vIC0gdGhlIG5vZGUgaGFzIHRoZSBOb0xlYWRpbmdDb21tZW50cyBlbWl0IGZsYWcuXG4gIC8vIEhvd2V2ZXIsIHRyYW5zZm9ybWF0aW9uIHN0ZXBzIHNvbWV0aW1lcyBjb3B5IG5vZGVzIHdpdGhvdXQga2VlcGluZyB0aGVpciBlbWl0IGZsYWdzLCBzbyBqdXN0XG4gIC8vIHNldHRpbmcgTm9MZWFkaW5nQ29tbWVudHMgcmVjdXJzaXZlbHkgaXMgbm90IGVub3VnaCwgd2UgbXVzdCBhbHNvIHNldCB0aGUgdGV4dCByYW5nZSB0byBhdm9pZFxuICAvLyB0aGUgY29waWVkIG5vZGUgdG8gaGF2ZSBjb21tZW50cyBlbWl0dGVkLlxuICBjb25zdCBvcmlnaW5hbFN0YXJ0ID0gbm9kZS5nZXRGdWxsU3RhcnQoKTtcbiAgY29uc3QgYWN0dWFsU3RhcnQgPSBub2RlLmdldFN0YXJ0KCk7XG4gIGZ1bmN0aW9uIHN1cHByZXNzQ29tbWVudHNJbnRlcm5hbChub2RlOiB0cy5Ob2RlKTogYm9vbGVhbiB7XG4gICAgdHMuc2V0RW1pdEZsYWdzKG5vZGUsIHRzLkVtaXRGbGFncy5Ob0xlYWRpbmdDb21tZW50cyk7XG4gICAgcmV0dXJuICEhdHMuZm9yRWFjaENoaWxkKG5vZGUsIChjaGlsZCkgPT4ge1xuICAgICAgaWYgKGNoaWxkLnBvcyAhPT0gb3JpZ2luYWxTdGFydCkgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gc3VwcHJlc3NDb21tZW50c0ludGVybmFsKGNoaWxkKTtcbiAgICB9KTtcbiAgfVxuICBzdXBwcmVzc0NvbW1lbnRzSW50ZXJuYWwobm9kZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1N5bnRoZXNpemVkQ29tbWVudChcbiAgICB0YWdzOiBUYWdbXSwgZXNjYXBlRXh0cmFUYWdzPzogU2V0PHN0cmluZz4pOiB0cy5TeW50aGVzaXplZENvbW1lbnQge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IHRzLlN5bnRheEtpbmQuTXVsdGlMaW5lQ29tbWVudFRyaXZpYSxcbiAgICB0ZXh0OiB0b1N0cmluZ1dpdGhvdXRTdGFydEVuZCh0YWdzLCBlc2NhcGVFeHRyYVRhZ3MpLFxuICAgIHBvczogLTEsXG4gICAgZW5kOiAtMSxcbiAgICBoYXNUcmFpbGluZ05ld0xpbmU6IHRydWUsXG4gIH07XG59XG5cbi8qKiBTZXJpYWxpemVzIGEgQ29tbWVudCBvdXQgdG8gYSBzdHJpbmcsIGJ1dCBkb2VzIG5vdCBpbmNsdWRlIHRoZSBzdGFydCBhbmQgZW5kIGNvbW1lbnQgdG9rZW5zLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nV2l0aG91dFN0YXJ0RW5kKHRhZ3M6IFRhZ1tdLCBlc2NhcGVFeHRyYVRhZ3MgPSBuZXcgU2V0PHN0cmluZz4oKSk6IHN0cmluZyB7XG4gIHJldHVybiBzZXJpYWxpemUodGFncywgZmFsc2UsIGVzY2FwZUV4dHJhVGFncyk7XG59XG5cbi8qKiBTZXJpYWxpemVzIGEgQ29tbWVudCBvdXQgdG8gYSBzdHJpbmcgdXNhYmxlIGluIHNvdXJjZSBjb2RlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nKHRhZ3M6IFRhZ1tdLCBlc2NhcGVFeHRyYVRhZ3MgPSBuZXcgU2V0PHN0cmluZz4oKSk6IHN0cmluZyB7XG4gIHJldHVybiBzZXJpYWxpemUodGFncywgdHJ1ZSwgZXNjYXBlRXh0cmFUYWdzKTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplKFxuICAgIHRhZ3M6IFRhZ1tdLCBpbmNsdWRlU3RhcnRFbmQ6IGJvb2xlYW4sIGVzY2FwZUV4dHJhVGFncyA9IG5ldyBTZXQ8c3RyaW5nPigpKTogc3RyaW5nIHtcbiAgaWYgKHRhZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIGlmICh0YWdzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IHRhZyA9IHRhZ3NbMF07XG4gICAgaWYgKCh0YWcudGFnTmFtZSA9PT0gJ3R5cGUnIHx8IHRhZy50YWdOYW1lID09PSAndHlwZWRlZicgfHwgdGFnLnRhZ05hbWUgPT09ICdub2NvbGxhcHNlJykgJiZcbiAgICAgICAgKCF0YWcudGV4dCB8fCAhdGFnLnRleHQubWF0Y2goJ1xcbicpKSkge1xuICAgICAgLy8gU3BlY2lhbC1jYXNlIG9uZS1saW5lciBcInR5cGVcIiBhbmQgXCJub2NvbGxhcHNlXCIgdGFncyB0byBmaXQgb24gb25lIGxpbmUsIGUuZy5cbiAgICAgIC8vICAgLyoqIEB0eXBlIHtmb299ICovXG4gICAgICBjb25zdCB0ZXh0ID0gdGFnVG9TdHJpbmcodGFnLCBlc2NhcGVFeHRyYVRhZ3MpO1xuICAgICAgcmV0dXJuIGluY2x1ZGVTdGFydEVuZCA/IGAvKioke3RleHR9ICovYCA6IGAqJHt0ZXh0fSBgO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIGZhbGwgdGhyb3VnaCB0byB0aGUgbXVsdGktbGluZSBvdXRwdXQuXG4gIH1cblxuICBsZXQgb3V0ID0gaW5jbHVkZVN0YXJ0RW5kID8gJy8qKlxcbicgOiAnKlxcbic7XG4gIGNvbnN0IGVtaXR0ZWQgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgZm9yIChjb25zdCB0YWcgb2YgdGFncykge1xuICAgIGlmIChlbWl0dGVkLmhhcyh0YWcudGFnTmFtZSkgJiYgU0lOR0xFVE9OX1RBR1MuaGFzKHRhZy50YWdOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGVtaXR0ZWQuYWRkKHRhZy50YWdOYW1lKTtcbiAgICBvdXQgKz0gJyAqJztcbiAgICAvLyBJZiB0aGUgdGFnVG9TdHJpbmcgaXMgbXVsdGktbGluZSwgaW5zZXJ0IFwiICogXCIgcHJlZml4ZXMgb24gc3Vic2VxdWVudCBsaW5lcy5cbiAgICBvdXQgKz0gdGFnVG9TdHJpbmcodGFnLCBlc2NhcGVFeHRyYVRhZ3MpLnNwbGl0KCdcXG4nKS5qb2luKCdcXG4gKiAnKTtcbiAgICBvdXQgKz0gJ1xcbic7XG4gIH1cbiAgb3V0ICs9IGluY2x1ZGVTdGFydEVuZCA/ICcgKi9cXG4nIDogJyAnO1xuICByZXR1cm4gb3V0O1xufVxuXG4vKiogTWVyZ2VzIG11bHRpcGxlIHRhZ3MgKG9mIHRoZSBzYW1lIHRhZ05hbWUgdHlwZSkgaW50byBhIHNpbmdsZSB1bmlmaWVkIHRhZy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZSh0YWdzOiBUYWdbXSk6IFRhZyB7XG4gIGNvbnN0IHRhZ05hbWVzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGNvbnN0IHBhcmFtZXRlck5hbWVzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGNvbnN0IHR5cGVzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGNvbnN0IHRleHRzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIC8vIElmIGFueSBvZiB0aGUgdGFncyBhcmUgb3B0aW9uYWwvcmVzdCwgdGhlbiB0aGUgbWVyZ2VkIG91dHB1dCBpcyBvcHRpb25hbC9yZXN0LlxuICBsZXQgb3B0aW9uYWwgPSBmYWxzZTtcbiAgbGV0IHJlc3RQYXJhbSA9IGZhbHNlO1xuICBmb3IgKGNvbnN0IHRhZyBvZiB0YWdzKSB7XG4gICAgdGFnTmFtZXMuYWRkKHRhZy50YWdOYW1lKTtcbiAgICBpZiAodGFnLnBhcmFtZXRlck5hbWUgIT09IHVuZGVmaW5lZCkgcGFyYW1ldGVyTmFtZXMuYWRkKHRhZy5wYXJhbWV0ZXJOYW1lKTtcbiAgICBpZiAodGFnLnR5cGUgIT09IHVuZGVmaW5lZCkgdHlwZXMuYWRkKHRhZy50eXBlKTtcbiAgICBpZiAodGFnLnRleHQgIT09IHVuZGVmaW5lZCkgdGV4dHMuYWRkKHRhZy50ZXh0KTtcbiAgICBpZiAodGFnLm9wdGlvbmFsKSBvcHRpb25hbCA9IHRydWU7XG4gICAgaWYgKHRhZy5yZXN0UGFyYW0pIHJlc3RQYXJhbSA9IHRydWU7XG4gIH1cblxuICBpZiAodGFnTmFtZXMuc2l6ZSAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IG1lcmdlIGRpZmZlcmluZyB0YWdzOiAke0pTT04uc3RyaW5naWZ5KHRhZ3MpfWApO1xuICB9XG4gIGNvbnN0IHRhZ05hbWUgPSB0YWdOYW1lcy52YWx1ZXMoKS5uZXh0KCkudmFsdWU7XG4gIGNvbnN0IHBhcmFtZXRlck5hbWUgPVxuICAgICAgcGFyYW1ldGVyTmFtZXMuc2l6ZSA+IDAgPyBBcnJheS5mcm9tKHBhcmFtZXRlck5hbWVzKS5qb2luKCdfb3JfJykgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHR5cGUgPSB0eXBlcy5zaXplID4gMCA/IEFycmF5LmZyb20odHlwZXMpLmpvaW4oJ3wnKSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgdGV4dCA9IHRleHRzLnNpemUgPiAwID8gQXJyYXkuZnJvbSh0ZXh0cykuam9pbignIC8gJykgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IHRhZzogVGFnID0ge3RhZ05hbWUsIHBhcmFtZXRlck5hbWUsIHR5cGUsIHRleHR9O1xuICAvLyBOb3RlOiBhIHBhcmFtIGNhbiBlaXRoZXIgYmUgb3B0aW9uYWwgb3IgYSByZXN0IHBhcmFtOyBpZiB3ZSBtZXJnZWQgYW5cbiAgLy8gb3B0aW9uYWwgYW5kIHJlc3QgcGFyYW0gdG9nZXRoZXIsIHByZWZlciBtYXJraW5nIGl0IGFzIGEgcmVzdCBwYXJhbS5cbiAgaWYgKHJlc3RQYXJhbSkge1xuICAgIHRhZy5yZXN0UGFyYW0gPSB0cnVlO1xuICB9IGVsc2UgaWYgKG9wdGlvbmFsKSB7XG4gICAgdGFnLm9wdGlvbmFsID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gdGFnO1xufVxuIl19